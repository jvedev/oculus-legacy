/* cls_ajax */
/* Load Timestamp 13:59:55.616 */
/*
 * AdvancedAJAX 1.1.2
 * (c) 2005-2006 Lukasz Lach
 *  mail: anakin@php5.pl
 *  www:  http://advajax.anakin.us/
 *        http://anakin.us/
 * http://creativecommons.org/licenses/LGPL/2.1/
 *
 */

function advAJAX() {

    var obj=new Object();

    obj.url=window.location.href;
    obj.method="GET";
    obj.parameters=new Object();
    obj.jsonParameters=new Object();
    obj.headers=new Object();
    obj.async=true;
    obj.mimeType="text/xml";
    obj.username=null;
    obj.password=null;
    obj.form=null;
    obj.disableForm=true;

    obj.unique=true;
    obj.uniqueParameter="_uniqid";

    obj.requestDone=false;
    obj.queryString="";
    obj.responseText=null;
    obj.responseXML=null;
    obj.status=null;
    obj.statusText=null;
    obj.aborted=false;
    obj.timeout=0;
    obj.retryCount=0;
    obj.retryDelay=1000;
    obj.tag=null;
    obj.group=null;
    obj.progressTimerInterval=50;

    obj.xmlHttpRequest=null;

    obj.onInitialization=null;
    obj.onFinalization=null;
    obj.onReadyStateChange=null;
    obj.onLoading=null;
    obj.onLoaded=null;
    obj.onInteractive=null;
    obj.onComplete=null;
    obj.onProgress=null;
    obj.onSuccess=null;
    obj.onFatalError=null;
    obj.onError=null;
    obj.onTimeout=null;
    obj.onRetryDelay=null;
    obj.onRetry=null;
    obj.onGroupEnter=null;
    obj.onGroupLeave=null;

    obj.createXmlHttpRequest=function() {

        if (typeof XMLHttpRequest != "undefined")
            return new XMLHttpRequest();
        var xhrVersion=[ "MSXML2.XMLHttp.5.0", "MSXML2.XMLHttp.4.0","MSXML2.XMLHttp.3.0",
            "MSXML2.XMLHttp","Microsoft.XMLHttp" ];
        for (var i=0; i < xhrVersion.length; i++) {
            try {
                var xhrObj=new ActiveXObject(xhrVersion[i]);
                return xhrObj;
            } catch (e) { }
        }
        obj.raiseEvent("FatalError");
        return null;
    };

    obj._oldResponseLength=null;
    obj._progressTimer=null;
    obj._progressStarted=navigator.userAgent.indexOf('Opera') == -1;
    obj._onProgress=function() {

        if (typeof obj.onProgress == "function" &&
            typeof obj.xmlHttpRequest.getResponseHeader == "function") {
            var contentLength=obj.xmlHttpRequest.getResponseHeader("Content-length");
            if (contentLength != null && contentLength != '') {
                var responseLength=obj.xmlHttpRequest.responseText.length;
                if (responseLength != obj._oldResponseLength) {
                    obj.raiseEvent("Progress", obj, responseLength, contentLength);
                    obj._oldResponseLength=obj.xmlHttpRequest.responseText.length;
                }
            }
        }
        if (obj._progressStarted) return;
        obj._progressStarted=true;
        var _obj=this;
        this.__onProgress=function() {
            obj._onProgress();
            obj._progressTimer=window.setTimeout(_obj.__onProgress, obj.progressTimerInterval);
        };
        _obj.__onProgress();
    };

    obj._onInitializationHandled=false;
    obj._initObject=function() {

        if (obj.xmlHttpRequest != null) {
            delete obj.xmlHttpRequest["onreadystatechange"];
            obj.xmlHttpRequest=null;
        }
        if ((obj.xmlHttpRequest=obj.createXmlHttpRequest()) == null)
            return null;
        if (typeof obj.xmlHttpRequest.overrideMimeType != "undefined")
            obj.xmlHttpRequest.overrideMimeType(obj.mimeType);
        obj.xmlHttpRequest.onreadystatechange=function() {

            if (obj == null || obj.xmlHttpRequest == null)
                return;
            obj.raiseEvent("ReadyStateChange", obj, obj.xmlHttpRequest.readyState);
            obj._onProgress();
            switch (obj.xmlHttpRequest.readyState) {
                case 1: obj._onLoading(); break;
                case 2: obj._onLoaded(); break;
                case 3: obj._onInteractive(); break;
                case 4: obj._onComplete(); break;
            }
        };
        obj._onLoadingHandled =
            obj._onLoadedHandled =
                obj._onInteractiveHandled =
                    obj._onCompleteHandled=false;
    };

    obj._onLoading=function() {

        if (obj._onLoadingHandled)
            return;
        if (!obj._retry && obj.group != null) {
            if (typeof advAJAX._groupData[obj.group] == "undefined")
                advAJAX._groupData[obj.group]=0;
            advAJAX._groupData[obj.group]++;
            if (typeof obj.onGroupEnter == "function" && advAJAX._groupData[obj.group] == 1)
                obj.onGroupEnter(obj);
        }
        obj.raiseEvent("Loading", obj);
        obj._onLoadingHandled=true;
    };
    obj._onLoaded=function() {

        if (obj._onLoadedHandled)
            return;
        obj.raiseEvent("Loaded", obj);
        obj._onLoadedHandled=true;
    };
    obj._onInteractive=function() {

        if (obj._onInteractiveHandled)
            return;
        obj.raiseEvent("Interactive", obj);
        obj._onInteractiveHandled=true;
        if (!obj._progressStarted)
            obj._onProgress();
    };
    obj._onComplete=function() {

        if (obj._onCompleteHandled || obj.aborted)
            return;
        if (obj._progressStarted) {
            window.clearInterval(obj._progressTimer);
            obj._progressStarted=false;
        }
        obj.requestDone=true;
        obj.responseText=obj.xmlHttpRequest.responseText;
        obj.responseXML=obj.xmlHttpRequest.responseXML;
        if (typeof obj.xmlHttpRequest.status != "undefined")
            obj.status=obj.xmlHttpRequest.status;
        if (typeof obj.xmlHttpRequest.statusText != "undefined")
            obj.statusText=obj.xmlHttpRequest.statusText;
        obj.raiseEvent("Complete", obj);
        obj._onCompleteHandled=true;
        if (obj.status == 200)
            obj.raiseEvent("Success", obj); else
            obj.raiseEvent("Error", obj);
        delete obj.xmlHttpRequest['onreadystatechange'];
        obj.xmlHttpRequest=null;
        if (obj.disableForm)
            obj.switchForm(true);
        obj._groupLeave();
        obj.raiseEvent("Finalization", obj);
    };

    obj._groupLeave=function() {

        if (obj.group != null) {
            advAJAX._groupData[obj.group]--;
            if (advAJAX._groupData[obj.group] == 0)
                obj.raiseEvent("GroupLeave", obj);
        }
    };

    obj._retry=false;
    obj._retryNo=0;
    obj._onTimeout=function() {

        if (obj == null || obj.xmlHttpRequest == null || obj._onCompleteHandled)
            return;
        obj.aborted=true;
        obj.xmlHttpRequest.abort();
        obj.raiseEvent("Timeout", obj);
        obj._retry=true;
        if (obj._retryNo != obj.retryCount) {
            obj._initObject();
            if (obj.retryDelay > 0) {
                obj.raiseEvent("RetryDelay", obj);
                startTime=new Date().getTime();
                while (new Date().getTime() - startTime < obj.retryDelay);
            }
            obj._retryNo++;
            obj.raiseEvent("Retry", obj, obj._retryNo);
            obj.run();
        } else {
            delete obj.xmlHttpRequest["onreadystatechange"];
            obj.xmlHttpRequest=null;
            if (obj.disableForm)
                obj.switchForm(true);
            obj._groupLeave();
            obj.raiseEvent("Finalization", obj);
        }
    };

    obj.run=function() {

        obj._initObject();
        if (obj.xmlHttpRequest == null)
            return false;
        obj.aborted=false;
        if (!obj._onInitializationHandled) {
            obj.raiseEvent("Initialization", obj);
            obj._onInitializationHandled=true;
        }
        if (obj.method == "GET" && obj.unique)
            obj.parameters[encodeURIComponent(obj.uniqueParameter)] =
                new Date().getTime().toString().substr(5) + Math.floor(Math.random() * 100).toString();
        if (!obj._retry) {
            for (var a in obj.parameters) {
                if (obj.queryString.length > 0)
                    obj.queryString += "&";
                if (typeof obj.parameters[a] != "object")
                    obj.queryString += encodeURIComponent(a) + "=" + encodeURIComponent(obj.parameters[a]); else {
                    for (var i=0; i < obj.parameters[a].length; i++)
                        obj.queryString += encodeURIComponent(a) + "=" + encodeURIComponent(obj.parameters[a][i]) + "&";
                    obj.queryString=obj.queryString.slice(0, -1);
                }
            }
            for (var a in obj.jsonParameters) {
                var useJson=typeof [].toJSONString == 'function';
                if (obj.queryString.length > 0)
                    obj.queryString += "&";
                obj.queryString += encodeURIComponent(a) + "=";
                if (useJson)
                    obj.queryString += encodeURIComponent(obj.jsonParameters[a].toJSONString()); else
                    obj.queryString += encodeURIComponent(obj.jsonParameters[a]);
            }
            if (obj.method == "GET" && obj.queryString.length > 0)
                obj.url += (obj.url.indexOf("?") != -1 ? "&" : "?") + obj.queryString;
        }
        if (obj.disableForm)
            obj.switchForm(false);
        try {
            obj.xmlHttpRequest.open(obj.method, obj.url, obj.async, obj.username || '', obj.password || '');
        } catch (e) {
            obj.raiseEvent("FatalError", obj, e);
            return;
        }
        if (obj.timeout > 0)
            setTimeout(obj._onTimeout, obj.timeout);
        if (typeof obj.xmlHttpRequest.setRequestHeader != "undefined")
            for (var a in obj.headers)
                obj.xmlHttpRequest.setRequestHeader(encodeURIComponent(a), encodeURIComponent(obj.headers[a]));
        if (obj.method == "POST" && typeof obj.xmlHttpRequest.setRequestHeader != "undefined") {
            obj.xmlHttpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            obj.xmlHttpRequest.send(obj.queryString);
        } else if (obj.method == "GET")
            obj.xmlHttpRequest.send('');
    };

    obj.handleArguments=function(args) {

        if (typeof args.form == "object" && args.form != null) {
            obj.form=args.form;
            obj.appendForm();
        }
        for (var a in args) {
            if (typeof obj[a] == "undefined")
                obj.parameters[a]=args[a]; else {
                if (a != "parameters" && a != "headers")
                    obj[a]=args[a]; else
                    for (b in args[a])
                        obj[a][b]=args[a][b];
            }
        }
        obj.method=obj.method.toUpperCase();
    };

    obj.switchForm=function(enable) {

        if (typeof obj.form != "object" || obj.form == null)
            return;
        for (var nr=0; nr < obj.form.elements.length; nr++)
            if (!enable) {
                if (obj.form.elements[nr]["disabled"])
                    obj.form.elements[nr]["_disabled"]=true; else
                    obj.form.elements[nr]["disabled"]="disabled";
            } else
            if (typeof obj.form.elements[nr]["_disabled"] == "undefined")
                obj.form.elements[nr].removeAttribute("disabled");
    };

    obj.appendForm=function() {

        obj.method=obj.form.getAttribute("method").toUpperCase();
        obj.url=obj.form.getAttribute("action");
        for (var nr=0; nr < obj.form.elements.length; nr++) {
            var e=obj.form.elements[nr];
            if (e.disabled)
                continue;
            switch (e.type) {
                case "text":
                case "password":
                case "hidden":
                case "textarea":
                    obj.addParameter(e.name, e.value);
                    break;
                case "select-one":
                    if (e.selectedIndex >= 0)
                        obj.addParameter(e.name, e.options[e.selectedIndex].value);
                    break;
                case "select-multiple":
                    for (var nr2=0; nr2 < e.options.length; nr2++)
                        if (e.options[nr2].selected)
                            obj.addParameter(e.name, e.options[nr2].value);
                    break;
                case "checkbox":
                case "radio":
                    if (e.checked)
                        obj.addParameter(e.name, e.value);
                    break;
            }
        }
    };

    obj.addParameter=function(name, value) {
        if (typeof obj.parameters[name] == "undefined")
            obj.parameters[name]=value; else
        if (typeof obj.parameters[name] != "object")
            obj.parameters[name]=[ obj.parameters[name], value ]; else
            obj.parameters[name][obj.parameters[name].length]=value;
    };
    obj.delParameter=function(name) {

        delete obj.parameters[name];
    };
    obj.raiseEvent=function(name) {
        var args=[];
        for (var i=1; i < arguments.length; i++)
            args.push(arguments[i]);
        if (typeof obj["on" + name] == "function")
            obj["on" + name].apply(null, args);
        if (name == "FatalError")
            obj.raiseEvent("Finalization", obj);
    };

    if (typeof advAJAX._defaultParameters != "undefined")
        obj.handleArguments(advAJAX._defaultParameters);
    return obj;
}

advAJAX.get=function(args) {

    return advAJAX.handleRequest("GET", args);
};

advAJAX.post=function(args) {

    return advAJAX.handleRequest("POST", args);
};

advAJAX.head=function(args) {

    return advAJAX.handleRequest("HEAD", args);
};

advAJAX.submit=function(form, args) {

    if (typeof args == "undefined" || args == null)
        return -1;
    if (typeof form != "object" || form == null)
        return -2;
    var request=new advAJAX();
    args["form"]=form;
    request.handleArguments(args);
    return request.run();
};

advAJAX.assign=function(form, args) {

    if (typeof args == "undefined" || args == null)
        return -1;
    if (typeof form != "object" || form == null)
        return -2;
    if (typeof form["onsubmit"] == "function")
        form["_onsubmit"]=form["onsubmit"];
    form["advajax_args"]=args;
    form["onsubmit"]=function() {
        if (typeof this["_onsubmit"] != "undefined" && this["_onsubmit"]() === false)
            return false;
        if (advAJAX.submit(this, this["advajax_args"]) == false)
            return true;
        return false;
    };
    return true;
};

advAJAX.download=function(targetObject, url) {
    var targetObj = targetObject;
    if (typeof targetObj == "string")
        targetObj=document.getElementById(targetObj);
    if (!targetObj)
        return -1;
    advAJAX.get({
        url: url,
        onSuccess : function(obj) {
            targetObj.innerHTML=obj.responseText;
        }
    });
};

advAJAX.scan=function() {

    var obj=document.getElementsByTagName("a");
    for (var i=0; i < obj.length;) {
        if (obj[i].getAttribute("rel") == "advancedajax" && obj[i].getAttribute("href") !== null) {
            var url=obj[i].getAttribute("href");
            var div=document.createElement("div");
            div.innerHTML=obj[i].innerHTML;
            div.className=obj[i].className;
            var parent=obj[i].parentNode;
            parent.insertBefore(div, obj[i]);
            parent.removeChild(obj[i]);
            advAJAX.download(div, url);
        } else i++;
    }
};

advAJAX.handleRequest=function(requestType, args) {

    if (typeof args == "undefined" || args == null)
        return -1;
    var request=new advAJAX();
    window.advajax_obj=request;
    request.method=requestType;
    request.handleArguments(args);
    return request.run();
};

advAJAX._defaultParameters=new Object();
advAJAX.setDefaultParameters=function(args) {

    advAJAX._defaultParameters=new Object();
    for (var a in args)
        advAJAX._defaultParameters[a]=args[a];
};

advAJAX._groupData=new Object();

/* boxfcn */
/* Load Timestamp 13:59:55.617 */
/****************************************************************************************/
/*        Section: String prototypes                                                    */
/* global Lines, BrowserDetect, ENUM, MAIN, SESSION, SETTINGS */

/** ************************************************************************************* */

String.prototype.removeTrailingZeros = function () {
    var sOut = "0." + this;
    sOut = parseFloat(sOut).toString();
    sOut = sOut.replace('0.', '');
    if (sOut == "0") {
        return "";
    }
    return sOut;
};

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (compareString) {
        var stringValue = '';
        if (this.typeof != 'String') {
            stringValue = this.toString();
        } else {
            stringValue = this;
        }

        if (stringValue == '' & compareString == '') {
            return true;
        }
        return (stringValue.indexOf(compareString) == 0 && compareString != '');
    };
}

if (!String.prototype.like) {
    /**
     * vergelijkt string met compareString case Insensitive
     * @param compareString
     * @returns {Boolean}
     */
    String.prototype.like = function (compareString) {
        return (this.toLowerCase().indexOf(compareString.toLowerCase()) > -1);
    };
}

if (!String.prototype.rgtzro) {
    String.prototype.rgtzro = function (n) {
        /* gebruik:
          var a=' '.rgtzro(5); // a == '50000'
         */
        if (this.length > 0) {
            return this + '0'.times(n - this.length);
        }
        return this;
    };
}

/**
 * String.nonBreakingSpace
 * geeft een string terug waar van de ' ' (spaties) vervangen zijn door &nbsp; maar dan via de unicode escape sequense '\u00a0'
 * @returns String waar van de ' ' (spaties) vervangen zij door de unicode escape sequense '\u00a0'
 *
 */
if (!String.prototype.nonBreakingSpace) {
    String.prototype.nonBreakingSpace = function () {
        return this.replace(/ /g, '\u00a0');
    };
}

String.prototype.times = function (n) {
    /* gebruik:
      var r='hoi', q;
      r=r.times(5);  // r == 'hoihoihoihoihoi'
      q='0'.times(4) // q == '0000'
     */
    var s = '';
    for (var i = 0; i < n; i++) {
        s += this;
    }
    return s;
};

if (!String.prototype.lftzro) {
    String.prototype.lftzro = function (n) {
        /* gebruik:
          var a='5'.lftzro(5); // a == '00005'
         */
        return '0'.times(n - this.length) + this;
    };
}

String.prototype.replaceAll = function (search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};


if (!String.prototype.lftblk) {
    String.prototype.lftblk = function (n) {
        /* gebruik:
          var a=' '.lftblk(5); // a == '    5'
         */
        if (this.length > 0) {
            return ' '.times(n - this.length) + this;
        }
        return this;

    };
}

if (!String.prototype.rgtblk) {
    String.prototype.rgtblk = function (n) {
        /* gebruik:
          var a=' '.lftblk(5); // a == '5    '
         */
        if (this.length > 0) {
            return this + ' '.times(n - this.length);
        }
        return this;
    };
}

if (!String.prototype.trim) {
    String.prototype.trim = function () {
        /* gebruik:
          var a=' blabla  '.trim(); // a='blabla'
         */
        a = this.replace(/^\s+/, '');
        return a.replace(/\s+$/, '');
    };
}
if (!String.prototype.trimright) {
    String.prototype.trimright = function () {
        // trim right
        /* gebruik:
          var a=' blabla  '.trimright(); // a=' blabla'
         */
        return this.replace(/\s+$/, '');
    };
}

if (!String.prototype.trimleft) {
    String.prototype.trimleft = function () {
        // trim right
        /* gebruik:
          var a=' blabla  '.trimleft(); // a='blabla  '
         */
        return this.replace(/^\s+/, '');
    };
}
if (!String.prototype.remove) {
    String.prototype.remove = function (t) {
        var i = this.indexOf(t);
        var r = "";
        if (i == -1)
            return this.toString();
        r += this.substring(0, i) + this.substring(i + t.length).remove(t);
        return r;
    };
}

if (!String.prototype.EBCDICCompare) {
    String.prototype.EBCDICCompare = function () {
        // Compare EBCDIC sequence (0-9 after A-Z)
        /* gebruik:
            foSTRING = new String("ABC")
            foSTRING.EBCDICCompare("AAA")  return 1
            foSTRING.EBCDICCompare("ABC")  return 0
            foSTRING.EBCDICCompare("DEF")  return -1
            Vergelijk volgens de EBCDIC volgorde de meegegeven string met het object
               kleiner dan  1
               groter dan  -1
               gelijk       0
       */
        // alleen karakters uit de *DTA range
        var faEbcdicSeq500 = " .(+*);-/,_:#=abcdefghijklmnopqrstuvwxyz|ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

        var fsCompStr = arguments[0];
        var faToStr = this.split("");
        var faCompStr = fsCompStr.split("");
        var fiToStr = faToStr.length;
        var fiCompStr = faCompStr.length;
        var fiCompLen = Math.min(fiToStr, fiCompStr);
        var fiChrPos1 = 0;
        var fiChrPos2 = 0;

        for (var i = 0; i < fiCompLen; i++) {
            if (faToStr[i] == faCompStr[i]) {
                continue;
            }
            fiChrPos1 = faEbcdicSeq500.indexOf(faToStr[i]);
            fiChrPos2 = faEbcdicSeq500.indexOf(faCompStr[i]);
            if (fiChrPos1 > fiChrPos2) {
                return 1;
            }
            if (fiChrPos1 < fiChrPos2) {
                return -1;
            }
        }
        if (fiToStr == fiCompStr) {
            return 0;
        }
        if (fiToStr > fiCompStr) {
            return 1;
        }
        return -1;
    };
}

/** ************************************************************************************* */
/* Section: Array prototypes */
/** ************************************************************************************* */
// if (!Array.prototype.indexOf){
// Array.prototype.indexOf=function(el, start) {
// var start=start || 0;
// var fiLEN=this.length;
// for ( var i=0; i < fiLEN; ++i ) {
// if ( this[i] == el ) {
// return i;
// }
// }
// return -1;
// };
// }

/** ************************************************************************************* */
/* Section: Date prototypes */
/** ************************************************************************************* */

Date.prototype.getMDay = function () {
    // Bepalen dagnummer (maandag 1 - zondag 7)
    return (this.getDay() + 6) % 7;
};

Date.prototype.getISOYear = function () {
    // Bepalen jaar dat hoort bij weeknummer
    var thu = new Date(this.getFullYear(), this.getMonth(), this.getDate() + 3 - this.getMDay());
    return thu.getFullYear();
};

Date.prototype.getWeek = function () {
    // Bepalen weeknummer
    var onejan = new Date(this.getISOYear(), 0, 1);
    var wk = Math.ceil((((this - onejan) / 86400000) + onejan.getMDay() + 1) / 7);
    if (onejan.getMDay() > 3) {
        wk--;
    }
    return wk;
};

Date.prototype.getWeekDate = function (dowOffset) {
    // Bepalen weekdatum (jjjjwwd)
    var jaar = this.getISOYear().toString();
    var week = this.getWeek().toString().lftzro(2);
    var dag = (this.getMDay() + 1).toString();
    return jaar + week + dag;

    //return this.getISOYear().toString() + this.getWeek().toString().lftzro(2) + (this.getMDay()+1).toString();
};

/**
 * Zet Jaar Week Dag data om in een javascript date object
 * @param YWD week jaar dag als string in YYYYWWD D is optioneel
 * @returns {Date} het bijbehordende javascript Date Object
 */
function YWDToDate(YWD) {
    var foRegExp = new RegExp(/[^\x30-\x39]/); //0-9  Testen of input alleen uit cijfers bestaat
    var fdRetDate = new Date();
    var fiYear = 0;
    var fiWeek = 0;
    var fiDays = 0;
    var fiDaysToAdd = 0;
    var fdMondayFirstWeek = new Date();

    if (foRegExp.test(YWD)) {
        return fdRetDate;
    }
    var fsYear = YWD.substring(0, 4);
    var fsWeek = YWD.substring(4, 6);
    var fsDay = YWD.substring(6, 7);


    if (fsYear.length < 4) {
        return fdRetDate;
    }
    if (fsWeek.length < 2 || fsWeek < '01') {
        fsWeek = '01';
    }
    if (fsWeek > '53') {
        fsWeek = '53';
    }
    if (fsDay < '1') {
        fsDay = '1';
    }
    if (fsDay > '7') {
        fsDay = '7';
    }


    fiYear = new Number(fsYear);
    if (fiYear < 40) {
        fiYear += 2000;
    }
    if (fiYear < 99) {
        fiYear += 1900;
    }
    if (fiYear < 1940) {
        return fdRetDate;
    }

    fdMondayFirstWeek = mondayFirstWeek(fiYear);
    fdRetDate = mondayFirstWeek(fiYear);

    fiWeek = new Number(fsWeek);
    fiDays = new Number(fsDay);
    fiDays--; // maandag is 1 die zit al in fdMondayFirstWeek;
    fiWeek--; // week 1 zit al in fdMondayFirstWeek
    fiDaysToAdd = (fiWeek * 7) + fiDays;
    fdRetDate.setDate(fdMondayFirstWeek.getDate() + fiDaysToAdd);
    return fdRetDate;
}

function stringToCYQ(CYQ) {
    // notitie YYYY/Q
    var foRegExp = new RegExp(/[^\x30-\x39]/); //0-9  Testen of input alleen uit cijfers bestaat
    var fdRetDate = new Date();
    if (foRegExp.test(CYQ)) {
        return fdRetDate;
    }
//  var fiYear = 0;
//  var fiMonth = 0;
//  var fiDay = 0;
//  var fiQuart = 0;
//  var fsYear = YWD.substring(0, 4);
//  var fsQuart = YWD.substring(4, 1);

//  var fiYear = 0;
//  var fiMonth = 0;
//  var fiDay = 0;
//  var fiQuart = 0;
//  var fsYear = YWD.substring(0, 4);
//  var fsQuart = YWD.substring(4, 1);

//  fiYear = new Number(fsYear);
//  fiQuart = new Number(fsQuart);
//  fiMonth = (fiQuart * 3) - 1;

    fdRetDate.setFullYear();
    fdRetDate.setDate();
    fdRetDate.setMonth();

    return fdRetDate;
}

/**
 *
 * @param year
 * @returns {Date} maandag week 1 van het gevraagde jaar
 */
function mondayFirstWeek(year) {
    // in nederland 4 januari valt altijd in week 1(NEN 2772)
    //opgelost via switch statement omdat voorbij het jaar dagen aftrekken bijzondere maar foutieve resultaten opleverd
    var foDate = new Date(year, 0, 4);
    var fiDay = foDate.getDay();

    switch (fiDay) {
        case 0: // zondag
            return new Date(year - 1, 11, 29);
        case 1: // maandag
            return new Date(year, 0, 4);
        case 2: // dinsdag
            return new Date(year, 0, 3);
        case 3: // woensdag
            return new Date(year, 0, 2);
        case 4: // donderdag
            return new Date(year, 0, 1);
        case 5: // vrijdag
            return new Date(year - 1, 11, 31);
        case 6: // zaterdag
            return new Date(year - 1, 11, 30);
    }
}

/** ************************************************************************************* */

/* Section: object functions */
/** ************************************************************************************* */


function getBrowserDim() {
    // ***************************************************************************
    // Verkrijg de beschikbare browser breedte en hoogte
    // parms: --
    // return: zie return
    // ***************************************************************************
    var fiWDT = 630, fiHGT = 460;
    if (parseInt(navigator.appVersion) > 3) {
        if (navigator.appName == "Netscape") {
            fiWDT = window.innerWidth;
            fiHGT = window.innerHeight;
        }
        if (navigator.appName.indexOf("Microsoft") != -1) {
            fiWDT = document.body.offsetWidth;
            fiHGT = document.body.offsetHeight;
        }
    }
    return {BRWWDT: fiWDT, BRWHGT: fiHGT};
}


function clearAuthenticationCache() {
    window.onbeforeunload = null;
    try {
        var agt = navigator.userAgent.toLowerCase();
        if (agt.indexOf("msie") != -1) {
            // IE clear HTTP Authentication
            document.execCommand("ClearAuthenticationCache");
        } else {
            var xmlhttp = createXMLObject();
            xmlhttp.open("GET", "PAGE FROM REALM TO LOGOUT", true, "logout", "logout");
            xmlhttp.send("");
            xmlhttp.abort();
        }
    } catch (e) {
        // There was an error

    }

    function createXMLObject() {
        var xmlhttp = null;
        try {
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            }
            // code for IE
            else if (window.ActiveXObject) {
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
        } catch (e) {
            xmlhttp = false;
        }
        return xmlhttp;
    }
}

// function jsc_CONFIRMEXIT() {
//   // ***************************************************************************
//   // Bevestigen afsluiten applicatie
//   // parms: ?
//   // return: --
//   // Indien geannuleerd zorgt IE ervoor dat het toch de window wil sluiten, er
//   // kan dan alleen in de event onbeforeunload nog worden gereageerd. Dus dan
//   // doen we een jsc_RECONFIRM()
//   // ***************************************************************************
//   var fsMsg = gCONFIRMEXIT1 + '\n\n' + gCONFIRMEXIT2 + '\n\n' + gCONFIRMEXIT3;
//   if (OCULUS.cancelEndApplication) {
//     var bCNF = confirm(fsMsg);
//     if (bCNF) {
//       window.onbeforeunload = null;
//       OCULUS.cancelEndApplication = false;
//       jsc_CLSWIN();
//       return;
//     }
//     window.onbeforeunload = jsc_RECONFIRM;
//     OCULUS.cancelEndApplication = false;
//   }
//   OCULUS.cancelEndApplication = false;
//   return false;
// }

// function jsc_RECONFIRM() {
//   // ***************************************************************************
//   // Laatste mogelijkheid om door te gaan.
//   // parms: --
//   // return: zie return
//   // ***************************************************************************
//   if (OCULUS.standAlone) { // voorheen gPFM_STANDALONE
//     window.onbeforeunload = jsc_CLSWIN;
//     return gRECONFIRM;
//   }
// }

// *************************************************************************************/
/* Section: RCVNETMSG */

// *************************************************************************************/
/**
 * controleerd op het bestaan van een variabele
 * @param name variabele naam als string
 * @windowName optioneel referentie naar window
 * @returns boolean
 */
function isSet(name, windowName) {
    if (name == null || isNaN(name) && (!name || name == '')) {
        return;
    } //-->
    var fsNameIn = name.toString();
    var faParts = fsNameIn.split('.');
    var fsName = faParts[0];
    for (var i = 0, l = faParts.length; i < l; i++) {
        if (i > 0) {
            fsName += '.' + faParts[i];
        }
        if (!isSetTest(fsName, windowName)) {
            return false;
        }
    }
    return true;
}

/**
 * controleerd op het bestaan van een variabele
 * @param name variabele naam als string
 * @windowName optioneel referentie naar window
 * @returns boolean
 */
function isSetTest(name, windowName) {
    var fsTEST = 'typeof ' + name + '!=\'undefined\'';
    var foDOC = window;
    if (windowName) {
        foDOC = windowName;
    }
    try {
        if (foDOC.eval(fsTEST)) {
            return true;
        }
    } catch (e) {
    }
    return false;
}

function getEval(value, ifEmpty, frame) {
    if (frame && isSet(value, frame)) {
        return frame.eval(value);
    }

    if (SESSION.activeFrame && isSet(value, SESSION.activeFrame)) {
        return SESSION.activeFrame.eval(value);
    }

    if (isSet(MAIN) && isSet(value, MAIN)) {
        return MAIN.eval(value);
    }

    if (isSet(value)) {
        return eval(value);
    }

    if (hasValue(ifEmpty)) {
        return ifEmpty;
    }
    return null;
}

// onderstaande regel niet verwijderen
if (OCULUS.standAlone) { // voorheen gPFM_STANDALON
    window.onbeforeunload = null;
}

/**
 * getInnerText
 * retourneerd de innerText(ie) of de  textContent(ff)
 * @param DomObj
 * @returns value
 */
function getInnerText() {
    var foObj = arguments[0];

    if (foObj.innerText) {
        return foObj.innerText;
    }
    return foObj.textContent;
}

// nieuwere functie ook geschikt voor FF SF CH
function setCursorToEnd(obj) {
    var inputObject = XDOM.getObject(obj);
    var fsValue = inputObject.value;

//  inputObject.setAttribute("data-block-autosubmit", "true");

    if (typeof inputObject.selectionStart == "number") {
        inputObject.selectionStart = inputObject.value.length;
        inputObject.selectionEnd = inputObject.value.length;
    } else {
        inputObject.focus();
        if (hasValue(fsValue)) {
            inputObject.value = '';
            inputObject.value = fsValue;
        }
    }
}

/**
 * edgefix reset zoom als start = tyrue
 * en hersteld de zoom weer
 * voor gebruik bij alignto
 * @version  V8R3M22 POM-2296
 * @param {type} start
 * @returns {void}
 */
function alignToEdgeFix(start) {
    if (!BrowserDetect.isEdge) {
        return;
    }
    if (start) {
        alignToEdgeFix.orgZoom = MAIN.OCULUS.zoomLevel;
        MAIN.OCULUS.zoomLevel = "100";
    } else {
        MAIN.OCULUS.zoomLevel = alignToEdgeFix.orgZoom;

    }
    //
    SESSION.session.zoom();
};
alignToEdgeFix.orgZoom = '';

/**
 * zorgt ervoor dat foObject uitgeleind wordt met foAlignTo volgens de volgende regels:
 * 1 links uitlijnen, als dit niet kan dan rechts
 * 2 aan de onderkant als dit niet kan aan de bovenkant
 * 3 als er niet onder of boven kan worden geplaatst dan aan de rechter kant
 * 4 kan dat niet dan aan de linker kant
 * 5 als niets kan dan centeren en overal overheen
 * @param foObject
 * @param foAlignTo
 * @param foContainer optioneel buitenste div element waarbinnen de plaatsing moet plaats vinden default waarde: DTADIV
 * @param marginHeight
 * @version  V8R3M22 POM-2296 initialisatie en toewijzing van variabele gescheiden
 *  in verband met hoisting alignToEdgeFix fix toegevoegd
 * @returns align object
 */
function alignTo(foObject, foAlignTo, foContainer, marginHeight) {
    alignToEdgeFix(true);
    var fiMarginHeight = marginHeight,
        fiVOffset = 7,
        fiHOffset = 10,
        fiObjectTop = -1,
        fiObjectLeft = -1,
        fiWidth = 0,
        fiHeight = 0,
        fiMaxHeight = 0,
        fiMaxWidth = 0,
        foPos = 0,
        fiTop = 0,
        fiLeft = 0,
        fiBottom = 0,
        fiRight = 0,
        foRet = {},
        foScreenDiv = foContainer,
        setZeroAsMinium = false;

    fiWidth = foObject.offsetWidth;
    fiHeight = foObject.offsetHeight;

    if (!foScreenDiv) {
        foScreenDiv = XDOM.getObject("DTADIV");
        setZeroAsMinium = true;
    }
    if (!fiMarginHeight) {
        fiMarginHeight = 0;
    }
    fiMaxHeight = foScreenDiv.offsetHeight - fiMarginHeight;
    fiMaxWidth = foScreenDiv.offsetWidth;
    foPos = getObjPosTo(foAlignTo, foScreenDiv);
    fiTop = foPos.top;
    fiLeft = foPos.left;
    fiBottom = foAlignTo.offsetHeight + fiTop;
    fiRight = foAlignTo.offsetWidth + fiLeft;
    fiWidth = foObject.offsetWidth;
    fiHeight = foObject.offsetHeight + 1; //oplossing tegen flikkeren na verkeerde plaatsting door afrondings fout
    // top positie bepalen
    // voorkeur onder ,boven,
    // rechts er naast bovenop gecentreerd
    if ((fiBottom + fiHeight + fiVOffset) < fiMaxHeight) { // onder
        fiObjectTop = (fiBottom + fiVOffset);
        foRet.y = ENUM.align.bottom;
    } else if ((fiTop - fiHeight - fiVOffset) > 0) { // boven
        fiObjectTop = (fiTop - fiHeight - fiVOffset);
        foRet.y = ENUM.align.top;
    } else {
        if ((fiRight + fiHOffset + fiWidth) < fiMaxWidth) {// rechts er naast
            fiObjectLeft = fiRight;
            fiObjectTop = fiMaxHeight - fiHeight - fiVOffset;
            foRet.x = ENUM.align.right;
        } else if (fiLeft - fiHOffset - fiWidth > 0) {// links er naast
            fiObjectLeft = fiLeft - fiHOffset - fiWidth;
            fiObjectTop = fiMaxHeight - fiHeight - fiVOffset;
            foRet.x = ENUM.align.left;
        } else { // centreren
            foRet.x = ENUM.align.center;
            foRet.y = ENUM.align.center;
            fiObjectTop = Math.round((fiMaxHeight / 2) - (fiHeight / 2));
            fiObjectLeft = Math.round((fiMaxWidth / 2) - (fiWidth / 2));
        }
    }

    // horizontale positie bepalen als deze nog niet is gezet:
    // voorkeur linkerhoek, rechterhoek
    if (fiObjectLeft === -1) {
        if (fiLeft + fiHOffset + fiWidth < fiMaxWidth) {
            fiObjectLeft = fiLeft + fiHOffset;
            foRet.x = ENUM.align.left;
        } else if ((fiRight - fiWidth) > 0) {
            fiObjectLeft = (fiRight - (fiWidth + fiHOffset));
            foRet.x = ENUM.align.right;
        } else {
            fiObjectLeft = Math.round((fiMaxWidth / 2) - (fiWidth / 2));
            foRet.x = ENUM.align.center;
        }
    }

    if (setZeroAsMinium) {
        if (fiObjectTop < 0) {
            fiObjectTop = 0;
        }
    }


    foRet.top = fiObjectTop;
    foRet.left = fiObjectLeft;
    alignToEdgeFix();
    return foRet;
}

// /////
/**
 *
 * @param type
 * @param id
 * @param cssClassName
 * @returns
 */
function getCaption(value, ifEmpty, recursiveCheck=false) {
    var fsResult = null;

    if(window['Captions']){ //when getCaption is called in app frame Captions object is unavailable
        fsResult = Captions.returnCaption(value);
    }


    if (typeof fsResult == 'string'  ) {
        return fsResult;
    }

    if(window['Stateless']){//when getCaption is called in app frame Stateless object is unavailable
        fsResult = Stateless.Page.getCaption(value);
        if (typeof fsResult == 'string'  ) {
            return fsResult;
        }
    }


    if (PFMBOX && isSet(value, PFMBOX)) {
        fsResult = PFMBOX.eval(value);
    }

    if (typeof fsResult == 'string') {
        return fsResult;
    }

    if (isSet(value)) {
        fsResult = eval(value);
    }

    if (typeof fsResult == 'string') {
        return fsResult;
    }

    if (isSet(value, PFMCON)) {
        fsResult = PFMCON.eval(value);
    }

    if (typeof fsResult == 'string') {
        return fsResult;
    }

    if(!recursiveCheck) {
        fsResult = getCapt(value);
        if (fsResult) {
            return fsResult;
        }
    }

    if (hasValue(ifEmpty)) {
        return ifEmpty;
    }

    return null;

}


/**
 * geeft de positie van de cursor (caret) terug van een veld
 * @param foField htmlDomInputObject
 * @returns positie van de cursor
 */
function getCaretPosition(foField) {
    var foSel = null;
    if (document.selection) {
        foField.focus();
        foSel = document.selection.createRange();
        foSel.moveStart('character', -foField.value.length);
        return foSel.text.length;
    }
    if (foField.selectionStart || foField.selectionStart == '0') {
        return foField.selectionStart;
    }
    return -1;
}

function strPx2Int(width) {
    var fsWidth = width;
    if (typeof (fsWidth) == "string" && fsWidth != null && fsWidth != "") {
        fsWidth = fsWidth.replace('px', '');
        return parseInt(fsWidth);
    }
    return 0;
}

// returns border width for some obj
function getBorderWidth(obj) {
    var foRet = {"top": 0, "left": 0, "right": 0, "bottom": 0};
    var objStyle = null;
    if (window.getComputedStyle) { // ff
        objStyle = window.getComputedStyle(obj, null);
        foRet.left = parseInt(objStyle.borderLeftWidth.slice(0, -2));
        foRet.top = parseInt(objStyle.borderTopWidth.slice(0, -2));
        foRet.right = parseInt(objStyle.borderRightWidth.slice(0, -2));
        foRet.bottom = parseInt(objStyle.borderBottomWidth.slice(0, -2));
    } else { // ie, chrome
        foRet.left = strPx2Int(obj.style.borderLeftWidth);
        foRet.top = strPx2Int(obj.style.borderTopWidth);
        foRet.right = strPx2Int(obj.style.borderRightWidth);
        foRet.bottom = strPx2Int(obj.style.borderBottomWidth);
    }
    return foRet;
}

function getObjPosTo(obj, objTo) {

    var foRet = getObjAbsolutePos(obj);
    var foObjToPos = getObjAbsolutePos(objTo);

    foRet.left -= foObjToPos.left;
    foRet.top -= foObjToPos.top;

    return foRet;
}

/**
 * analizeerd een string in het axis format (R1_C3)
 * @param axis
 * @returns {row,col} object met numbers row en col
 */
function getRowAndCol(axis) {
    var fiRow = -1;
    var fiCol = -1;
    var fsAxis = axis.toUpperCase().replace('R', '').replace('C', ''); //(fsAxis = 1_3)
    var faAxis = fsAxis.split('_');
    if (faAxis.length == 2) {
        fiRow = parseInt(faAxis[0]);
        fiCol = parseInt(faAxis[1]);
    }
    return {'row': fiRow, 'col': fiCol};
}


// returns the absolute position of some obj within document
function getObjAbsolutePos(obj) {
    var foRet = {"left": 0, "top": 0};

    if (hasValue(obj)) {
        foRet.left = obj.offsetLeft;

        var offsetParent = obj.offsetParent;
        var offsetParentTagName = offsetParent != null ? offsetParent.tagName.toLowerCase() : "";

        if ((BrowserDetect.browser == 'Explorer' && BrowserDetect.version >= 8) && offsetParentTagName == 'td') {
            foRet.top = obj.scrollTop;
        } else if ((BrowserDetect.browser == 'Explorer' && BrowserDetect.version == 8) && (offsetParentTagName == 'td' || offsetParentTagName == 'table')) {
            // rke Het gele wybertje verdween van het scherm alleen bij ie8. Staat nu niet goed, maar is niet weg.
            foRet.top = obj.scrollHeight;
            foRet.left = obj.scrollWidth;
        } else {
            foRet.top = obj.offsetTop;
        }

        var parentNode = obj.parentNode;
        var borderWidth = null;

        while (offsetParent != null) {
            foRet.left += offsetParent.offsetLeft;
            foRet.top += offsetParent.offsetTop;

            var parentTagName = offsetParent.tagName.toLowerCase();

            if (((BrowserDetect.browser == 'Explorer' && BrowserDetect.version < 8) && parentTagName != "table") ||
                (BrowserDetect.isFirefox && parentTagName == "td") ||
                BrowserDetect.isChrome) {
                borderWidth = getBorderWidth(offsetParent);
                foRet.left += borderWidth.left;
                foRet.top += borderWidth.top;
            }

            if (offsetParent != document.body && offsetParent != document.documentElement) {
                foRet.left -= offsetParent.scrollLeft;
                foRet.top -= offsetParent.scrollTop;
            }

            // next lines are necessary to fix the problem with offsetParent
            if (!(BrowserDetect.browser == 'Explorer' && BrowserDetect.version < 8)) {
                while (offsetParent != parentNode && parentNode !== null) {
                    foRet.left -= parentNode.scrollLeft;
                    foRet.top -= parentNode.scrollTop;
                    parentNode = parentNode.parentNode;
                }
            }

            parentNode = offsetParent.parentNode;
            offsetParent = offsetParent.offsetParent;
        }
    }
    return foRet;
}


function hasValue(fo) {
    return !(typeof fo == 'undefined' || fo == null);
}


var Logger = {};
Logger.placeHolder = null;

Logger.createLogDiv = function () {
    var foParent = XDOM.getObject('DTADIV');
    var d = new Date();
    Logger.placeHolder = document.createElement("DIV");
    Logger.placeHolder.style.display = "none";
    foParent.appendChild(Logger.placeHolder);
    Logger.placeHolder.appendChild(document.createTextNode(d + " --> log start"));
};

Logger.log = function (fsLog) {
    try {
        var foPlaceHolder = Logger.getLogDiv();
        if (!foPlaceHolder) {
            return;
        }
        var d = new Date();
        foPlaceHolder.appendChild(document.createTextNode(d + " --> " + fsLog));
    } catch (e) {
    }
};

Logger.getLogDiv = function () {
    try {
        var foLogDiv = XDOM.getObject('logdiv');
        var foParent = null;
        var d = null;
        if (!foLogDiv) {
            d = new Date();
            foParent = XDOM.getObject('DTADIV');
            if (!foParent) {
                return null;
            }
            foLogDiv = document.createElement("DIV");
            foLogDiv.id = "logdiv";
            foLogDiv.style.display = "none";
            foParent.appendChild(foLogDiv);
            foLogDiv.appendChild(document.createTextNode(d + " --> log start"));
        }
        return foLogDiv;
    } catch (e) {
    }
};

Logger.stackTrace = function (s) {
    var fsOut = 'stacktrace:' + s;
    console.log("------------------ stacktrace:" + s + " START -----------");
    try {
        i.dont.exist += 0; // doesn't exist- that's the point
    } catch (e) {

        try {
            var currentFunction = arguments.callee.caller;
            while (currentFunction) {
                var fn = currentFunction.toString();
                var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('(')) || 'anonymous';
                fsOut += '\n - ' + fname;
                console.log("       --> " + fname);
                currentFunction = currentFunction.caller;
            }
        } catch (ie) {
            console.log("fout in stacktrace ");
        }
    }
    return fsOut;
};

function equals(value, compareValue) {
    if (!hasValue(value) || !hasValue(compareValue)) {
        return false;
    }
    if (isArray(compareValue)) {
        return isIn(value, compareValue);
    }
    if (getType(value) == "string") {
        return (value.like(compareValue));
    }

    return (value == compareValue);
}

function isIn(value, compareValues) {
    if (!hasValue(value) || !hasValue(compareValues)) {
        return false;
    }
    if (!isArray(compareValues)) {
        return equals(value, compareValues);
    }
    for (var i = 0, l = compareValues.length; i < l; i++) {
        if (equals(value, compareValues[i])) {
            return true;
        }
    }
    return false;
}

function isArray(obj) {
    if (obj instanceof Array) {
        return true;
    }
    if (typeof obj !== 'object') {
        return false;
    }
    if (getType(obj) === 'array') {
        return true;
    }
    return false;
}

function getType(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return String(obj);
    }
    return Object.prototype.toString.call(obj).replace(/\[object ([a-zA-Z]+)\]/, '$1').toLowerCase();
}

function nullWhenEmpty(str) {
    if (typeof str == 'undefined' || str == '') {
        return null;
    }
    return str;
}

function nullOrJson(str) {
    if (typeof str == 'undefined' || str == '') {
        return null;
    }

    return JSON.stringify(str);
}

function nullOrInt(str) {
    var fiStr = nullWhenEmpty(str);
    if (fiStr) {
        fiStr = parseInt(fiStr);
    }
    return fiStr;
}

function stringValue(str) {
    if (typeof str == 'undefined') {
        return '';
    }
    return str;
}

function floor(nr, decimals) {
    var fiDecimal = Math.pow(10, decimals);
    var fiReturn = Math.floor(nr * fiDecimal) / fiDecimal;
    return fiReturn;
}

function isZero(value) {
    var fsValue = value.replace(',', '.');
    var fiValue = parseFloat(fsValue);
    if (isNaN(fiValue) || floor(fiValue, 6) == 0) {
        return true;
    }
    return false;
}

function setThenEqual(value1, value2) {
    return (!value1 || !value2 || value1 == value2);
}

function scriptToServer(i) {
    return parseInt(i) + 1;
}

/**
 * verkrijgt record nummer zoals gedefinieerd in het attribute data-record-number -1
 * data-record-number is een server side record dat wil zeggen 1 based client side is het 0 based
 * @param obj
 */
function getClientRecordNr(obj) {
    var fsRecord = XDOM.getAttribute(obj, "data-record-number");
    if (!fsRecord) {
        return null;
    }
    return serverToScript(fsRecord);
}

function getRecordNr(obj) {
    var fsRecord = XDOM.getAttribute(obj, "data-record-number");
    return parseInt(fsRecord);
};

function serverToScript(i) {
    return parseInt(i) - 1;
}

function arrayToEvalString(foArr) {
    if (isArray(foArr)) {
        return '["' + foArr.join('","') + '"]';
    }
    return "[]";
}

function unformatThousand(value) {
    return value.split(SETTINGS.thousandSeparator).join('');
}

function unformatAll() {
    var faElementsWithThousandSep = XDOM.queryAll("[data-thousand-separator='on']");
    var foElement = null;
    for (var i = 0, l = faElementsWithThousandSep.length; i < l; i++) {
        foElement = faElementsWithThousandSep[i];
        if (foElement.tagName == "INPUT") {
            foElement.value = unformatThousand(foElement.value);
        }
    }
}


function formatThousandAll() {
    var faInput = XDOM.queryAll("[data-thousand-separator='on']");
    var foInput = null;
    var fsValue = null;

    for (var i = 0, l = faInput.length; i < l; i++) {
        foInput = faInput[i];

        if (foInput.hasAttribute("data-output-value")) {
            fsValue = XDOM.getAttribute(foInput, "data-output-value");

            XDOM.setAttribute(foInput, "data-old-value", fsValue);
            foInput.innerHTML = formatThousand(fsValue);
        } else {
            foInput.value = formatThousand(foInput.value);
        }
    }
}


function formatThousand(value) {
    var fsDecimal = '';
    var fsInteger = '';
    var faNumber = null;
    var fsChar = '';
    var fsIntegerOut = '';
    var fiIntegerPos = 0;
    var fiIntegerLength = 0;
    var fbIsNegative = false;

    if (!value) {
        return '';
    }
    ;
    if (typeof value === "number") {
        value = value.toString();
    }


    if (SETTINGS.thousandSeparator == ",") {
        fsDecimalSeparator = '.';
    } else {
        fsDecimalSeparator = ',';
    }

    faNumber = value.split(fsDecimalSeparator);

    fsInteger = faNumber[0];
    fsDecimal = faNumber.length > 1 ? fsDecimalSeparator + faNumber[1] : '';
    fiIntegerLength = fsInteger.length;

    if (fsInteger.charAt(0) == "-") {
        fbIsNegative = true;
    }

    for (var i = fiIntegerLength - 1; i > -1; i--) {
        fsChar = fsInteger.charAt(i);
        if (!isNaN(fsChar)) {
            fsIntegerOut = fsChar + fsIntegerOut;
            fiIntegerPos++;
            if (fiIntegerPos % 3 == 0 && i != 0) {
                if (i == 1 && fbIsNegative)
                    break;

                fsIntegerOut = SETTINGS.thousandSeparator + fsIntegerOut;
            }
        }
    }

    if (fbIsNegative) {
        fsIntegerOut = "-" + fsIntegerOut;
    }

    return fsIntegerOut + fsDecimal;
}


function getUID() {
    var d = new Date();
    var s = Math.floor((1 + Math.random()) * 0x10000)
        .toString(16)
        .substring(1);

    s += d.getTime();
    return s;
}


function setOldValue(obj) {
    obj.setAttribute("data-old-value", obj.value);
}

function fieldIsChanged(obj) {
    return (obj.getAttribute("data-old-value") != obj.value);
}

function getUsedAttributes() {
    var faDom = SESSION.activeFrame.document.getElementsByTagName("*");
    var foEllement = null;
    var dataAtributes = {};
    for (var i = 0, l = faDom.length; i < l; i++) {
        foEllement = faDom[i];
        for (var n = 0, le = foEllement.attributes.length; n < le; n++) {
            var foAttribute = foEllement.attributes[n];
            if (foAttribute.name.startsWith("data-")) {
                dataAtributes[foAttribute.name] = "true";
            }
        }
    }
    for (var attributeName in dataAtributes) {
        console.log(attributeName);
    }
}

/**
 * bepaald of het element focus kan hebben
 **/
function canHaveFocus(obj) {
    if (obj && obj.tagName == "INPUT" && (isIn(obj.type, ["text", "password", "button"]))) {
        return true;
    }
    return false;
}


/**
 * verkrijgt record nummer zoals gedefinieerd in het attribute data-record-number -1
 * data-record-number is een server side record dat wil zeggen 1 based client side is het 0 based
 * @param obj
 */

/*  MVB aangepast, verwijderd ivm doublure
function getClientRecordNr(obj){
	var fsRecord = XDOM.getAttribute(obj,"data-record-number");
	if(!fsRecord){
		return null;
	}
	return serverToScript(fsRecord)	;
}
*/

function getRecordNumber(obj) {
    var nr = obj.getAttribute("data-record-number");
    if (nr) {
        return parseInt(nr);
    }
    return null;
}


function addInputField(name, value) {

    var input = XDOM.getObject(name);
    if (input) {
        input.value = value;
        return;
    }

    input = XDOM.createElement('input', name);
    input.setAttribute('name', name);
    input.setAttribute('type', 'hidden');
    input.value = value;
    SESSION.activeForm.appendChild(input);
    return;
};

var useTimer = false;

function time(label) {
    if (useTimer) {
        console.time(label);
    }

}

function timeEnd(label) {
    if (useTimer) {
        console.timeEnd(label);
    }

}

function scrollIntoView(oElement, oContainer) {
    var containerTopPos = oContainer.scrollTop;
    var containerBottomPos = (containerTopPos + oContainer.clientHeight);
    var selectedRowTopPos = oElement.offsetTop;
    var selectedRowBottomPos = (selectedRowTopPos + oElement.clientHeight);

    if (selectedRowTopPos < containerTopPos) {
        oContainer.scrollTop = selectedRowTopPos;
    } else if (selectedRowBottomPos > containerBottomPos) {
        oContainer.scrollTop = (selectedRowBottomPos - oContainer.clientHeight);
    }

    return;
};


function activateOneButton(setInactive, setActive) {
    XDOM.setAttributesToNodeList(setInactive, "data-button-state", "inactive");
    setActive.setAttribute("data-button-state", "active");
}

function isActive(obj) {
    return (obj.dataset.buttonState == "active" || obj.parentNode.dataset.buttonState == "active");
}
/* xdom */
/* Load Timestamp 13:59:55.618 */
/* global SESSION, Stateless, PFMBOX, GLOBAL */

/**
 * namespace voor crosbrowser dom methodes
 */
var XDOM = function() {};
XDOM.GLOBAL = function() {};

XDOM.hexEncode = function(encodeString) {
    if (!encodeString) {
        return '';
    }
    var hexString, i, l;
    var hexResult = '';
    for (i = 0, l = encodeString.length; i < l; i++) {
        hexString = encodeString.charCodeAt(i).toString(16);
        hexResult += ('000' + hexString).slice(-4);
    }
    return hexResult;
};

XDOM.hexDecode = function(decodeString) {
    if (!decodeString) {
        return '';
    }
    var i, l;
    var hexString = decodeString.match(/.{1,4}/g) || [];
    var responseText = '';

    for (i = 0, l = hexString.length; i < l; i++) {
        responseText += String.fromCharCode(parseInt(hexString[i], 16));
    }

    return responseText.trim();
};

XDOM.rightTrim = function(stringObj) {
    if (BrowserDetect.isIE) {
        return stringObj;
    }
    if (typeof stringObj === 'string' || stringObj instanceof String) {
        return stringObj.trimRight();
    }

    return stringObj;
};
XDOM.removeInput = name => {
    delete SESSION.activePage.controlerFields[name];
}
XDOM.createInputField = function(name, value) {
    // ***************************************************************************
    // Creert een INPUT element
    // parms:  fNAME=naam van het nieuwe INPUT element
    //         fVALUE=waarde van het nieuwe INPUT element
    // return: --
    // ***************************************************************************
    SESSION.activePage.controlerFields[name] = value;
    return;
    var foInp = XDOM.getObject(name);

    if (foInp) {
        foInp.value = value;
        return;
    }
    foInp = XDOM.createElement('input', name);
    foInp.setAttribute('name', name);
    foInp.setAttribute('type', 'hidden');
    foInp.setAttribute('value', value);
    SESSION.activeForm.appendChild(foInp);
    return;
};

XDOM.objSerializeToAttribute = (atribute, json) => {
    let serialised = Object.entries(json)
        .map(p => `&quot;${p[0]}&quot;:&quot;${p[1]}&quot;`)
        .join(',');
    return ` data-${atribute}="{${serialised}}" `;
};
/**
 *
 * @param {type} xmlString
 * @returns {unresolved}
 */
XDOM.getXML = function(xmlString='') {
    var parser = new DOMParser();
    return parser.parseFromString(xmlString.trim() , 'application/xml');
};

XDOM.query = function(query, parentObject) {
    if (parentObject) {
        return parentObject.querySelector(query);
    }

    if (SESSION.subScope) {
        return SESSION.subScope.querySelector(query);
    }
    if (SESSION.activeForm) {
        return SESSION.activeForm.querySelector(query);
    }
    return document.querySelector(query);
};

XDOM.queryAllAppend = function(query, collection, parentObject) {
    var returnObj = collection || [];
    var nodeList = XDOM.queryAll(query, parentObject);
    return returnObj.concat(Array.prototype.slice.call(nodeList));
};

XDOM.queryAll = function(query, parentObject) {
    if (parentObject) {
        return parentObject.querySelectorAll(query);
    }
    if (SESSION.subScope) {
        return SESSION.subScope.querySelectorAll(query);
    }

    if (SESSION.activeForm) {
        return SESSION.activeForm.querySelectorAll(query);
    }

    return document.querySelectorAll(query);
};

function getCaller() {
    let stack = new Error().stack.split('\n')[3],
        f = stack
            .split('(')[0]
            .replace('at Object.', '')
            .replace('at Function.', '')
            .trim();

    return f;
}

XDOM.queryScope = function(query, parentObject) {
    if (SESSION.subScope) {
        return XDOM.query(query, parentObject);
    }
    let ret = XDOM.query(query + ':not([data-stateless-page-id])');
    return ret;
};

XDOM.queryAllScope = function(query, parentObject) {
    let ret = null;
    if (parentObject) {
        ret = parentObject.querySelectorAll(query);
        if (ret) {
            return ret;
        }
    }
    if (SESSION.subScope && SESSION.subScope.id != 'SCRDIV') {
        return XDOM.queryAll(query, parentObject);
    }

    ret = XDOM.queryAll(query + ':not([data-stateless-page-id])');
    return ret;
};

/**
 * opvragen van een attribute waarde
 * @param obj
 * @param name
 * @returns
 */
XDOM.getAttribute = function(obj, name) {
    var foObj = XDOM.getObject(obj);
    if (!(foObj && name)) {
        return null;
    } //--->
    if (foObj.getAttribute) {
        return foObj.getAttribute(name);
    }
    return null;
};

XDOM.GLOBAL.setAttribute = function(name, value) {
    XDOM.setAttribute(GLOBAL.eventSourceElement, name, value);
};

XDOM.GLOBAL.fieldIsChanged = function() {
    return XDOM.fieldIsChanged(GLOBAL.eventSourceElement);
};

XDOM.fieldIsChanged = function(obj) {
    var foObj = XDOM.getObject(obj) || GLOBAL.eventSourceElement;
    var fsOldValue = null;

    //we will not deal with we will not do an onchange on a button
    if(foObj.type=="button") return false;

    if (!('value' in foObj)) {
        return false;
    }
    fsOldValue = XDOM.getAttribute(foObj, 'data-old-value');

    if (!fsOldValue) {
        fsOldValue = '';
    }
    return foObj.value !== fsOldValue;
};

/**
 * setten van een array van attributes
 * @param obj
 * @param faAttributes van attributes
 */
XDOM.setAttributes = function(obj, faAttributes) {
    var foObject = XDOM.getObject(obj);
    if (!faAttributes) {
        return;
    } //--->
    for (var attribute in faAttributes) {
        foObject.setAttribute(attribute, faAttributes[attribute]);
    }
};

XDOM.radioAttributeToggle = function(
    allItems,
    item,
    attribute,
    valueOn,
    valueOff
) {
    XDOM.setAttributesToNodeList(allItems, attribute, valueOff);
    item.setAttribute(attribute, valueOn);
};

XDOM.setAttributesToNodeList = function(nodeList, attribute, value) {
    var objects = nodeList;
    if (typeof nodeList === 'string') {
        objects = XDOM.queryAll(nodeList);
    }

    for (var i = 0, l = objects.length; i < l; i++) {
        objects[i].setAttribute(attribute, value);
    }
};

/**
 * setten van een attribute
 * @param obj
 * @param name
 * @param value
 */
XDOM.setAttribute = function(obj, name, value) {
    var foObject = XDOM.getObject(obj);
    if (!(foObject && name && hasValue(value))) {
        return;
    } //--->
    foObject.setAttribute(name, value);
};

XDOM.removeAttribute = function(obj, name) {
    var foObject = XDOM.getObject(obj);
    if (!(foObject && name)) {
        return;
    } //--->
    if (foObject.setAttribute) {
        foObject.setAttribute(name, null);
    }
};

/**
 * toevoegen van event handlers  aan alle elementen van een node gebaseerd op de query
 * @param query
 * @param type
 * @param handler
 */
XDOM.addEventListenerToNode = function(query, type, handler, parentObject) {
    var objects = null;

    if (parentObject) {
        objects = parentObject.querySelectorAll(query);
    } else {
        objects = XDOM.queryAll(query);
    }

    var obj = null;
    for (var i = 0, l = objects.length; i < l; i++) {
        obj = objects[i];
        XDOM.addEventListener(obj, type, handler);
    }
};

/**
 * toevoegen van een event handler
 * @param obj
 * @param type
 * @param handler
 */
XDOM.addEventListener = function(obj, type, handler) {
    if (!(obj && type && handler)) {
        return;
    } //--->

    if (obj.attachEvent) {
        obj.attachEvent('on' + type, handler);
    } else if (obj.addEventListener) {
        obj.addEventListener(type, handler, false);
    }
};

/**
 * verwijderen van een event handler
 * @param obj
 * @param type
 * @param handler
 */
XDOM.removeEventListener = function(obj, type, handler) {
    if (!(obj && type && handler)) {
        return;
    } //--->
    if (obj.removeEventListener) {
        obj.removeEventListener(type, handler, false);
    } else if (obj.detachEvent) {
        obj.detachEvent('on' + type, handler);
    } else {
        obj.setAttribute('on' + type, null);
    }
};

/**
 * het ophalen van een HTML dom Object
 * @param fsId id
 * @returns {HTMLElement} object
 */
XDOM.getObject = function(fsId, parentObject= undefined) {
    var retObj = null;
    if (typeof fsId == 'object') {
        return fsId;
    }
    if (!fsId) {
        return null;
    }

    if (parentObject) {
        return XDOM.getHTMLObject(fsId, parentObject);
    }

    if (!retObj && SESSION.subScope) {
        retObj = XDOM.getHTMLObject(fsId, SESSION.subScope);
    }

    if (!retObj && SESSION.activeForm) {
        retObj = XDOM.getHTMLObject(fsId, SESSION.activeForm.document);
    }

    if (!retObj && SESSION.activeFrame) {
        retObj = XDOM.getHTMLObject(fsId, SESSION.activeFrame.document);
    }

    if (!retObj && SESSION.activePage && SESSION.activePage.dom) {
        retObj = XDOM.getHTMLObject(fsId, SESSION.activePage.dom);
    }

    if (!retObj) {
        retObj = XDOM.getHTMLObject(fsId, document);
    }

    if (!retObj && parent) {
        retObj = XDOM.getHTMLObject(fsId, parent.document);
    }

    return retObj;
};

XDOM.getHTMLObject = function(id, doc) {
    var ret = null;
    if (!doc) {
        return null;
    }
    if (doc && doc.getElementById) {
        ret = doc.getElementById(id);
    } else if (document.all) {
        ret = doc.all[id];
    } else if (document.layers) {
        ret = doc.layers[id];
    } else if (doc) {
        ret = doc[id];
    }
    //voor stateless
    if (!ret && doc.querySelector) {
        ret = doc.querySelector("[id='" + id + "']");
    }
    return ret;
};

XDOM.getEvent = function(e, ieWindow) {
    if (SESSION.activeFrame) var win = null;
    var foEvent = e;
    if (!foEvent) {
        if (ieWindow) {
            win = ieWindow;
        } else if (PFMBOX && SESSION.activeFrame) {
            win = SESSION.activeFrame;
        } else {
            win = window;
        }
        if (win) {
            foEvent = win.event;
        }
        if (!foEvent && !BrowserDetect.isFirefox) {
            foEvent = event;
        }
    }

    if (!foEvent) {
        return;
    } //-->
    var srcElement = foEvent.srcElement || foEvent.target;
    if (srcElement.readyState) {
        return;
        //als een event gelijk valt met een ajax call event kan dat problemen geven
        //zelfde moment dat er een response event gebeurd in dat geval is het eventSourceElement niet meer burikbaar voor de focus maar ook niet meer relevant
    }

    if (GLOBAL.eventObject) {
        GLOBAL.eventObject.cleanUp();
        GLOBAL.eventObject = null;
    }
    GLOBAL.eventObject = new XDOM.crossBrowserEvent(foEvent);

    //globals
    GLOBAL.eventSourceElement = GLOBAL.eventObject.srcElement;
    if (GLOBAL.eventSourceElement && GLOBAL.eventSourceElement.tagName) {
        GLOBAL.eventObjectTAG = GLOBAL.eventSourceElement.tagName.toUpperCase();
    } else {
        GLOBAL.eventObjectTAG = '';
    }
    GLOBAL.dataset = GLOBAL.eventSourceElement.dataset;
    SESSION.activePanel = XDOM.GLOBAL.getEditWindow();
    GLOBAL.charCode = GLOBAL.eventObject.keyCode;
    GLOBAL.char = GLOBAL.eventObject.char;
    XDOM.setScopeFromEvent();
    return GLOBAL.eventObject;
};

XDOM.getInnerText = function(obj) {
    if (obj.textContent || obj.textContent == '') {
        return obj.textContent;
    }
    return obj.innerText;
};

XDOM.setInnerText = function(id, value) {
    var foObj = XDOM.getObject(id);

    if (foObj) {
        if (BrowserDetect.isFirefox) {
            foObj.textContent = value;
        } else {
            foObj.innerText = value;
        }
    }
};

/**
 *
 * @param type
 * @param id
 * @param cssClassName
 * @returns HTMLElement
 */
XDOM.createElement = function(type, id, cssClassName) {
    var foElement = document.createElement(type);
    if (id) {
        foElement.id = id;
    }
    if (cssClassName) {
        foElement.className = cssClassName;
    }
    return foElement;
};

/**
 *
 * @param sText
 * @returns {text}
 */
XDOM.createTextNode = function(text) {
    return document.createTextNode(text);
};

XDOM.replaceAllChilds = function(node, newNode) {
    if (!node) {
        return;
    }
    if (node.hasChildNodes()) {
        while (node.childNodes.length >= 1) {
            node.removeChild(node.firstChild);
        }
    }
    node.appendChild(newNode);
};

XDOM.removeAllChilds = function(node) {
    if (!node) {
        return;
    }
    if (node.hasChildNodes()) {
        while (node.childNodes.length >= 1) {
            node.removeChild(node.firstChild);
        }
    }
};

XDOM.removeDOMObject = function(fObject) {
    var foObject = null;
    if (typeof fObject == 'string') {
        foObject = XDOM.getObject(fObject);
    } else {
        foObject = fObject;
    }
    if (foObject && foObject.parentNode) {
        foObject.parentNode.removeChild(foObject);
    }
};

XDOM.crossBrowserEvent = function(e) {
    this._event = e;
    this.clientX = e.clientX || e.pageX;
    this.clientY = e.clientY || e.pageY;
    this.srcElement = e.target || e.srcElement;
    this.currentTarget = e.currentTarget || e.srcElement;
    this.keyCode = e.charCode || e.keyCode || e.which;
    this.char = String.fromCharCode(this.keyCode);
    this.type = e.type;
    this.offsetX = e.offsetX;
    this.offsetY = e.offsetY;

    if (e.modifiers) {
        this.altKey = e.modifiers & Event.ALT_MASK;
        this.ctrlKey = e.modifiers & Event.CONTROL_MASK;
        this.shiftKey = e.modifiers & Event.SHIFT_MASK;
    } else {
        this.altKey = e.altKey;
        this.ctrlKey = e.ctrlKey;
        this.shiftKey = e.shiftKey;
    }
};

XDOM.crossBrowserEvent.prototype.cleanUp = function() {
    this._event = null;
    this.clientX = null;
    this.clientY = null;
    this.srcElement = null;
    this.currentTarget = null;
    this.keyCode = null;
    this.char = null;
    this.type = null;
    this.offsetX = null;
    this.offsetY = null;
    this.altKey = null;
    this.ctrlKey = null;
    this.shiftKey = null;
};

XDOM.crossBrowserEvent.prototype.cancel = function() {
    if (!this._event) {
        return false;
    }
    try {
        if (this._event.stopPropagation) {
            this._event.stopPropagation();
            this._event.preventDefault();
        } else {
            this._event.cancelBubble = true;
        }
        this._event.returnValue = false;
        return false;
    } catch (e) {
        return false;
    }

    return false;
};

XDOM.crossBrowserEvent.prototype.remapKeyCode = function() {
    GLOBAL.charCode = 505;
    this.keyCode = 505;
    this.char = '';
    if (BrowserDetect.isIE) {
        var foEvent = XDOM.getEvent();
        if (foEvent) {
            foEvent.keyCode = 505;
            foEvent.returnValue = false; //in verband met access denied in ie op event object
            //this._event.keyCode=505;
            //this._event.returnValue=false;
        }
    }
};

XDOM.cancelEvent = function(e) {
    if (e) {
        XDOM.getEvent(e);
    }

    if (GLOBAL.eventObject) {
        GLOBAL.eventObject.cancel();
    }
};

/**
 * geeft de huidige selectie terug
 * @returns {String}
 */
XDOM.getSelection = function(obj) {
    var txtObj = XDOM.getObject(obj);
    var selectedText = '';

    if (document.selection != undefined) {
        txtObj.focus();
        selectedText = document.selection.createRange().text;
    }

    if (selectedText == '' && hasValue(txtObj.selectionStart)) {
        selectedText = txtObj.value.substring(
            txtObj.selectionStart,
            txtObj.selectionEnd
        );
    }
    return selectedText;
};

XDOM.getStyle = function(fsID, styleProp) {
    var fsResult = '';
    var foObj = XDOM.getObject(fsID);
    if (foObj.currentStyle) {
        fsResult = foObj.currentStyle[styleProp];
    } else if (window.getComputedStyle) {
        fsResult = document.defaultView
            .getComputedStyle(foObj, null)
            .getPropertyValue(styleProp);
    }
    return fsResult;
};

XDOM.extendObject = function(subClass, baseClass) {
    function inheritance() {}

    inheritance.prototype = baseClass.prototype;
    subClass.prototype = new inheritance();
    subClass.prototype.constructor = subClass;
    subClass.baseConstructor = baseClass;
    subClass.superClass = baseClass.prototype;
    subClass.prototype._super = baseClass;
    baseClass.prototype.base = function(innerBaseClass, functionName) {
        var args = Array.prototype.slice.call(arguments, 2);
        return innerBaseClass.prototype._super.prototype[functionName].apply(
            this,
            args
        );
    };
};

XDOM.getObjectValue = function(obj) {
    var foField = XDOM.getObject(obj);
    var id = null;
    var value = '';

    if (!foField) {
        return null;
    } //-->}
    if (Mask.isMask(foField)) {
        id = foField.getAttribute('data-mask-target');
        if (id) {
            foField = XDOM.getObject(id);
        }

        if (foField.tagName == 'OUTPUT') {
            return foField.getAttribute('data-output-value').replace('&nbsp;', '');
        } else {
            return foField.value;
        }
    }

    if (foField.tagName == 'INPUT' || foField.tagName == 'TEXTAREA') {
        return foField.value;
    }

    if (foField.tagName == 'OUTPUT') {
        if (hasValue(foField.getAttribute('data-output-value'))) {
            value = foField.getAttribute('data-output-value').replace('&nbsp;', '');
        } else {
            value = foField.innerText;

            if (!value) {
                value = foField.textContent;
            }

            if (!value || (value && value.trim().length == 0)) {
                value = '';
            }
        }
        if (value && value.trim().length == 0) {
            return '';
        }
        return value;
    }

    if (isLogical(foField)) {
        return Logical.getObjValue(foField);
    }
    return foField.textContent;
};
/**
 * clears fields and set old-value
 * @param {string[]}fields
 */
XDOM.clearFields = function(fields=[]){
    fields.forEach(field=>XDOM.setObjectValue(field, ''));
}

XDOM.setObjectValue = function(obj, value, data) {
    var field = XDOM.getObject(obj);
    if (!field || !hasValue(value)) {
        return null;
    } //-->}
    value = value.toString();

    value = MaxScale.formatScaleOnly(field, value);

    if (field.tagName === 'OUTPUT') {
        if(field.getAttribute('data-thousand-separator')=='on'){
            value = formatThousand(value);
        }
        field.setAttribute('data-output-value', value.trim()); //voor css selectors
    } else {
        field.setAttribute('value', value.trim()); //voor css selectors
    }

    if (Mask.isMask(field)) {
        return Mask.setValue(field, value);
    }

    if (XDOM.getBooleanAttribute(field, 'data-unicode')) {
        value = XDOM.hexDecode(value); //transmit data as HEX
    }

    if (Logical.setObjValue(field, value)) {
        return;
    }

    switch (field.getAttribute('data-datatype')) {
        case '*MEMO':
            field.innerText = value;
            field.value = value;
            return;
            break;
        case '*LNK':
            return Link.setObjValue(field, value, data);
            break;
        case '*IMG':
            return oculusImage.setObjValue(field, value);
            break;
    }

    if (field.getAttribute('data-upload-base-id')) {
        return; //bij een upload kan geen waarde worden gezet
    }
    if (field.getAttribute('data-signature-name')) {
        return; //bij een signature kan geen waarde worden gezet
    }
    if (field.tagName == 'INPUT') {
        field.value = value;
        field.setAttribute('value', value.trim()); //voor css selectors
        return;
    }


    if (value == '' && field.tagName == 'OUTPUT') {
        field.innerHTML = '&nbsp;';
        return;
    }

    XDOM.setInnerText(field, value);
};

XDOM.getAxis = function(axis, recordNr) {
    var foRecord = XDOM.getObject('SFL_RCD' + recordNr);
    var foAxis = null;
    if (!foRecord) {
        return null;
    }
    foAxis = foRecord.querySelectorAll("[data-axis='" + axis + "']")[0];
    if (!foAxis) {
        foAxis = foRecord.querySelectorAll("[data-cell-axis='" + axis + "']")[0];
    }
    return foAxis;
};

XDOM.returnResolutionMode = function() {
    var resolution = MAIN.window
        .getComputedStyle(MAIN.document.body, ':after')
        .getPropertyValue('content');
    switch (resolution) {
        case 'fullHD':
        case "'fullHD'":
        case '"fullHD"':
            resolution = 'fullHD';
            break;
        case 'highDef':
        case "'highDef'":
        case '"highDef"':
            resolution = 'highDef';
            break;
        case 'high':
        case "'high'":
        case '"high"':
            resolution = 'high';
            break;
        case 'medium':
        case "'medium'":
        case '"medium"':
            resolution = 'medium';
            break;
        default:
            resolution = 'low';
            break;
    }
    return resolution;
};

XDOM.getAxisValue = function(axis, recordNr) {
    var foObj = XDOM.getAxis(axis, recordNr);
    return XDOM.getObjectValue(foObj);
};

XDOM.setAxisValue = function(axis, recordNr, value) {
    var foObj = XDOM.getAxis(axis, recordNr);
    XDOM.setObjectValue(foObj, value);
};

XDOM.getParentAttribute = function(obj, attribute) {
    var out = obj;
    var ret = '';

    if (!out) {
        return ret;
    }

    ret = obj.getAttribute(attribute) || '';

    while (out && out.parentNode && !ret) {
        out = out.parentNode;
        if (out.getAttribute) {
            ret = out.getAttribute(attribute);
        }
        if (ret) {
            return ret;
        }
    }
    return ret;
};

/**
 * @returns {HTMLElement} object that contains the css class
 * @param {HTMLElement} childe element
 * @param {String} classname
 */
XDOM.getParentByClass = function(obj, className) {
    var out = obj;
    while (out && out.parentNode) {
        out = out.parentNode;
        if (out.classList.contains(className)) {
            return out;
        }
    }
    return null;
};

XDOM.getParentByAttribute = function(obj, attribute) {
    var out = obj;
    while (out && out.parentNode && !out.getAttribute(attribute)) {
        out = out.parentNode;
    }
    if (out.getAttribute && out.getAttribute(attribute)) {
        return out;
    }
    return null;
};

XDOM.getParentByTagName = function(obj, tag) {
    let out = obj,
        tagName = tag.toUpperCase();

    if (!out) {
        return null;
    }
    while (out && out.parentNode && out.tagName) {
        if (out.tagName.toUpperCase() === tagName) {
            return out;
        }
        out = out.parentNode;
    }

    return null;
};

XDOM.getBrowserWindowSize = function() {
    var browserWidth = 0;
    var browserHeight = 0;

    if (typeof window.innerWidth == 'number') {
        browserWidth = window.innerWidth;
        browserHeight = window.innerHeight;
    } else if (
        document.documentElement &&
        (document.documentElement.clientWidth ||
            document.documentElement.clientHeight)
    ) {
        browserWidth = document.documentElement.clientWidth;
        browserHeight = document.documentElement.clientHeight;
    }

    return { width: browserWidth, height: browserHeight };
};

XDOM.cancelAndRemap = function(e) {
    if (e) {
        XDOM.getEvent(e);
    }
    if (GLOBAL.eventObject) {
        GLOBAL.eventObject.cancel();
        GLOBAL.eventObject.remapKeyCode();
    }
};

XDOM.clearSelection = function(e) {
    var objSelection = null;
    if ((objSelection = document.selection) && objSelection.empty) {
        objSelection.empty();
    } else {
        if (window.getSelection) {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(document.createRange());
        }
    }
};

/**
 * verkrijgt een attribute vanuit de GLOBAL.eventSourceElement
 */
XDOM.GLOBAL.getAttribute = function(name) {
    return XDOM.getAttribute(GLOBAL.eventSourceElement, name);
};
XDOM.GLOBAL.getBooleanAttribute = function(name) {
    return XDOM.getBooleanAttribute(GLOBAL.eventSourceElement, name);
};
/**
 * Sets the caret (cursor) position of the specified text field.
 * Valid positions are 0-obj.length.
 * @param obj
 * @param pos
 */
XDOM.setCursor = function(obj, pos) {
    if (!obj) {
        return;
    } //-->
    if (obj.createTextRange) {
        var textRange = obj.createTextRange();
        textRange.collapse(true);
        textRange.moveEnd('character', pos);
        textRange.moveStart('character', pos);
        textRange.select();
    } else if (obj.setSelectionRange) {
        obj.setSelectionRange(pos, pos);
    }
    return;
};

XDOM.getBooleanAttribute = function(obj, name) {
    var foObj = XDOM.getObject(obj);
    if (!foObj || !foObj.getAttribute) {
        return false;
    }

    var fsValue = foObj.getAttribute(name);

    if (fsValue == 'true') {
        return true;
    }
    if (fsValue == 'false' || fsValue == 'null') {
        return false;
    }
    if (fsValue) {
        return fsValue;
    }
    return false;
};

XDOM.classNameReplaceOrAdd = function(obj, classNameOld, classNameNew) {
    if (!obj) {
        return;
    }
    var fsNewClassName = null;
    if (obj.className.indexOf(classNameOld) > -1) {
        if (classNameOld != classNameNew) {
            fsNewClassName = obj.className.replace(classNameOld, classNameNew);
        } else {
            fsNewClassName = obj.className;
        }
    } else {
        fsNewClassName = obj.className + ' ' + classNameNew;
    }
    obj.className = fsNewClassName;
};

XDOM.classNameRemove = function(obj, classNameRemove) {
    var fsNewClassName = null;

    if (obj) {
        if (obj.className.indexOf(classNameRemove) > -1) {
            fsNewClassName = obj.className.replace(classNameRemove, '');
        }

        if (fsNewClassName) {
            obj.className = fsNewClassName.trim();
        }
    }
};

XDOM.insertAtCursor = function(foObj, fsValue) {
    if (document.selection) {
        foObj.focus();
        sel = document.selection.createRange();
        sel.text = fsValue;
    } else if (foObj.selectionStart || foObj.selectionStart == '0') {
        var startPos = foObj.selectionStart;
        var endPos = foObj.selectionEnd;
        foObj.value =
            foObj.value.substring(0, startPos) +
            fsValue +
            foObj.value.substring(endPos, foObj.value.length);
    } else {
        foObj.value += fsValue;
    }
};

XDOM.getEditWindow = function(id) {
    var foPanel = null;
    if (typeof id == 'string') {
        fsId = id;
    } else {
        fsId = XDOM.getAttribute(id, 'data-panel-id');
        if (!fsId) {
            fsId = XDOM.GLOBAL.getAttribute('data-for-panel');
        }
    }
    if (fsId && GUI.BasePanel) {
        foPanel = GUI.BasePanel.instances[fsId];
    }
    return foPanel;
};

XDOM.GLOBAL.getEditWindow = function() {
    return XDOM.getEditWindow(GLOBAL.eventSourceElement);
};

/**
 * Sets the caret (cursor) position of the specified text field.
 * Valid positions are 0-obj.length.
 * @param obj
 * @param pos

 XDOM.setCursor = function (obj,pos){
 if(!obj){return;} //-->
 if(obj.createTextRange){
 var textRange = obj.createTextRange();
 textRange.collapse(true);
 textRange.moveEnd('character',pos);
 textRange.moveStart('character',pos);
 textRange.select();
 }else if(obj.setSelectionRange){
 obj.setSelectionRange(pos,pos);
 }
 return;
 };
 */

/**
 * zet de focus op een veld nadat er gewisseld is van sessie
 * wordt aangeroepen vanuit het sessie object
 */

XDOM.focus = function(object, canselBlur) {
    XDOM.getEvent();
    var obj = XDOM.getObject(object);
    if (!obj) {
        return false;
    }

    if (
        obj.tagName !== 'INPUT' &&
        obj.tagName !== 'TEXTAREA' &&
        obj.tagName !== 'A' &&
        obj.constructor.name !== "Window"
    ) {
        return false;
    }

    if (obj.style.display == 'none' || obj.style.visibility == 'hidden') {
        return false;
    }
    //foObj.dataset.dontRegister = true;

    obj.focus();
    INP.select(obj);
    XDOM.setAttribute(obj, 'data-old-value', obj.value);
    SESSION.activePage.selectedObjectId = obj.id;

    return true;
};

XDOM.setSelection = function() {
    GLOBAL.selection = ENUM.selection.unKnown;
    var fiCarretPos = null;
    if (
        equals(GLOBAL.eventSourceElement.type, 'text') ||
        equals(GLOBAL.eventSourceElement.type, 'password')
    ) {
        if (hasValue(GLOBAL.eventSourceElement.selectionStart)) {
            if (
                XDOM.getSelection(GLOBAL.eventSourceElement) ==
                GLOBAL.eventSourceElement.value
            ) {
                GLOBAL.selection = ENUM.selection.all;
                return GLOBAL.selection;
            }
            fiCarretPos = getCaretPosition(GLOBAL.eventSourceElement);
            if (fiCarretPos == 0) {
                GLOBAL.selection = ENUM.selection.start;
                return GLOBAL.selection;
            }
            if (fiCarretPos == GLOBAL.eventSourceElement.value.length) {
                GLOBAL.selection = ENUM.selection.end;
                return GLOBAL.selection;
            }
            GLOBAL.selection = ENUM.selection.none;
            return GLOBAL.selection;
        }
    }
    return GLOBAL.selection;
};

XDOM.invokeClick = function(objIn) {
    let obj = XDOM.getObject(objIn);
    if (!obj) {
        return;
    }

    if (BrowserDetect.isSafari) {
        let event = document.createEvent('HTMLEvents');
        event.initEvent('click', true, true);
        obj.dispatchEvent(event);
        return;
    }

    obj.click();
    return;
};

XDOM.setOldvalue = function(id) {
    if (Array.isArray(id)) {
        for (let i = 0, l = id.length; i < l; i++) {
            XDOM.setOldvalue(id[i]);
        }
        return;
    }

    let obj = XDOM.getObject(id);
    if (!obj) {
        return;
    }
    obj.setAttribute('data-old-value', obj.value);
};

XDOM.forEach = function(selection, handler) {
    var collection = selection;
    if (typeof collection === 'string') {
        collection = XDOM.queryAll(selection);
    }

    for (var i = 0, l = collection.length; i < l; i++) {
        handler(collection[i], i);
    }
};

/**
 *
 * @param {array} arr
 * @returns {array} with only unique values
 */
XDOM.unique = function(arr) {
    return arr.filter(function(value, index, self) {
        return self.indexOf(value) === index;
    });
};

/**
 * parsed string naar json als deze niet goed gevormd is
 * zoals b.v. bij condHiddenLines of paramObject of snelzoek in edit/info windows
 * @param {type} stringToParse
 * @returns {JSON@call;parse.out}
 */
XDOM.parse = function(stringToParse) {
    if (typeof stringToParse !== 'string') {
        return stringToParse;
    }

    if (stringToParse == '') {
        return null;
    }

    var obj = JSON.parse('{"out":' + stringToParse.replaceAll("'", '"') + '}');
    if (obj) {
        return obj.out;
    }
    return null;
};

XDOM.clone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
};

XDOM.getFilledArray = function(value, nr) {
    var ret = [];
    for (var i = 0; i < nr; i++) {
        ret.push(value);
    }
    return ret;
};
XDOM.log = function(obj) {
    if (typeof obj === 'string') {
        console.log(obj);
        return;
    }
    console.log(JSON.stringify(obj));
};

XDOM.objectIsEqual = function(a, b) {
    if (!a || !b) {
        return false;
    }
    // Create arrays of property names
    var aProps = Object.getOwnPropertyNames(a);
    var bProps = Object.getOwnPropertyNames(b);

    // If number of properties is different,
    // objects are not equivalent
    if (aProps.length !== bProps.length) {
        return false;
    }

    for (var i = 0; i < aProps.length; i++) {
        var propName = aProps[i];

        // If values of same property are not equal,
        // objects are not equivalent
        if (a[propName] !== b[propName]) {
            return false;
        }
    }

    // If we made it this far, objects
    // are considered equivalent
    return true;
};

XDOM.setScopeFromEvent = function() {
    if (!window.Stateless) {
        return; //we zitten in het buitenste frame Stateless is hier niet bekend vandaar deze actie afbreken
    }
    var pageId = XDOM.getParentAttribute(
            GLOBAL.eventSourceElement,
            'data-stateless-page-id'
        ),
        page = Stateless.Page.get(pageId);
    Stateless.Page.setScope(page);
};

XDOM.Def2Attributes = function(definition) {
    let attributes = `  `;
    for (let key in definition) {
        if (typeof definition[key] != 'string') {
            continue;
        }
        attributes += ` data-option-${key}="${definition[key]}" `;
    }
    return attributes;
};

XDOM.Attributes2Def = function(obj) {
    if (!obj) {
        return {};
    }
    let definition = {},
        ds = obj.dataset || obj;
    for (let key in ds) {
        if (key.indexOf('option') == 0) {
            definition[key.replace('option', '').toUpperCase()] = ds[key];
        }
    }
    return definition;
};

XDOM.objectUnderModal = function(obj) {
    //zoek, en topview hebben geen tabdiv en staan dus nooit under modal
    if (obj.ownerDocument.getElementById('searchBody')) {
        //console.log('tabdiv is er niet');
        return false;
    }

    //onderstaande kijkt in een iframe boven die van het huidige object of er blockers aan staan
    let blockers = obj.ownerDocument.defaultView.parent.document.querySelectorAll(
        '[data-blocker="on"]'
    );
    //console.log(obj.dataset);
    if (blockers.length > 0) {
        // er staan blockers aan
        //  console.log('blockers');
        return true;
    }
    return false;
};

/* browserDetect */
/* Load Timestamp 13:59:55.618 */
//testje
var bBRWFCN_LOADED=true;
//browser detectie script
//alle niet ondersteunde browser moeten in de array blijven om foutieve detectie te voorkomen

var BrowserDetect = {
    browser:'',

    init: function () {
        this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
        this.version = this.searchVersion(navigator.userAgent)
            || this.searchVersion(navigator.appVersion)
            || "an unknown version";
        this.OS = this.searchString(this.dataOS) || "an unknown OS";
    },
    searchString: function (data) {
        for (var i=0;i<data.length;i++)	{
            var dataString = data[i].string;
            var dataProp = data[i].prop;
            this.versionSearchString = data[i].versionSearch || data[i].identity;
            if (dataString) {
                if (dataString.indexOf(data[i].subString) != -1)
                    return data[i].identity;
            }
            else if (eval('typeof ' + dataProp + '!=\'undefined\'')){
                return data[i].identity;
            }
        }
    },
    searchVersion: function (dataString) {
        var index = dataString.indexOf(this.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
    },
    dataBrowser: [
        {
            string: navigator.userAgent,
            subString: "Edge",
            identity: "Edge"
        },
        {
            string: navigator.userAgent,
            subString: "Chrome",
            identity: "Chrome"
        },
        { 	string: navigator.userAgent,
            subString: "OmniWeb",
            versionSearch: "OmniWeb/",
            identity: "OmniWeb"
        },
        {
            string: navigator.vendor,
            subString: "Apple",
            identity: "Safari",
            versionSearch: "Version"
        },
        {
            prop: "window.opera",
            identity: "Opera"
        },
        {
            string: navigator.vendor,
            subString: "iCab",
            identity: "iCab"
        },
        {
            string: navigator.vendor,
            subString: "KDE",
            identity: "Konqueror"
        },
        {
            string: navigator.userAgent,
            subString: "Firefox",
            identity: "Firefox"
        },
        {
            string: navigator.vendor,
            subString: "Camino",
            identity: "Camino"
        },
        {		// for newer Netscapes (6+)
            string: navigator.userAgent,
            subString: "Netscape",
            identity: "Netscape"
        },
        {
            string: navigator.userAgent,
            subString: "MSIE",
            identity: "Explorer",
            versionSearch: "MSIE"
        },
        {
            string: navigator.userAgent,
            subString: "Gecko",
            identity: "Mozilla",
            versionSearch: "rv"
        },
        { 		// for older Netscapes (4-)
            string: navigator.userAgent,
            subString: "Mozilla",
            identity: "Netscape",
            versionSearch: "Mozilla"
        }
    ],
    dataOS : [
        {
            string: navigator.platform,
            subString: "Win",
            identity: "Windows"
        },
        {
            string: navigator.platform,
            subString: "Mac",
            identity: "Mac"
        },
        {
            string: navigator.userAgent,
            subString: "iPhone",
            identity: "iPhone/iPod"
        },
        {
            string: navigator.platform,
            subString: "Linux",
            identity: "Linux"
        }
    ]

};
BrowserDetect.init();

var BROWSER_NAME  			='';
var BROWSER_VERSION  		='';
var is_ie6 = false;
var is_ie = false;
var is_ff = false;
var is_chr = false;
var is_saf = false;


BrowserDetect.isIE8				= false;
BrowserDetect.isIE9 			= false;
BrowserDetect.isIE 				= false;
BrowserDetect.isFirefox 	= false;
BrowserDetect.isChrome 		= false;
BrowserDetect.isSafari 		= false;
BrowserDetect.isiPad 		= false;
BrowserDetect.browserUsed	= null;
BrowserDetect.scrollbarWidth = 16;
BrowserDetect.isiPad = navigator.userAgent.match(/iPad/i) != null;
BrowserDetect.isiPad = /iPad/i.test(navigator.userAgent) || /iPhone OS 3_1_2/i.test(navigator.userAgent) || /iPhone OS 3_2_2/i.test(navigator.userAgent);

switch(BrowserDetect.browser.toString()){

    case 'Explorer':

        BrowserDetect.isIE 					= true;
        BrowserDetect.browserUsed		= 'InternetExplorer';
        BROWSER_NAME 								= 'ie';


        if (BrowserDetect.version == 9){
            BrowserDetect.isIE9 		= true;
            BROWSER_VERSION					= BrowserDetect.version;
        }

        if (BrowserDetect.version == 10){
            BrowserDetect.isIE9 		= true;
            BROWSER_VERSION					= BrowserDetect.version;
        }
        break;
    case 'Edge':
        BrowserDetect.isEdge		 	= true;
        BrowserDetect.browserUsed	= 'Edge';
        BROWSER_NAME 							= 'edge';
        BROWSER_VERSION						= BrowserDetect.version;
        break;
    case 'Firefox':
        BrowserDetect.isFirefox 	= true;
        BrowserDetect.browserUsed	= 'FireFox';
        BROWSER_NAME 							= 'ffx';
        BROWSER_VERSION						= BrowserDetect.version;
        break;
    case 'Safari':
        BrowserDetect.isSafari 		= true;
        BrowserDetect.browserUsed	= 'Safari';
        BROWSER_NAME 							= 'saf';
        BROWSER_VERSION						= BrowserDetect.version;
        break;
    case 'Chrome':
        BrowserDetect.scrollbarWidth = 17;
        BrowserDetect.isChrome 		= true;
        BrowserDetect.browserUsed	= 'Chrome';
        BROWSER_NAME								= 'chr';
        BROWSER_VERSION						= BrowserDetect.version;
        break;
    case 'Mozilla':
        BrowserDetect.isIE 				= true;
        BrowserDetect.browserUsed	= 'InternetExplorer';
        BROWSER_NAME								= 'moz';
        BROWSER_VERSION						= BrowserDetect.version;
        break;

    default:
        BROWSER_NAME ='unknown';
        BrowserDetect.browserUsed ='other';
}




/*===============================================================================*/
/*============================= SUPPORTED BROWSERS ==============================*/
/*===============================================================================*/
var	supportedBrowsers = [
    {
        "browserName"							: "Explorer",
        "browserTag"							: "ie",
        "supportedFromVersion"		: "10",
        "supportedOperatingSys"		: "Microsoft Windows"
    },
    {
        "browserName"							: "Edge",
        "browserTag"							: "edge",
        "supportedFromVersion"		: "10",
        "supportedOperatingSys"		: "Microsoft Windows"
    },
    {
        "browserName"							: "Chrome",
        "browserTag"							: "chr",
        "supportedFromVersion"		: "26",
        "supportedOperatingSys"		: "Microsoft Windows"
    },
    {
        "browserName"							: "Firefox",
        "browserTag"							: "ffx",
        "supportedFromVersion"		: "20",
        "supportedOperatingSys"		: "Microsoft Windows"
    },
    {
        "browserName"							: "Safari",
        "browserTag"							: "saf",
        "supportedFromVersion"		: "6",
        "supportedOperatingSys"		: "OS X Mountain Lion"
    },
    {
        "browserName"							: "Mozilla",
        "browserTag"							: "moz",
        "supportedFromVersion"		: "11",
        "supportedOperatingSys"		: "Microsoft Windows"
    }
];



function checkForSupportedBrowser(){
    var browserIsSupported = false;
    for (var i = 0; i < supportedBrowsers.length; i++) {
        if(BrowserDetect.browser == supportedBrowsers[i].browserName){

            if(BrowserDetect.version >= supportedBrowsers[i].supportedFromVersion){
                browserIsSupported = true;
            }

        }
    }

    if(!browserIsSupported){
        var txtMsg = getCapt('gBROWSERNOTSUPPORTEDMSG1')+" "+BrowserDetect.browser +" v"+BrowserDetect.version+" "+getCapt('gBROWSERNOTSUPPORTEDMSG2');
        alert(txtMsg);
        window.location.href = "/";
        return false;
    }
}




/* inzfcn */
/* Load Timestamp 13:59:55.619 */
/* global SESSION, NAV, MAIN, XDOM, GUI */

function updateNav() {
    var stackCode = SESSION.activePage.macroSwitch.macroStackCode;
    var isSessionOverlay = false;

    if(SESSION.activePage.viewProperties.dataAvailable == 'true'){
        if(SESSION.activePage.viewProperties.recursiveCall=="1"){
            SESSION.stack.setRecurrent();
        }
    }

    if(SESSION.activePage.screenType == "*SCH" || SESSION.isSingleView) {
        isSessionOverlay = true;
    }

    MAIN.SCREEN.initScreenSize(SESSION.activePage.screenSize, SESSION.stack.currentSession, isSessionOverlay);

    if(!isSessionOverlay) {
        SESSION.stack.serverSwitch(SESSION.activePage.macroName, SESSION.activePage.macroSwitch.loadedSubprocedure, stackCode);
        SESSION.stack.setCurrent(NAV, SESSION.activePage);
        // SESSION.stack.currentSubprocedure.renderTabs();
        MacroTab.render(SESSION.stack.currentSubprocedure.getMacrosDefs());
    }
    SESSIONFRAME.SessionMenus.updateFromMain();

    // SESSION.stack.currentMacro.tab.activate();

    SESSION.stack.currentSession.zoom();
}

var TabProtect = {};

TabProtect.blokker = null;

TabProtect.createBlokker = function() {
    var foParent = XDOM.getObject('INZ');
    var foBlokker = XDOM.getObject('tabBlokker');
    // controleren of blokker al bestaat
    if (foBlokker) {
        TabProtect.blokker = foBlokker;
    } else {
        TabProtect.blokker = XDOM.createElement("DIV", "tabBlokker", "protect");
        foParent.appendChild(TabProtect.blokker);
    }
};

TabProtect.protect = function() {
    if(TabProtect.blokker){
        TabProtect.blokker.className='protectDIV';
    }
};

TabProtect.free = function() {
    if(TabProtect.blokker){
        TabProtect.blokker.className='noprotectDIV';
    }
};



function setFrames(type) {
    if (type == '*PGM') {

        if(SESSION.isSingleView){
            SESSION.activeFrame = SESSION.topViewFrame;
        }else{
            SESSION.activeFrame = SESSION.appFrame;
        }
    } else {
        SESSION.activeFrame = SESSION.searchFrame;
    }
    if (SESSION.activeFrame) {
        SESSION.activeForm = SESSION.activeFrame.document.forms[0];
        PAGE = SESSION.activeFrame;
        PAGEDOC = SESSION.activeFrame.document;

        SCOPE.pageDoc = PAGEDOC;
        SCOPE.page = PAGE;
        SESSION.PAGEDOC = PAGEDOC;
        SESSION.PAGE = PAGE;
        MAIN.PAGEDOC = PAGEDOC;
        MAIN.PAGE = PAGE;
    }
}


/**
 * als er op een macro tab wordt geklikt en er is al een
 * submit aan de gang bijvoorbeeld door een autosubmit veld
 * (SESSION.submitInProgress == true) dan wiordt de SESSION.NextMacroId gevuld
 * nadat de pagina is herladen en de initialisatie klaar is wordt deze dan
 * uitgevoerd dit is gedaan om dubbele submits in ff chrome en safari te
 * voorkomen
 */
//function executeNextAction() {
//  if(hasValue(SESSION.NextMacroId)){
//	  // er is om een andere macro gevraagd terwijl er al een (auto) submit aan de gang was
//	 GUI.subProcedureTab.handleClick(SESSION.NextMacroId);
//	 // er hoeft verder niets meer te worden gedaan
//	 return;
//  }
//
//  return;
//}

function sortIntArray(arrayin){
    return arrayin.sort(function (a,b) {return parseInt(a) - parseInt(b);});
}
/* guifcn */
/* Load Timestamp 13:59:55.620 */
/* global XDOM */

// function jsc_OPNDOCWDW() {
//     // ***************************************************************************
//     // Opent een minimale venster obv een URL
//     // parms:  fDOCPD=URL
//     //         fbRSZABL=true (resizeable) || false (fixed)
//     // return: --
//     // ***************************************************************************
//     // open window voor externe documenten
//     var fDOCPD = arguments[0];
//     var fbRSZABL = arguments[1];
//
//     var fsRSZABL = fbRSZABL ? 1 : 0;
//     var fOPNWDW = null;
//     var feOPNWDW =
//         '' +
//         'title=0,' +
//         'titlebar=0,' +
//         'toolbar=0,' +
//         'menubar=0,' +
//         'location=0,' +
//         'directories=0,' +
//         'status=0,' +
//         'resizable=' +
//         fsRSZABL +
//         ',' +
//         'scrollbars=1,' +
//         'alwaysRaised=yes,' +
//         'dependent=yes';
//
//     fOPNWDW = window.open(fDOCPD, 'DOCWDW', feOPNWDW);
//     try {
//         if (!fOPNWDW.opener) {
//             fOPNWDW.opener = self;
//             fOPNWDW.focus();
//         }
//     } catch (e) {
//     }
//     XDOM.cancelEvent();
//     return false;
// }

//***************************************************************************
// Creert een INPUT element
// parms:  fNAME=naam van het nieuwe INPUT element
//         fVALUE=waarde van het nieuwe INPUT element
// return: --
// ***************************************************************************

// ***************************************************************************
// Geeft aan of het opgegeven object hidden is
// parms:  fFIELD=te testen object
// return: true (hidden) || false (visible)
// ***************************************************************************
function isHidden(fsField) {
    var foObj = XDOM.getObject(fsField);

    if (!foObj) {
        return true;
    }

    if (foObj.type == 'hidden') {
        return true;
    }

    if (foObj.className.search('hidden') > -1) {
        return true;
    }

    if (
        foObj.hasAttribute('data-hidden') &&
        XDOM.getBooleanAttribute(foObj, 'data-hidden')
    ) {
        return true;
    }
    if (
        foObj.hasAttribute('data-hidden-line') &&
        XDOM.getBooleanAttribute(foObj, 'data-hidden-line')
    ) {
        return true;
    }
    return false;
}

// ***************************************************************************
// Veranderd de class eigenschap van het opgegeven object
// parms:  foFLD=object waarop de verandering moet plaats vinden
//         fOLDCLS=oude classe wat veranderd moet worden
//         fNEWCLS= nieuwe classe wat toegepast moet worden
//         fbCHGCLS=true (wel veranderen )|| false (niet veranderen)
// return: --
// !! Als NEWCLS='*OLD' class vervangen door een evt bewaarde class
//    als OLDCLS='*ALL' alle classes vervangen door NEWCLS
//    als OLDCLS=''     dan wordt NEWCLASS toegevoegd aan de huidige class
//    als OLDCLS!='' en NEWCLS='' dan wordt OLDCLS verwijderd
// ****************************************************************************

function blocked() {
    //OCULUS.checkKeyCode moet nog worden ingebouwd!

    if (SESSION.protected) {
        GLOBAL.eventObject.remapKeyCode();
        GLOBAL.eventObject.cancel();
        if (
            GLOBAL.charCode == keyCode.tab &&
            GLOBAL.eventObject.srcElement.tagName == 'INPUT'
        ) {
            //zorgen dat tab ook niet meer werkt
            GLOBAL.eventObject.srcElement.focus();
        }
        return true;
    }
    return false;
}

var ScreenBlokker = {};
ScreenBlokker.onclick = null;
ScreenBlokker.domObject = null;
ScreenBlokker.screenDiv = null;
ScreenBlokker.guiObject = null;

ScreenBlokker.show = function (z) {
    Dragger.screenDiv = XDOM.getObject('DTADIV');
    Dragger.domObject = XDOM.createElement(
        'DIV',
        'screenBlokker',
        'screenBlokker'
    );
    Dragger.screenDiv.appendChild(this.domObject);
    Dragger.domObject.onclick = Dragger.onclick;
    if (z) {
        Dragger.domObject.style.zIndex = z;
    }
};

ScreenBlokker.hide = function () {
    if (Dragger.domObject) {
        Dragger.screenDiv.removeChild(Dragger.domObject);
    }
    Dragger.domObject = null;
};

/**
 * sluit alle openstaande popups
 * @returns boolean
 */
function closePopUp() {
    XDOM.cancelAndRemap();
    return (
        popupPanel.close() |
        Service.close() |
        Calender.close() |
        QuickSearch.close() |
        closeHighSlide()
    );
}

function closeAllModalObjects() {
    closeNativeDialogs();
    return (
        closePopUp() ||
        Messages.closeWindow() | closeHighSlide() | Stateless.panel.close()
    );
}

function closeHighSlide() {
    var overlayObj = XDOM.getObject('whiteOverlay');
    var imgObj = XDOM.getObject('imgViewer');
    if (overlayObj) {
        XDOM.removeDOMObject(overlayObj);
        XDOM.removeDOMObject(imgObj);
        return true;
    }
    return false;
}

function setfavourites() {
    const favButton = XDOM.query('[data-button-icon="favourites"]'),
        show = SESSION.isSingleView == false && minVersion('*8A');
    if (favButton) {
        if(show){
            favButton.setAttribute('data-hidden', false);
            favButton.parentNode.style.display = '';
            return;
        }
        favButton.setAttribute('data-hidden', true);
        favButton.parentNode.style.display = 'none';

    }
}

function hideColourPicker() {
    if(!minVersion('*8A')){
        return;
    }
    const icon = XDOM.query('.session-user-button [data-click="skin"]');

    XDOM.removeDOMObject(icon?.parentNode);
    XDOM.removeDOMObject(SCOPE.pageDoc.querySelector('[data-button-icon="skin"]')?.parentNode);

}

/**
 * shows or hide the print button based on user settings
 * note: in firefox these buttons wil never be shown at all
 */
function setPrintButton() {
    const printBtn = SCOPE.pageDoc.querySelector('[data-button-icon="print"]');
    const hide = BrowserDetect.isFirefox || !SCOPE.main.Settings.get('SHOW_PRINT_BUTTON')?'true':'false'
    printBtn.setAttribute('data-hidden', hide);
    printBtn.parentNode.setAttribute('data-hidden', hide);
}

function setTitle() {
    if (NAV.Macro.currentInstance) {
        NAV.Macro.currentInstance.setTitle();
    }
}

function getPanelThemeColor(domObj) {
    //   let subviewContainer = XDOM.getParentByTagName(domObj,"FIELDSET"),
    //       subviewBackgroundColor = "";
    //   if(!subviewContainer){
    //    return;
    //   }
    //   subviewBackgroundColor = XDOM.getAttribute("data-fieldset-background-color");
}

//***************************************************************************
//Toepassen labels uit javascript teksten bestand op de objecten
//parms:  --
//return: --
//***************************************************************************
function setLabels(parent) {
    var faLables = null;
    if (parent) {
        faLables = parent.getElementsByTagName('label');
    } else {
        faLables = SESSION.activeFrame.document.getElementsByTagName('label');
    }

    for (var i = 0, l = faLables.length; i < l; i++) {
        faLables[i].innerHTML = getCaption(faLables[i].id, '');
    }
    let titles = PAGEDOC.querySelectorAll('[data-set-title]');
    for (var i = 0, l = titles.length; i < l; i++) {
        titles[i].title = getCapt(titles[i].dataset.setTitle);
    }

    return;
}

//***************************************************************************
//Toepassen helpText uit javascript teksten bestand op de objecten
//parms:  --
//return: --
//***************************************************************************
function setHelpText() {
    var pageObjects = XDOM.queryAll('[data-selection-help]');
    var helpTextValue = '';

    for (var i = 0, l = pageObjects.length; i < l; i++) {
        helpTextValue = getTitleText(pageObjects[i].dataset.selectionHelp);
        if (hasValue(helpTextValue)) {
            GUI.infoTitle.register(pageObjects[i], helpTextValue);
        }
    }
    return;
}

function getTitleText(text) {
    var fsHelpText = text;
    switch (text) {
        case '*LOWER':
            fsHelpText = getCapt('cWS_SLT_GTE');
            break;
        case '*UPPER':
            fsHelpText = getCapt('cWS_SLT_LTE');
            break;
        case '*NEWER':
            fsHelpText = getCapt('cWS_SLT_NEW');
            break;
        case '*OLDER':
            fsHelpText = getCapt('cWS_SLT_OLD');
            break;
        case '*EQUAL':
            fsHelpText = getCapt('cWS_SLT_EQL');
            break;
        case '*LEFTEQ':
            fsHelpText = getCapt('cWS_SLT_LEQ');
            break;
        case '*SCAN':
            fsHelpText = getCapt('cWS_SLT_SCN');
            break;
        case '*UNEQUAL':
            fsHelpText = getCapt('cWS_SLT_NEQ');
            break;
    }
    return fsHelpText;
}

function setSubviewNoMargin(subfiewContainer, screenMode) {
    var foObj = null,
        foFS = null;
    if (screenMode == GUI.BasePanel.screenMode.subview) {
        foObj = XDOM.getObject(subfiewContainer);
        foFS = XDOM.getParentByTagName(foObj, 'FIELDSET');
        foFS.className += ' subviewNoMargin';
        foFS.setAttribute('data-dashboard', 'gadget');
    }
}

/**
 *
 * @param i
 * return {peas}
 */
function int2css(i, nr) {
    return i.toString().lftzro(nr);
}

function backOnDisabled() {
    if (!isEnabled(GLOBAL.eventSourceElement)) {
        SESSION.activePage.previousField.focus();
        return true;
    }
    return false;
}

function protectPage() {
    SESSION.protected = true;
    TabProtect.protect();
    var protectDiv = XDOM.getObject('PROTECT');
    var sessionLoader = XDOM.getObject('sessionLoader');
    let enableLoader = SCOPE.main.Settings.get('ENABLE_LOADER');
    protectDiv.className = 'protectDIV';

    if (typeof enableLoader !== 'undefined') {
        if (enableLoader) {
            sessionLoader.className = 'protectDIV';
        }
    } else {
        sessionLoader.className = 'protectDIV';
    }
}

function releasePage() {
    SESSION.protected = false;
    TabProtect.free();
    var protectDiv = XDOM.getObject('PROTECT');
    var sessionLoader = XDOM.getObject('sessionLoader');
    protectDiv.className = 'noprotectDIV';
    sessionLoader.className = 'noprotectDIV';
}

function showFrame(type) {
    var frameToHide = null,
        frameToShow = null;
    if (type === '*SCH') {
        SESSION.seachFrameObj.setAttribute('data-hidden', false);

        //zoek is geopend vanuit eescreenTypen topView
        //if(SESSION.isSingleView){
        //  SESSION.topViewFrameObj.setAttribute("data-hidden", false);
        //}
        //SESSION.seachFrameObj.style.display 			= "block";
        //SESSION.topViewFrameObj.setAttribute("data-hidden", true);
        //SESSION.topViewFrameObj.style.display 		= "none";
        Search.searchBlocker(true);
    } else {
        if (SESSION.isSingleView) {
            SESSION.seachFrameObj.setAttribute('data-hidden', true);
            SESSION.topViewFrameObj.setAttribute('data-hidden', false);
            TopView.topViewBlocker(true);
        } else {
            SESSION.seachFrameObj.setAttribute('data-hidden', true);
            SESSION.topViewFrameObj.setAttribute('data-hidden', true);
            SESSION.appFrameObj.setAttribute('data-hidden', false);
        }
    }
}

function getFontPrefix(group) {
    let fontGroup = group,
        returnFontClass = '';

    switch (fontGroup) {
        case ENUM.fontIconGroup.fontAwesome:
            returnFontClass = 'fa fa-';
            break;
        case ENUM.fontIconGroup.pthFont:
            returnFontClass = 'pth-';
            break;
        case ENUM.fontIconGroup.customFont:
            returnFontClass = 'custom-';
            break;
    }
    return returnFontClass;
}

function updatePanelSort(sortDomObj = getHighestPanel()) {
    let panelWrapper = null,
        highestIndex = 100,
        topObject = XDOM.query('[data-show-on-top]', SESSION.activeForm);

    if (!sortDomObj) {
        return;
    }

    if (topObject) {
        highestIndex = parseInt(topObject.dataset.showOnTop) + 1;
        topObject.removeAttribute('data-show-on-top');
    }

    panelWrapper = XDOM.getParentByAttribute(sortDomObj, 'data-update-dom-depth');
    if (panelWrapper) {
        XDOM.setAttribute(panelWrapper, 'data-show-on-top', highestIndex);
        panelWrapper.style.zIndex = highestIndex;
    }
}

function getHighestPanel() {
    let panelObj = null,
        panelObjects = XDOM.queryAll(
            "[data-update-dom-depth='true']:not([data-hidden='true'])"
        ),
        z = 0,
        HighestZ = 0;
    HighestObject = null;

    if (panelObjects.length <= 0) {
        //no panels found
        return null;
    }

    for (panelObj of panelObjects) {
        // geen subview schermen meerekenen
        if (
            XDOM.getParentAttribute(panelObj, 'data-screen-mode') ==
            GUI.BasePanel.screenMode.subview
        ) {
            continue;
        }
        z = parseInt(panelObj.style.zIndex);
        if (z > HighestZ) {
            HighestZ = z;
            HighestObject = panelObj;
        }
    }
    return HighestObject;
}

/**
 * checks if extention is an image
 * @param {String} extention
 * @returns {boolean} true if extention is an image
 */
const isImage = extention =>
    ['BMP', 'JPG', 'JPEG', 'PNG', 'GIF'].indexOf(extention) > -1;

/**
 * finds of file from filename or url
 * @param {String} fileName
 * @returns {String}  extention
 */
const getExtention = fileName =>
    fileName
        .substr(fileName.lastIndexOf('.') + 1)
        .toUpperCase()
        .split('?')[0];

/**
 * gets fileName including extention from url
 * @param {String} url
 * @returns {String} filename
 */
const getFilenameFromUrl = url =>
    url.substring(url.lastIndexOf('/') + 1).split('?')[0];

// function userOrDevTitle() {
//   if (true || OCULUS.debugMode) {
//     let ret = arguments[0] || ''; //let op arguments is geen array dus geen map of join gebruiken
//     for (let i = 1, l = arguments.length; i < l; i++) {
//       ret += ' - ' + arguments[i];
//     }
//     return ret;

//     return arguments.join('-');
//   }
//   return arguments[0] || '';
// }


const cancelEvent = e => {
    if (!e) {
        return;
    }
    e.stopPropagation();
    e.preventDefault();
}

const inWizard = ()=>{
    return !!SCOPE.session.wizardDefinition;
}
/* prcfcn */
/* Load Timestamp 13:59:55.621 */


/**
 * initialiseert positie scrollbar bij kiezen andere optie in P procedure en bij submit
 */
function resetAllsubfilePositions() {
    for (var x in SESSION.program) {
        SESSION.program[x].subfilePos = 0;
    }
}

function gotoPreviousProgram() {
    if (SESSION.submitInProgress) {
        return;
    }

    Upload.resetFormEncType();
    SESSION.stack.back(SESSION.activePage);
    closeHighSlide();

    Subfile.getProgramSettings().subfilePos = 0;

    window.onbeforeunload = null;
    Command.submit();
    return false;
}

/* pgmfcn */
/* Load Timestamp 13:59:55.621 */
/**
 * voegt attribute toe aan object
 * @param {object}{string} fOBJ:  object of id van object
 * @param {string}         fsATR: lijst van attributen
 * @return{string}         fsVAL: waarde
 */
ATTRIB.SETVAL = function () {
    var fOBJ = arguments[0];
    var fsATR = arguments[1];
    var fsVAL = arguments[2];
    var foOBJ = XDOM.getObject(fOBJ);
    if (foOBJ.setAttribute) {
        foOBJ.setAttribute(fsATR, fsVAL);
    } else {
        foOBJ[fsATR] = fsVAL;
    }
    return;
};

/**
 * vraagt attribute op van object
 * @param {object}{string} fOBJ:  object of id van object
 * @param {string}         fsATR: lijst van attributen
 * @return{string}         fsVAL: waarde
 */
ATTRIB.GETVAL = function () {
    var fOBJ = arguments[0];
    var fsATR = arguments[1];
    var foOBJ = XDOM.getObject(fOBJ);
    if (foOBJ.getAttribute) {
        return foOBJ.getAttribute(fsATR);
    }
    return foOBJ[fsATR];
};

/**
 * copieerd attribute op van object fFRMOBJ naar object fTOOBJ
 * @param {object}{string} fFRMOBJ:  object of id van object waar vandaan moet worden gekopieerd
 * @param {object}{string} fTOOBJ:   object of id van object waar naartoe moet worden gekopieerd
 * @param {string}         fsATR: lijst van attributen
 * @return{string}         fsVAL: waarde
 */
ATTRIB.CPYATR = function () {
    var fFRMOBJ = arguments[0];
    var fTOOBJ = arguments[1];
    var fsATR = arguments[2];
    var foFRMOBJ = XDOM.getObject(fFRMOBJ);
    var foTOOBJ = XDOM.getObject(fTOOBJ);
    var foVal = ATTRIB.GETVAL(foFRMOBJ, fsATR);
    ATTRIB.SETVAL(foTOOBJ, fsATR, foVal);
    return;
};

/****************************************************************************************/
/*        Section: DOM interpretation functions                                         */

/****************************************************************************************/
/**
 * retourneerd of het html Dom object beschikbaar is dus niet hidden,disabled of protected
 * @param foFLD htmlDomObject;
 * @returns {Boolean}
 */
function isEnabled(foFLD) {
    return (
        !XDOM.getBooleanAttribute(foFLD, 'data-protected') &&
        !XDOM.getBooleanAttribute(foFLD, 'data-hidden') &&
        !foFLD.disabled &&
        !foFLD.readOnly
    );
}

function setCursorIeBugFix(oCursorField) {
    if (!BrowserDetect.isIE) {
        return oCursorField;
    }
    if (BrowserDetect.version == '11') {
        XDOM.clearSelection();
    }
    if (
        oCursorField &&
        (oCursorField.tagName == 'OUTPUT' || oCursorField.tagName == 'DIV' || oCursorField.type == 'file')
    ) {
        return null;
    }
}

function setCursorFFBugFix() {
    //omdat we op geen enkele manier een goede keyhandling kunnen realiseren binnen fire fox als er geen input element aanwezig is deze uiterst vreselijke oplossing onze nederige excusses
    if (!BrowserDetect.isFirefox) {
        return false;
    }
    var foFocusInput = XDOM.getObject('focusInput');
    if (!foFocusInput) {
        foFocusInput = XDOM.createElement('input', 'focusInput');
        var foDTADIV = XDOM.getObject('DTADIV');
        foDTADIV.appendChild(foFocusInput);
    }
    foFocusInput.type = 'text';
    foFocusInput.style.marginLeft = '-5000px';
    foFocusInput.focus();
    return true;
}

function getStatelessPart(obj) {
    return (
        obj.dataset.quicksearchSelectfield || // snelzoek
        obj.dataset.statelessPageId || // edit/stateless window
        obj.dataset.panelId
    ); // mask in edit window
}

function setSubviewLoading(domObj, loading) {
    if (!domObj) {
        return;
    }
    const subviewContainer = XDOM.getParentByTagName(domObj, 'FIELDSET');
    if (subviewContainer) {
        subviewContainer.dataset.isLoading = loading;
    }
}

function allSubviewsLoaded() {
    const dtaDiv = XDOM.getObject('DTADIV');
    const loading = dtaDiv.querySelectorAll('[data-is-loading="true"]');
    return loading.length === 0;
}

function setCursorFromStateless() {
    if (!allSubviewsLoaded()) {
        return;
    }
    if (GLOBAL.focusFirstSubView) {
        obj = getFirstField();
        XDOM.focus(obj);
        GLOBAL.focusFirstSubView = false;
        return;
    }
}

/**
 * haalt eerste te focusen element op van de pagina op basis van de volgorde in de dom
 * noormaal gesproken is dit het element dat links boven aan staat
 * geordend van links naar rechts
 */
function getFirstField() {
    const dtaDiv = XDOM.getObject('DTADIV'),
        query =
            "input:not([type='hidden']):not([data-hidden='true']):not([data-protected='true']), " +
            "textarea:not([type='hidden']):not([data-hidden='true']):not([data-protected='true']):not([data-hidden-line='true'])";
    return dtaDiv.querySelector(query);
}

/**
 * Position cursor or give focus obv SESSION.activePage.lastSelectedInput
 * @return void
 */
function setCursor(useScope = SESSION.submitFromScope) {
    if (
        !SESSION.activePage ||
        SESSION.session.state == 'inactive' ||
        OCULUS.tablet ||
        BrowserDetect.isiPad ||
        !OCULUS.extendedNav
    ) {
        return;
    }

    let obj = XDOM.getObject(SESSION.activePage.cursorFocus) ;
    //when object is a mask object is hidden so first get the visable object
    if (Mask.isMask(obj)) {
        obj = Mask.getFirstPart(obj); //bij een masker het eerste element gebruiken
    }
    if(!obj ||  isHidden(obj)){
        obj = getFirstField();
        //object might be a mask so in that case get first field
        if (Mask.isMask(obj)) {
            obj = Mask.getFirstPart(obj); //bij een masker het eerste element gebruiken
        }
    }
    obj = Logical.getDisplayObj(obj);

    if (!obj) {
        //er is geen input veld gevonden probeer de focus te zetten in een subview als deze worden geladen
        //voor nu zet de focus op een knop of het frame
        Stateless.setTryFirstSubview();
        if (setCursorFFBugFix()) {
            return;
        }
        obj = XDOM.query("[data-command-focused='true']", SESSION.activeForm) ||
            XDOM.getObject('CLOSE', SESSION.activeForm) ||
            XDOM.getObject('ENTER', SESSION.activeForm) ||

            SESSION.activeFrame;
    }
//obj.constructor.name === "Window"
    if (!Stateless.canHaveFocus(obj)){
        return;
    }
    let scope = '';
    //feature check  if not hen the object is window witch is fine
    if(obj.getAttribute){
        scope =
            obj.getAttribute('data-panel-id') ||
            obj.getAttribute('data-quicksearch-selectfield') ||
            obj.getAttribute('data-prompt-field') ||
            obj.getAttribute('data-stateless-page-id') ||
            'MAIN';
    }


    if (scope == useScope) {
        SESSION.submitFromScope = '';
        XDOM.focus(obj);
    }
}

function autoOpen(obj) {
    if (Service.autoObject) {
        return;
    }

    var foCurrentObj = definitions.currentObject.calender;
    if (!foCurrentObj) {
        foCurrentObj = definitions.currentObject.choiceService;
    }
    if (!foCurrentObj) {
        foCurrentObj = definitions.currentObject.quickSearch;
    }

    if (!foCurrentObj) {
        return;
    } // -->
    if (!foCurrentObj.action) {
        return;
    } // -->

    switch (foCurrentObj.action) {
        case ENUM.serviceAction.userAction:
            return;
            break;
        case ENUM.serviceAction.cursorAndBlank:
            if (obj.value.length > 0 && SESSION.activePage.messageLevel != 'F') {
                return;
            }
            break;
        case ENUM.serviceAction.cursorAndError:
            if (SESSION.activePage.messageLevel != 'F') {
                return;
            }
            break;
        default:
            return;
    }
    if (foCurrentObj.quickSearch) {
        foCurrentObj.quickSearch.open(false);
        return;
    } else {
        //openService(foCurrentObj, false);
        //todo: ajax
    }
    return;
}

/**
 * zet de tekst in de balk onderin met bijbehorende stijl balk.
 * @param status status van de boodschap
 * @param message de boodschap zelf
 * @param longMessage mouse over title text
 */
function setMessage(status, message, longMessage) {
    var slongMessage = longMessage;
    var oMSG = XDOM.getObject('MSGTXT');
    if (!oMSG) {
        return;
    }
    var commandDiv = XDOM.getObject('CMDDIV');
    var longMessageIcon = XDOM.getObject('LONGMESSAGEICON');
    switch (status) {
        case 'G':
        case 'A':
            commandDiv.className = 'STS_A';
            break;
        case 'V':
            commandDiv.className = 'STS_B';
            break;
        case 'S':
            commandDiv.className = 'STS_C';
            break;
        case 'W':
            commandDiv.className = 'STS_D';
            break;
        case 'F':
            commandDiv.className = 'STS_E';
            break;
        case 'M':
            commandDiv.className = 'STS_M';
            break;
        default:
            commandDiv.className = '';
            //XDOM.setAttribute(commandDiv, "data-message-status='default'")
            break;
    }
    if (document.all) {
        oMSG.innerText = message;
    } else {
        oMSG.textContent = message;
    }

    //als er een lange MSG is dan kan deze in een TITLE attribute getoond worden
    if (slongMessage) {
        longMessageIcon.setAttribute('data-hidden', 'false');
        GUI.infoTitle.register(commandDiv, slongMessage);
    } else {
        longMessageIcon.setAttribute('data-hidden', 'true');
        GUI.infoTitle.register(commandDiv, '');
    }
}

/**
 * haalt de tekst in de balk onderin weg en zet de stijl terug naar geen bericht.
 */
function resetMessage() {
    if (SESSION.submitInProgress) {
        return;
    }
    setEventsMessage('', '');
    return;
}

function logoutIe() {
    document.execCommand('ClearAuthenticationCache', 'false');
    top.location.reload();
}

function logout() {
    if (BrowserDetect.isEdge || BrowserDetect.isIE) {
        logoutIe();
    }
    if (BrowserDetect.isChrome) {
        logoutChrome();
    }
    //jammer nog geen mooie oplossing voor firefox
    top.location.href = top.location.href.replace('http://', 'http://logout@');
}

function logoutChrome() {
    const xmlHttpRequest = new XMLHttpRequest(),
        thisUri = location.href.replace('http://', 'http://logout@');

    xmlHttpRequest.onreadystatechange = function () {
        if (xmlHttpRequest.readyState == 4) {
            top.location.reload();
        }
    };

    xmlHttpRequest.open('GET', thisUri, true);
    xmlHttpRequest.setRequestHeader('Authorization', 'Basic logout');
    xmlHttpRequest.send();
    return false;
}

const readerAsDataURL = inputFile => {
    const reader = new FileReader();

    return new Promise((resolve, reject) => {
        reader.onerror = () => {
            reader.abort();
            reject(new DOMException('Problem parsing input file.'));
        };

        reader.onload = () => {
            resolve(reader);
        };
        reader.readAsDataURL(inputFile);
    });
};

/* calfcn */
/* Load Timestamp 13:59:55.622 */
var gTODAY=new Date();
var fACTDT=new Date();
var fPRTDAG=new Date();
var RE_NUM=/^\-?\d+$/;
var NUM_WEEKSTART=1;

function Calender(targetId, axis, visible,cellAxis){
    this.targetId = targetId;
    this.visible = visible;

    this.targetObject = null;
    this.activeDate = new Date();
    this.hoveredDate = new Date();
    this.foFocusField = [];
    this.today = new Date();
    this.placeHolder = null;
    this.caldiv = null;
    this.calwrapperdiv = null;
    this.weekRows = 0;
    this.calingField = null;
    this.shiftPressed = false;
    this.axis = axis;
    this.cellAxis = cellAxis,
        this.recordNumber = parseInt(XDOM.getAttribute(targetId, "data-record-number"));
}
Calender.currentInstance = null;

Calender.prototype.init = function(){
    this.displayObject = XDOM.getObject('CAL_' + this.targetId);
    if(!hasValue(this.visible)){
        this.visible = true;
    }

    if(!this.visible && this.displayObject){
        this.displayObject.className = 'hidden';
        return;
    }
    this.renderIcon();
};

Calender.prototype.open = function(calingField){
    XDOM.cancelEvent();
    var dateValue = '';

    if(!this.visible){
        return;
    }
    closePopUp();

    this.targetObject = XDOM.getObject(this.targetId);
    this.calingField = this.targetObject;
    Calender.currentInstance = this;
    Mask.completeAllParts(this.targetObject);
    dateValue = this.targetObject.value;



    if (!dateValue || dateValue == '  -  -') {
        this.activeDate=new Date();                 // actieve datum
    }  else {
        this.setActiveDate(dateValue,this.targetObject.getAttribute("data-mask"));
    }

    this.hoveredDate = this.activeDate;
    this.render();
};

Calender.prototype.setActiveDate = function(value,dateFormat){
    var year = null, week = null, day= null;
    switch(dateFormat){
        case '*DMY':
        case '*DMCY':
        case '*DMYY':
            this.activeDate=string2Date(value);
            return;
            break;
        case '*YWD':
            year = value.substring(0, 2);
            if(year.trim()){
                year = '20' + year;
            }
            week = value.substring(2, 4);
            day = value.substring(4, 5);
            break;
        case '*CYWD':
            year = value.substring(0, 4);
            week = value.substring(4, 6);
            day = value.substring(6, 7);
            break;
        case '*CYW':
            year = parseInt(value.substring(0, 4));
            week = value.substring(4, 6);
            day = '1';
            break;
        case '*YWK':
            year = value.substring(0, 2);
            if(year.trim()){
                year = '20' + year;
            }
            week = value.substring(2, 4);
            day = '1';
            break;
        default:
            this.activeDate = string2Date(value);
            break;
    }
    this.setActiveYwdDate(year,week,day);

};

Calender.prototype.setActiveYwdDate = function(yearIn,weekIn,dayIn){
    var dayToAdd = 0,
        year = 0,
        week = 0,
        day = 0,
        returnDate = mondayFirstWeek(year),
        today = new Date();


    year = parseInt(yearIn)|| today.getFullYear();
    week = parseInt(weekIn) || 1;
    day = parseInt(dayIn) || 1;

    returnDate = mondayFirstWeek(year);

    day--; // maandag is 1 die zit al in mondayFirstWeek;
    week--; // week 1 zit al in mondayFirstWeek



    dayToAdd = (week * 7) + day;
    returnDate.setDate(returnDate.getDate() + dayToAdd);
    this.activeDate = returnDate;
};


Calender.close = function() {
    var firstElement = null;
    if(Calender.currentInstance){
        XDOM.removeDOMObject(Calender.currentInstance.placeHolder);
        if(Calender.currentInstance.calingField){
            firstElement = Calender.currentInstance.calingField.getAttribute("data-mask-first-part")
            XDOM.focus(firstElement);
        }
        Calender.currentInstance = null;
        return true;
    }
    return false;
};

Calender.prototype.render = function(actionBy) {
    var foParent = XDOM.getObject('DTADIV');
    // in een calender komen maximaal 6 van 40px hoog en
    // en een header van 89 de max hoogte is dus 89  + (6 * 40) = 329
    // ten behoeven van de uitleining wordt de calender eerst op een maximaal gezet
    var maxHeight = '329px';

    this.placeHolder=XDOM.createElement("DIV","popCALWDW","");
    this.caldiv = XDOM.createElement("DIV", "CALDIV");
    this.calwrapperdiv = XDOM.createElement("DIV", "CALWRAPPER");
    this.caldiv.appendChild(this.calwrapperdiv);
    this.placeHolder.appendChild(this.caldiv);

    this.renderHeader();
    this.renderTable();

    XDOM.removeDOMObject("popCALWDW");
    foParent.appendChild(this.placeHolder);
    this.caldiv.setAttribute("data-click-action", "closePopup");
    this.placeHolder.setAttribute("data-click-action", "closePopup");

    var foMaskDiv = XDOM.getObject(this.targetObject.id + '_container');

    this.placeHolder.style.height= maxHeight;
    var pos = alignTo(this.placeHolder, foMaskDiv,foParent);
    this.placeHolder.style.height= '';

    this.placeHolder.style.top = pos.top + 'px';
    this.placeHolder.style.left = pos.left + 'px';





    this.foFocusField = XDOM.getObject('ACTDAT');

    if (this.foFocusField) {
        this.foFocusField = this.foFocusField.children[0];
        this.foFocusField.focus();
    }

    if(actionBy == 'usr'){

        newDate = [
            this.hoveredDate.getFullYear(),
            this.hoveredDate.getMonth(),
            this.hoveredDate.getDate()
        ];

        var newSelection = XDOM.getObject(newDate[0]+"_"+newDate[1]+"_"+newDate[2]);
        this.foFocusField = newSelection;
        newSelection.focus();

        this.highlight();
    }

    XDOM.cancelEvent();
    return;
};

Calender.dayHeaders = function(){
    var foTr = XDOM.createElement("TR","", "Weekdays");
    var foTd = XDOM.createElement("td","", "");
    var ttlClass = 'workDayTTL';
    const weekDays =     getCaptionSet('ARR_WEEKDAYS');
    foTd.appendChild(XDOM.createTextNode(getCapt('gCAL023')));
    foTr.appendChild(foTd);
    for (var n=0; n<7; n++){
        if(n >=5){
            ttlClass = "weekendTTL";
        }

        foTd = XDOM.createElement("td","", ttlClass);
        foTd.appendChild(XDOM.createTextNode(weekDays[(NUM_WEEKSTART+n)%7]));
        foTr.appendChild(foTd);
    }
    return foTr;
};


Calender.prototype.renderDay = function(foDate, dayNr){
    var fsCss = ' working theme-font-color';
    var foTd = null;
    var foInput = null;
    var day = foDate.getDate().toString().lftzro(2);
    var month = (foDate.getMonth() + 1).toString().lftzro(2);
    var year = foDate.getFullYear().toString().lftzro(2);
    //var week = foDate.getWeek().toString().lftzro(2);
    var dateString = '';


    if(foDate.getDay() == 0 || foDate.getDay() == 6) {// weekend days
        fsCss = ' weekend ';
    }

    //id voor TD's in cal
    foTd = XDOM.createElement("TD","", 'date ' + fsCss);

    if (foDate.getDate() == this.today.getDate() &&
        foDate.getMonth() == this.today.getMonth() &&
        foDate.getFullYear() == this.today.getFullYear()) {
        fsCss = ' today ';

    }

    if (foDate.getMonth() == this.hoveredDate.getMonth()) {// print days of current month
        fsCss += ' thisMonth';
    }else{
        fsCss += ' notThisMonth';
    }

    if (
        foDate.getDate() == this.activeDate.getDate() &&
        foDate.getMonth() == this.activeDate.getMonth() &&
        foDate.getFullYear() == this.activeDate.getFullYear()
    ) {
        foTd.id = "ACTDAT";
    }

    //ISO 8601 string
    dateString = year+"-"+month+"-"+day; //+ "T00:00:00.000";

    foInput = XDOM.createElement("INPUT","",'datinp ' + fsCss);
    foInput.type="button";
    foInput.value=foDate.getDate();
    foInput.id = foDate.getFullYear()+"_"+foDate.getMonth()+"_"+foDate.getDate();
    foInput.setAttribute('data-calender-return-data', dateString);
    foInput.setAttribute('data-click-action', "Calender.returnDate");

    foInput.setAttribute('data-calender-return-data-day', day);
    //foInput.setAttribute('data-calender-return-data-week', week);
    foInput.setAttribute('data-calender-return-data-month', month);
    foInput.setAttribute('data-calender-return-data-year', year);
    foInput.setAttribute('data-calender-return-data-day-number', dayNr);



    foTd.appendChild(foInput);
    foTd.setAttribute('data-calender-return-data', dateString);
    foTd.setAttribute('data-click-action', "Calender.returnDate");

    foTd.setAttribute('data-calender-return-data-day', day);
    //foTd.setAttribute('data-calender-return-data-week', week);
    foTd.setAttribute('data-calender-return-data-month', month);
    foTd.setAttribute('data-calender-return-data-year', year);
    foTd.setAttribute('data-calender-return-data-day-number', dayNr);

    return foTd;
};

Calender.prototype.renderTable = function() {

    var foTempDate=new Date(this.hoveredDate);
    foTempDate.setDate(1);
    var foDay=new Date(foTempDate.setDate(1 - (7 + foTempDate.getDay() - NUM_WEEKSTART) % 7));

    var foTr = null;
    var foTd = null;

    var foTbody =  XDOM.createElement("TBODY");
    var foResultTable = XDOM.createElement("TABLE","CALTBL" );
    var week 		= foDay.getWeek();
    var dateVars	= null;
    var fiCurrentMonth =foDay.getMonth();
    var yearWeek = null;
    var swichedYear = false;

    var getThursday = null;
    var getYearWeek = null;

    foResultTable.appendChild(foTbody);

    foTbody.appendChild(Calender.dayHeaders());
    this.weekRows = 0;
    while (foDay.getMonth() == this.hoveredDate.getMonth() || foDay.getMonth() == fiCurrentMonth) {
        this.weekRows++;

        getThursday = new Date(foDay);
        getThursday.setDate(getThursday.getDate() + 3); //donderdag bepalen.
        getYearWeek = getThursday.getFullYear();

        foTr = XDOM.createElement("TR");
        foTr.setAttribute("data-calender-yearWeek", getYearWeek);
        foTr.setAttribute("data-calender-week", foDay.getWeek().toString().lftzro(2));

        foTd = XDOM.createElement("TD","","date");
        foTd.appendChild(XDOM.createTextNode(foDay.getWeek()));
        foTr.appendChild(foTd);

        for (var fCURWD=0; fCURWD<7; fCURWD++) {
            foTr.appendChild(this.renderDay(foDay,fCURWD+1));
            foDay.setDate(foDay.getDate() + 1);
        }

        foTbody.appendChild(foTr);
    }

    this.calwrapperdiv.appendChild(foResultTable);

    return;
};

Calender.handleOnClick = function(e){
    if(e){
        XDOM.getEvent(e);
    }
    if(GLOBAL.eventSourceElement.getAttribute("data-service-type")==ENUM.serviceType.calendar){
        var foCal = new Calender(GLOBAL.eventSourceElement.getAttribute("data-to-id"),null,true);
        foCal.open();
    }
};

Calender.open = function (obj){
    if(GLOBAL.eventSourceElement.getAttribute("data-service-type")==ENUM.serviceType.calendar){
        var foCal = new Calender(obj.getAttribute("data-mask-target"),null,true);
        foCal.open();
    }
};


Calender.handleKeyDown = function(e){
    if(e){
        XDOM.getEvent(e);
    }

    if(!Calender.currentInstance){return false;}
    if(this.shiftPressed){return true;}
    switch(GLOBAL.charCode){
        case  keyCode.shift:
            this.shiftPressed = true;
        case  keyCode.F4:
        case  keyCode.F2:
            return false;
            break;
    }
    return true;
};


/**
 * Keyboard handling tbv kalender
 */
Calender.handleKeyUp = function(e){
    if(e){
        XDOM.getEvent(e);
    }

    if(!Calender.currentInstance){return false;}
    XDOM.cancelEvent(e);
    this.shiftPressed = GLOBAL.event.event.shiftKey;
    switch(GLOBAL.charCode){
        case  keyCode.arrowLeft:
            if(this.shiftPressed){
                Calender.previousMonth(null, 'usr');
            } else {
                Calender.currentInstance.navigateCalender("prevDay");
            }
            break;
        case  keyCode.arrowUp:
            if(this.shiftPressed){
                Calender.previousYear(null, 'usr');
            }else {
                Calender.currentInstance.navigateCalender("prevWeek");
            }
            break;
        case  keyCode.arrowRight:
            if(this.shiftPressed){
                Calender.nextMonth(null, 'usr');
            }else {
                Calender.currentInstance.navigateCalender("nextDay");
            }
            break;
        case  keyCode.arrowDown:
            if(this.shiftPressed){
                Calender.nextYear(null, 'usr');
            }else {
                Calender.currentInstance.navigateCalender("nextWeek");
            }
            break;
        case  keyCode.tab:
            if(this.shiftPressed){
                Calender.currentInstance.navigateCalender("prevDay");
            }else {
                Calender.currentInstance.navigateCalender("nextDay");
            }
            break;
        case  keyCode.space:
        case  keyCode.enter:
            Calender.returnDate(Calender.currentInstance.hoveredDate);
            break;
        case  keyCode.shift:
            this.shiftPressed = false;
            break;
        case keyCode.escape:
        case keyCode.F12:
            closePopUp();
            break;
        default:
            return;
            break;
    }
    GLOBAL.eventObject.remapKeyCode();
    return true;

};




Calender.prototype.renderHeader = function (){
    var fsMonthYear = getCaptionSet('ARR_MONTHS')[this.hoveredDate.getMonth()] + ' ' + this.hoveredDate.getFullYear();

    var foPanelHeader = XDOM.createElement("DIV", "", "calendarPanelHeader theme-background-color");
    var foCurrentMonth = XDOM.createElement("DIV", "", "curMonth");
    var foExit = XDOM.createElement("DIV","MEXIT", "pth-close closeCalendarButton");
    var foCalHeader = XDOM.createElement("DIV", "CALHDR");
    var foPrvYear = XDOM.createElement("DIV", "prvYear",   "pth-icon prvYear");
    var foPrvMonth = XDOM.createElement("DIV", "prvMonth", "pth-icon prvMonth");
    var foSltToday = XDOM.createElement("DIV", "sltToday", " sltToday theme-hover-background-color theme-background-color");
    var foNxtMonth = XDOM.createElement("DIV", "nxtMonth", "pth-icon nxtMonth");
    var foNxtYear = XDOM.createElement("DIV", "nxtYear",   "pth-icon nxtYear");

    foPanelHeader.appendChild(foCurrentMonth);
    foPanelHeader.appendChild(foExit);
    //foPanelHeader.setAttribute("data-mousedown-action", "Dragger.start");
    //foPanelHeader.setAttribute("data-dragger-objid", "popCALWDW");


    this.caldiv.appendChild(foPanelHeader);


    /*this.caldiv.appendChild(foCurrentMonth);
    this.caldiv.appendChild(foExit);*/

    foCurrentMonth.appendChild(XDOM.createTextNode(fsMonthYear));

    foSltToday.appendChild(XDOM.createTextNode(getCapt('gCAL022')));


    foCalHeader.appendChild(foPrvYear);
    foCalHeader.appendChild(foPrvMonth);
    foCalHeader.appendChild(foSltToday);
    foCalHeader.appendChild(foNxtMonth);
    foCalHeader.appendChild(foNxtYear);


    this.calwrapperdiv.appendChild(foCalHeader);


    foPrvYear.setAttribute("data-click-action",  "Calender.previousYear");
    foPrvMonth.setAttribute("data-click-action", "Calender.previousMonth");
    foSltToday.setAttribute("data-click-action", "Calender.setToday");
    foNxtMonth.setAttribute("data-click-action", "Calender.nextMonth");
    foNxtYear.setAttribute("data-click-action",  "Calender.nextYear");
    foExit.setAttribute("data-click-action",  "closePopUp");
    this.caldiv.setAttribute("data-click-action",  "closePopUp");
    foCurrentMonth.setAttribute("data-click-action",  "closePopUp");
};





Calender.setToday = function(e) {
    Calender.returnDate(new Date());
    return;
};

Calender.nextYear = function (e ,actBy){
    XDOM.cancelEvent(e);
    var foDate=new Date(Calender.currentInstance.hoveredDate);
    var oldYear = foDate.getFullYear();
    var newYear = oldYear + 1;
    foDate.setYear(newYear);
    // Let op: kan jaar overslaan (schrikkeljaar); zo nodig naar laatste dag goede jaar
    while(foDate.getFullYear() > newYear) foDate.setDate(foDate.getDate() - 1);
    Calender.currentInstance.hoveredDate=foDate;
    Calender.currentInstance.render(actBy);

    return;
};


Calender.nextMonth = function(e, actBy){
    XDOM.cancelEvent(e);
    var foDate=new Date(Calender.currentInstance.hoveredDate);
    var oldMonth = foDate.getMonth();
    var newMonth = oldMonth + 1;
    foDate.setMonth(newMonth);
    // Let op: kan maand overslaan (31-01 -> 03-03); zo nodig naar laatste dag goede maand
    if (newMonth < 12) while(foDate.getMonth() > newMonth) foDate.setDate(foDate.getDate() - 1);
    Calender.currentInstance.hoveredDate = foDate;
    Calender.currentInstance.render(actBy);
    return;
};

Calender.previousYear = function(e, actBy){
    XDOM.cancelEvent(e);
    var foDate=new Date(Calender.currentInstance.hoveredDate);
    var oldYear = foDate.getFullYear();
    var newYear = oldYear - 1;
    foDate.setYear(newYear);
    // Let op: kan jaar overslaan (schrikkeljaar); zo nodig naar eerste dag goede jaar
    while(foDate.getFullYear() < newYear) foDate.setDate(foDate.getDate() + 1);
    Calender.currentInstance.hoveredDate = foDate;
    Calender.currentInstance.render(actBy);
    return null;
};

Calender.previousMonth = function(e, actBy){
    XDOM.cancelEvent(e);
    var foDate=new Date(Calender.currentInstance.hoveredDate);
    var oldMonth = foDate.getMonth();
    var newMonth = oldMonth - 1;
    foDate.setMonth(newMonth);
    // Let op: kan maand overslaan (31-03 -> 03-03); zo nodig naar laatste dag goede maand
    if (newMonth > 0) while(foDate.getMonth() > newMonth) foDate.setDate(foDate.getDate() - 1);
    Calender.currentInstance.hoveredDate=foDate;
    Calender.currentInstance.render(actBy);
    return null;
};

Calender.previousDay = function(minus){
    var foDate=new Date(Calender.currentInstance.hoveredDate);
    var oldDay = foDate.getDate();
    var newDay = oldDay - minus;
    foDate.setDate(newDay);

    return foDate;
};


Calender.nextDay = function(plus){
    var foDate=new Date(Calender.currentInstance.hoveredDate);
    var oldDay = foDate.getDate();
    var newDay = oldDay + plus;
    foDate.setDate(newDay);

    return foDate;
};

var newDate = null;
var currentDate = null;

Calender.prototype.navigateCalender = function (direction){

    currentDate 	= this.foFocusField.id.split("_");

    var getNewDate = null;

    switch(direction){
        case "prevDay":
            getNewDate = Calender.previousDay(1);
            break;
        case "prevWeek":
            getNewDate = Calender.previousDay(7);
            break;
        case "nextDay":
            getNewDate = Calender.nextDay(1);
            break;
        case "nextWeek":
            getNewDate = Calender.nextDay(7);
            break;
    };


    newDate = [
        getNewDate.getFullYear(),
        getNewDate.getMonth(),
        getNewDate.getDate()
    ];


    if(this.foFocusField){
        this.cancelHighlight();
    }

    var controlDate1 = 	new Date(newDate[0],newDate[1],1);
    var controlDate2 = 	new Date(currentDate[0],currentDate[1],1);

    if(controlDate1 > controlDate2){
        Calender.nextMonth();
    }	else if(controlDate1 < controlDate2){
        Calender.previousMonth();
    }

    newSelection = XDOM.getObject(newDate[0]+"_"+newDate[1]+"_"+newDate[2]);
    Calender.currentInstance.hoveredDate = new Date(getNewDate);

    this.foFocusField = newSelection;
    newSelection.focus();

    this.highlight();

    return;
};

/**
 * @returns
 */

Calender.returnDate = function(dateIn){

    var instance = Calender.currentInstance.targetObject;
    var mask = Calender.currentInstance.targetObject.getAttribute("data-mask");
    var lastField = null,
        day = null,
        week = null,
        yearWeek = null,
        month = null,
        year = null,
        dayNr = null,
        returnValue = null;

    if(instance.getAttribute("data-protected")=="true"){
        closePopUp();
        return;
    }

    if(dateIn){
        day      = dateIn.getDate().toString().lftzro(2);
        week     = dateIn.getWeek().toString().lftzro(2);
        month    = (dateIn.getMonth() +1).toString().lftzro(2);
        year     = dateIn.getFullYear().toString().lftzro(2);
        yearWeek = year;
        dayNr    = (dateIn.getMDay()+1).toString();
    }else{
        day      = XDOM.GLOBAL.getAttribute('data-calender-return-data-day');
        week     = XDOM.getParentByTagName(GLOBAL.eventSourceElement, "TR").getAttribute('data-calender-week');
        yearWeek = XDOM.getParentByTagName(GLOBAL.eventSourceElement, "TR").getAttribute('data-calender-yearWeek');
        month    = XDOM.GLOBAL.getAttribute('data-calender-return-data-month');
        year     = XDOM.GLOBAL.getAttribute('data-calender-return-data-year');
        dayNr    = XDOM.GLOBAL.getAttribute('data-calender-return-data-day-number');
    }

    returnValue = formatDate(dayNr,day,week,month,year,yearWeek,mask);

    XDOM.setObjectValue(Calender.currentInstance.targetObject,returnValue);
    Subfile.setChanged(Calender.currentInstance.recordNumber);
    closePopUp();

    handleOnChange(instance);
    lastField = XDOM.getObject(instance.getAttribute("data-mask-last-part"));

    if(!isAutoSubmitField(instance) && lastField){
        fp.next(lastField);
    }
    return;
};


function formatDate(dayNr,day,week,month,year,yearWeek,mask){
    switch(mask){
        case '*CYQ':
            return year + Math.ceil( parseInt(month)/3);
            break;
        case '*YRQ':
            return year.substring(2) + Math.ceil( parseInt(month)/3);
            break;
        case '*DMY':
            return day + month + year.substring(2);
            break;
        case '*DMCY':
        case '*DMYY':
        case '*EUR':
            return day + month + year;
            break;
        case '*CYWD':
            return yearWeek + week + dayNr;
            break;
        case '*CYW':
            return yearWeek + week;
            break;
        case '*YWK':
            return yearWeek.substring(2) + week;
            break;
        case '*YWD':
            return yearWeek.substring(2) + week + dayNr;
            break;
        case '*YRP':
            return year.substring(2) + month; //navragen
            break;
        default:
            return day + month + year;
            break;

    }
}

function formatDatex() {
    var fTEMP=arguments[0];
    var fFORMAT=arguments[1];

    var fTEMP_dg=fTEMP.getDate().toString();
    var fTEMP_mn=(fTEMP.getMonth()+1).toString();
    var fTEMP_jr=fTEMP.getFullYear().toString();
    var fTEMP_qrt = Math.ceil(fTEMP_mn/3);
    var fTMPDT = null;
    var fJR= '';

    if (fTEMP_dg < 10) { fTEMP_dg='0' + fTEMP_dg; }
    if (fTEMP_mn < 10) { fTEMP_mn='0' + fTEMP_mn; }


    // YYYY/QQ
    if (fFORMAT == 'CYQ') {
        fTMPDT=fTEMP_jr + '/' + fTEMP_qrt;
    }
    // DD-MM-CCJJ
    if (fFORMAT == 'DMCY') {
        fTMPDT=fTEMP_dg
            + '-' + fTEMP_mn
            + '-' + fTEMP_jr;
    }
    // *DMY
    if (fFORMAT == '*DMY') {
        fJR=fTEMP_jr.toString().substring(2);
        fTMPDT=fTEMP_dg
            + fTEMP_mn
            + fJR;
    }
    // *DMYY en *EUR
    if (fFORMAT == '*DMYY' ||
        fFORMAT == '*EUR') {
        fTMPDT=fTEMP_dg
            + fTEMP_mn
            + fTEMP_jr;
    }
    // *CYWD
    if (fFORMAT == '*CYWD') {
        fTMPDT=fTEMP.getWeekDate();
    }
    // *CYW
    if (fFORMAT == '*CYW') {
        fTMPDT=fTEMP.getWeekDate().substring(0,6);
    }

    // blanko formaat=ddmmccjj
    if (fFORMAT == '') {
        fTMPDT=fTEMP_dg
            + fTEMP_mn
            + fTEMP_jr;
    }
    return fTMPDT;
}

function string2Date() {
    var fSTRDATE=arguments[0].trim();
    var dt_date=new Date();
    dt_date.setDate(1);

    try {
        if (fSTRDATE) {
            // Splits in dag/maand/jaar indien opgemaakt (dd-mm-eejj)
            var arr_date=fSTRDATE.split('-');
            // Splits in dag/maand/jaar indien niet opgemaakt (ddmmeejj of ddmmjj)
            if(arr_date.length == 1 && fSTRDATE.length >= 6) {
                arr_date[0]=fSTRDATE.substring(0,2);
                arr_date[1]=fSTRDATE.substring(2,4);
                arr_date[2]=fSTRDATE.substring(4);
            }
            // Goede jaar in datum zetten
            if (RE_NUM.exec(arr_date[2])) {
                // Jaar zo nodig corrigeren
                if (arr_date[2] < 100) arr_date[2]= Number(arr_date[2]) + 2000;
                dt_date.setFullYear(arr_date[2]);
            }
            // Goede maand in datum zetten
            if (RE_NUM.exec(arr_date[1]) && arr_date[1] >= 1 && arr_date[1] <= 12) {
                dt_date.setMonth(arr_date[1]-1);
            }
            // Goede dag in datum zetten
            if (RE_NUM.exec(arr_date[0]) && arr_date[0] >= 1 && arr_date[1] <= 31) {
                dt_date.setDate(arr_date[0]);
            }
        }
    } catch(err) {
    }

    return (dt_date);
}

Calender.prototype.highlight = function(){
    this.foFocusField.className += " dateActive";
    return;
};

Calender.prototype.cancelHighlight = function(){
    this.foFocusField.className = this.foFocusField.className.replace(" dateActive", "");
    return;
};



/* messages */
/* Load Timestamp 13:59:55.623 */

/**
 * voor de vertaling van messageCodes naar taal afhankelijke strings
 * @version V8R3M22 POM-2275 alert naar setMessage overgezet, tekst in variabele t.b.v. vertaaling
 */
var MESSAGES = {};
var ERRORMESSAGES = {};
/**
 * wordt bij prepareDom aangeroepen omdat dan pas de taalafhankelijke variabelen zijn geladen
 * @returns {void}
 */
MESSAGES.prepare = function(){
    MESSAGES.Success=getCapt('msgSuccess');
    MESSAGES.HandlerError=getCapt('msgHandlerError');
    MESSAGES.ArchiveNotFound=getCapt('msgArchiveNotFound');
    MESSAGES.ConfError=getCapt('msgConfError');
    MESSAGES.KeyError=getCapt('msgKeyError');
    MESSAGES.DocNotFound=getCapt('msgDocNotFound');
    MESSAGES.SymLinkError=getCapt('msgSymLinkError');
    MESSAGES.extentionNotSupported=getCapt('msgExtentionNotSupported');


    ERRORMESSAGES['HeaderRequired'] 	= {"caption": getCapt('gQSEARCHHEADERREQUIRED'), messageLevel:'message'	};
    ERRORMESSAGES['InputRequired']  	= {"caption": getCapt('gQSEARCHINPUTREQUIRED'), 	messageLevel:'OK'	};
    ERRORMESSAGES['InvalidInput']  		= {"caption": getCapt('gQSEARCHINVALIDINPUT'), 	messageLevel:'error'	};
    ERRORMESSAGES['SqlPrepareError'] 	= {"caption": getCapt('gQSEARCHSQLPREPAREERR'), 	messageLevel:'error'	};
    ERRORMESSAGES['SqlFetchError'] 		= {"caption": getCapt('gQSEARCHSQLFETCHERR'), 		messageLevel:'error'	};
    ERRORMESSAGES['ResultSetEmpty'] 	= {"caption": getCapt('gQSEARCHRESULTSETEMPTY'), messageLevel:'OK'	};
    ERRORMESSAGES['SubfileFull'] 	    = {"caption": "", messageLevel:'OK'	};
    ERRORMESSAGES['ParameterError'] 	    = {"caption": getCapt('gMESSAGEPARAMETERERROR'), messageLevel:'error'	};
    ERRORMESSAGES['DataError'] 	    = {"caption": getCapt('gMESSAGEDATAERROR'), messageLevel:'error'	};
    ERRORMESSAGES['DataWarning'] 	    = {"caption": getCapt('gMESSAGEDATAWARNING'), messageLevel:'warning'	};
    ERRORMESSAGES['GenericError'] 	    = {"caption": getCapt('gMESSAGEGENERIC'), messageLevel:'error'	};




};


/* inzsession */
/* Load Timestamp 13:59:55.623 */
async function initSession() {
    setSessionVariables();

    // Settings is  loaded set in session.js session constructor
    // we need to make sure the settings are loaded before we go on
    // before loading the iframe that wil trigger this function in the onload event
    // this way the sources for the iframe and the settings will be loaded simultaniously
    await SCOPE.main.Settings.onLoad(SESSION.session.enviroment);


    initSessionOptions()

    SCOPE.main.AdminMenu.tabletMode(SESSION.session.enviroment);
    ProcedureMenu.render(SESSION.session.procedures || SESSION.session.homeProcedure);
    MAIN.SessionTab.newTab(SESSION);
    SESSION.session.setTitle();
    SESSION.session.helpUri = SESSION.menuDefinitionVarName;

    //needs to be scoped because of the loaded settings
    SCOPE.main.newTheme.initialiseJob(document, SESSION.session.enviroment);

    SESSION.session.authenticationToken = SESSION.AUTHTOKEN
    MAIN.SessionTab.activate(SESSION.jobId, SESSION.session);

    setResolutionMode();
    setEventHandlers();
    setCaptions();

    if (!SCOPE.main.User.check()) {
        return;
    }
    SESSION.session.zoom();

    startDefaultProcedure();
    KeepAlive.start();
}

function startDefaultProcedure() {
    let prc = SESSION.session.getDefaultPRC(),
        button = null;

    if (!prc && SCOPE.main.Settings.get('AUTO_LOAD_PROCEDURE')) {
        let procedures = SESSION.session.procedures.filter(o => typeof o !== 'string');
        prc = procedures[0] ? procedures[0].PRC : '';

    }
    button = SESSIONDOC.querySelector(`.procedureBtn[data-option-prc="${prc}"]`);

    if (button) {
        XDOM.invokeClick(button);
        return;
    }

    MAIN.focusMenu(SESSIONDOC.querySelector('.procedureMenu .row .procedureBtnContainer a'));
    return;
}

function setCaptions() {
    XDOM.setInnerText('chooseTitle', getCapt('gCHOOSETITLE'));

    //only if usersetting isActive
    if (typeof top.oculusSessionBackgroundTitle !== 'undefined') {
        if (top.oculusSessionBackgroundTitle) {
            XDOM.setInnerText('oculusSessionBackgroundTitle', top.oculusSessionBackgroundTitle);
        }
    } else {
        XDOM.setInnerText('oculusSessionBackgroundTitle', 'Oculus');
    }

    if (typeof top.oculusSessionBackgroundSubtitle !== 'undefined') {
        if (top.oculusSessionBackgroundSubtitle) {
            XDOM.setInnerText('oculusSessionBackgroundSubtitle', top.oculusSessionBackgroundSubtitle);
        }
    } else {
        XDOM.setInnerText('oculusSessionBackgroundTitle', 'iOpener');
    }
}

function setResolutionMode() {
    var foBodyTag = XDOM.getObject('INZ');
    if (foBodyTag) {
        foBodyTag.setAttribute('data-screen-size', this.macroResolution);

        foBodyTag.className = OCULUS.sessionResolution + 'Resolution';
    }
}


function setSessionVariables() {
    SESSIONDOC = SESSIONFRAME.frameElement.contentDocument;
    SESSION.appFrameObj = SESSIONFRAME.frameElement.contentDocument.querySelector("[data-frame-type='Application']");
    SESSION.antiFlashingFrameObj = SESSIONFRAME.frameElement.contentDocument.querySelector(
        "[data-frame-type='antiFlashing']"
    );
    SESSION.seachFrameObj = SESSIONFRAME.frameElement.contentDocument.querySelector("[data-frame-type='Search']");
    SESSION.topViewFrameObj = SESSIONFRAME.frameElement.contentDocument.querySelector("[data-frame-type='topView']");

    SESSION.appFrame = SESSION.appFrameObj.contentWindow;
    SESSION.antiFlashingFrameObj = SESSION.antiFlashingFrameObj.contentWindow;
    SESSION.searchFrame = SESSION.seachFrameObj.contentWindow;
    SESSION.topViewFrame = SESSION.topViewFrameObj.contentWindow;
    SESSION.activeFrame = SESSION.appFrame;

    SESSION.id = SESSIONFRAME.frameElement.id.split('_')[1]; //bepalen van id voor session op basis van id frameElement
    SESSION.session = MAIN.NAV.Session.instances[SESSION.id];
    SCOPE.session.enviroment = SESSION.session.enviroment;

    SESSIONFRAME.frameElement.contentDocument.body.setAttribute('data-session-id', SESSION.id);
    SESSIONFRAME.frameElement.contentDocument.body.setAttribute('data-browser-used', BrowserDetect.browserUsed);

    setBodyAttributes(SESSION.appFrame)
    setBodyAttributes(SESSION.antiFlashingFrameObj)
    setBodyAttributes(SESSION.searchFrame)
    setBodyAttributes(SESSION.topViewFrame)


    // session globals
    SESSION.session.defaultTheme = !SESSION.environmentTheme;
    SESSION.stack = SESSION.session.stack;
    SESSION.window = SESSIONFRAME;
    SESSION.session.validApps = OCULUS.validApps;
    SESSION.session.validModules = OCULUS.validModules;
    SESSION.session.setSessionAttributes(SESSION);
}

function setBodyAttributes(contentwindow){
    const body = contentwindow.frameElement.contentDocument.body
    // get the browser name
    const browser = BrowserDetect.browserUsed.toLowerCase()

    //determine if this is an enterprise version
    const isEnterprise = browser == "firefox" && BrowserDetect.version >= 128

    body.setAttribute('data-browser-used', browser);
    body.setAttribute('data-browser-is-enterprise', isEnterprise);
}

function initSessionOptions() {
    setHomeDummys(SESSION.session);
    var options = getEval('PFMBOX.' + SESSION.menuDefinitionVarName) || SESSION.session.homeMenu;

    if (!options) {
        SCOPE.main.Dialogue.alert(`menu definition  ${SESSION.menuDefinitionVarName} is not defined `, `Menu not defined`);
        return false;
    }
    SESSION.session.initOptions(options);
    setZoomFactor();
}

function setZoomFactor() {
    SESSION.session.zoomIn();
}

function setEventHandlers() {
    Events.register();
    XDOM.addEventListener(window, 'keydown', OCULUS.checkKeyCode);
    XDOM.addEventListener(window, 'keyup', OCULUS.removeKeyCode);
    XDOM.addEventListener(window, 'click', handleSessionClick);
}

function handleSessionClick(e) {
    XDOM.getEvent(e);
    switch (XDOM.GLOBAL.getAttribute('data-click-action')) {
        case 'Messages.close':
            Messages.close();
    }
}

function setDummyHomeMenuItem(procedure, session) {
    const menuItem = {
        PRC: 'DUMMY_HOME_PRC',
        DSC: 'Home',
        TTL: 'Home',
        OPT: [procedure],
        isHome: true
    };
    // SCOPE.session['DUMMY_HOME_MENU_ITEM'] = menuItem;
    session.homeMenu = menuItem;
    //set startMenu
    SESSION.menuDefinitionVarName = 'DUMMY_HOME_MENU_ITEM';
}

function setHomeForSubprocedure(session) {
    //define dummy items
    const startItem = session.option.PGM;
    let subProcedure = SCOPE.session[startItem] || session.homeSubProcedure;
    if (!subProcedure) {
        SCOPE.main.Dialogue.alert(`Home page definition ${startItem} not defined `);
        subProcedure = {};
    }
    subProcedure.SBP = startItem;
    subProcedure.TTL = 'Home';

    const procedure = {
        DFTAPP: subProcedure.DFTAPP,
        DFTSBP: startItem,
        PRC: 'DUMMY_HOME_PRC',
        APP: subProcedure.DFTAPP,
        OPT: [subProcedure],
        isHome: true
    };
    //set dumy home procedure definition on session scope
    // SCOPE.session['DUMMY_HOME_PRC'] = procedure;
    session.homeProcedure = procedure;
    setDummyHomeMenuItem(procedure, session);
}

function setHomeForMacro(session) {
    const {PGM, APP} = session.option;
    //set dummy subprocedure
    const subProcedure = {
        OPT: [
            {
                MCR: PGM,
                DSC: 'Home',
                TTL: 'Home',
                isHome: true
            }
        ],
        DFTAPP: APP,
        DFTMCR: PGM,
        isHome: true
    };
    session.homeSubProcedure = subProcedure;
    // SCOPE.session['DUMMY_HOME_SBP'] = subProcedure;

    session.option.PGM = 'DUMMY_HOME_SBP';
    //buble up to supProcedure
    setHomeForSubprocedure(session);
}

function setHomeDummys(session) {
    switch (session.option.HOMETYPE) {
        case '*MCR':
            setHomeForMacro(session);
            break;
        case '*SBP':
            setHomeForSubprocedure(session);
            break;
        case '*PRC':
            setHomeProcedure(session);
            break;
        default:
            break;
    }
}

function setHomeProcedure(session) {
    //define dummy items
    const startItem = session.option.PGM;
    let procedure = SCOPE.session[startItem];
    if (!procedure) {
        SCOPE.main.Dialogue.alert(`HomeProcedure ${startItem} not defined`);
        procedure = {};

    }
    procedure.PRC = startItem;
    procedure.TTL = 'Home';
    setDummyHomeMenuItem(procedure, session);
}

/* events */
/* Load Timestamp 13:59:55.624 */
/* global XDOM, GLOBAL, keyCode */

class Events {
    static register(p = window) {
        p.addEventListener('click', Events.handleClick);
        p.addEventListener('contextmenu', Events.contextmenu);
        p.addEventListener('mousedown', Events.handleAllEvents);
        p.addEventListener('mouseup', Events.handleAllEvents);
        p.addEventListener('keyup', Events.handleKeyUp);
        p.addEventListener('keydown', Events.handleKeydown);
        p.addEventListener('mouseenter', Events.handleAllEvents);
    }

    static contextmenu(e) {
        if (e.altKey) {
            return false;
        }

        if (SCOPE.main.ctx) {
            SCOPE.mainDoc.dispatchEvent(SCOPE.main.ctx.menu.closeCtx);
        }

        return Events.handleAllEvents(e);
    }
    static handleClick(e) {
        if (e.button === 2) {
            return false;
        } //firefoxbug

        if (SCOPE.main.ctx) {
            SCOPE.mainDoc.dispatchEvent(SCOPE.main.ctx.menu.closeCtx);
        }
        return Events.handleAllEvents(e);
    }

    static handleKeyUp(e) {
        return Events.handleAllEvents(e);
    }

    static handleKeydown(e) {
        return Events.handleAllEvents(e);
    }

    static handleAllEvents(e) {
        let event = Events.set(e);
        if (SCOPE.main.keyNav.edgeBugBlokkerHandler(e)) {
            return true;
        }
        if (event.handle()) {
            Events.stop(e);
            return true;
        }
        return false;
    }

    static set(e) {
        if (e) {
            GLOBAL.event = new Events(e);
        }
        return GLOBAL.event;
    }

    static stop(e) {
        //let event = Events.set(e);
        e.stopPropagation();
    }

    static cancel(e) {
        let event = Events.set(e);
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    cancel() {
        this.event.preventDefault();
        this.event.cancelBubble = true;
        this.event.stopImmediatePropagation();
    }

    constructor(e) {
        this.event = e;
        this.keyCode = e.keyCode;
        this.altKey = e.altKey;
        this.source = e.target;
        this.type = e.type;
    }

    static debugHelp(e) {
        let id = e.source.id;
        //  let ds = e.source.dataset;
        let type = e.event.type;
        // let code = e.keyCode;
        // let hotkeyHandler = ds.hotkeyHandler;
        switch (type) {
            case 'mousedown':
                id = id;
                break;
            case 'keyup':
                id = id;
                break;
            case 'keydown':
                id = id;
                break;
            case 'mouseenter':
                id = id;
                break;
        }
    }

    static getHandler(className, handler) {
        if (window[className] && window[className][handler]) {
            return window[className][handler];
        }
    }

    handle() {
        let className = 'AdminMenu',
            eventType = this.event.type,
            action = '';
        Events.debugHelp(this);

        this.invokeObject = XDOM.getParentByAttribute(this.source, 'data-event-class');
        if (this.invokeObject) {
            className = this.invokeObject.dataset.eventClass;
            eventType = this.invokeObject.getAttribute('data-' + this.event.type) || this.event.type;
            if(className=='none'){
                return true;
            }
        }

        if (MAIN.keyNav.handle(this)) {
            return true;
        }
        if (window[className] && window[className][eventType]) {
            window[className][eventType](this);
            return false;
        }
        if (window['handle' + eventType]) {
            window['handle' + eventType](this.event); //oude event handlers
            return true;
        }
        if(eventType==='print'){
            return;
        }
        if (window[eventType] && typeof window[eventType]=='function') {
            window[eventType](this);
            return true;
        }
    }
}

/* ifi */
/* Load Timestamp 13:59:55.624 */
// // if(!top.serverName){
// top.serverName = "pths02";
// // }
//
// // if(!top.idePort){
// //   top.idePort = 13371;
// // }
//
// var devTools = {};
//
// (function () {
//
//     const server = (window.location.protocol + "//" + top.serverName + ":" + top.idePort).toUpperCase();
//     const windows = {};
//     const captions = getCaptionSet("deftools")
//
//     function prepareDom() {
//         if (!GLOBAL.inDeveloperMode || SESSION.activePage.screenType == '*SCH') {
//             return;
//         }
//
//         let placeHolder = SESSION.activeFrame.frameElement.contentDocument.querySelector('.session-user-buttons'),
//             buttons = `
//     <div class="defButtonContainer">
//
//        <div class="session-user-button theme-hover-background-color" >
//           <i class="fa fa-database"  title="${captions.ipmf}" data-event-class="devTools" data-click="openIPMF" ></i>
//        </div>
//        <div class="session-user-button theme-hover-background-color" >
//          <i class="fa fa-link" title="${captions.directLink}" data-event-class="devTools" data-click="createLink" ></i>
//        </div>
//        <div class="session-user-button theme-hover-background-color" >
//          <i class="fas fa-bug" title="${captions.reportBug}" data-event-class="devTools" data-click="showLocation"></i>
//        </div>
//        <div class="session-user-button theme-hover-background-color" >
//          <i class="fas fa-toggle-on" title="${captions.switchCacheOff}" data-event-class="devTools" data-click="toggleCache"></i>
//        </div>
//     `;
//
//         if (top.ifiAvailable) {
//             buttons += `<div class="session-user-button theme-hover-background-color" >
//            <i class="fa fa-code" data-event-class="devTools" data-click="openIfi" ></i>
//         </div>`;
//         }
//         buttons += `</div>`; // close tag defButtonContainer
//         placeHolder.innerHTML = buttons + placeHolder.innerHTML;
//
//         SESSION.activeFrame.frameElement.contentDocument.querySelector("body").setAttribute("data-developer", "true");
//         XDOM.addEventListener(window, 'message', onMessage);
//         updateToggle()
//         subscribe (window.SCOPE.main.mainState.devTools ,updateToggle)
//     }
//
//     function updateToggle() {
//         const {useCache} = window.SCOPE.main.mainState.devTools;
//         const toggle = SCOPE.pageDoc.querySelector('[data-event-class="devTools"][data-click="toggleCache"]')
//         if(!toggle) return;
//         toggle.title = useCache ? captions.switchCacheOff : captions.switchCacheOn;
//         toggle.className = useCache  ? "fas fa-toggle-on" : "fas fa-toggle-off";
//     }
//
//     function onMessage(e) {
//         if (e.origin.toUpperCase() !== server) {
//             return;
//         }
//         if (devTools[e.data]) {
//             devTools[e.data]();
//         }
//     };
//
//     function refresh() {
//         Command.submit();
//     };
//
//     function screenshot() {
//         alert('screenshot op cliboard en ook de stack uitschrijven')
//     }
//
//     function createLink() {
//         SCOPE.main.directLink.startCollecting();
//     }
//
//
//     // function toggleCache(ev) {
//     //     const toggle = ev.event.target;
//     //     //toggle
//     //     SCOPE.main.mainState = !toggle.className.includes('toggle-on');
//     //     update()
//     //     console.log("toggleCache(ev), ", SCOPE.main.mainState);
//     // }
//
//     function showLocation() {
//         OclDefTools.location()
//     }
//
//     function openIPMF() {
//         var uri = '/' + SESSION.stack.currentSession.signOnMethode + '/ndpcgi/'
//             + SESSION.stack.currentSession.jobNr
//             + '/box/ndmctl/debug.ndm/showipmf?PFMJOBID=' + SESSION.stack.currentSession.jobNr
//             + "&AUTHTOKEN=" + SESSION.AUTHTOKEN;
//         window.open(uri, 'popupWindow', 'width=600,height=600,top=0,left=850, title=0, titlebar=0, toolbar=0, menubar=0, location=0, directories=0, status=0, resizable=1, scrollbars=1, alwaysRaised=yes, dependent=yes');
//     };
//
//
//     function update() {
//         let ifiButton = SCOPE.pageDoc.querySelector('[data-click="openIfi"]');
//         if (!ifiButton) {
//             return;
//         }
//         let app = SESSION.stack.currentMacro.application,
//             idlWindow = 'app',
//             macro = SESSION.activePage.macroName;
//
//         if (SESSION.activePage.screenType === '*SCH') {
//             app = 'dbs';
//             idlWindow = 'search';
//         }
//
//         ifiButton.setAttribute("data-app", app);
//         ifiButton.setAttribute("data-macro", macro);
//         ifiButton.setAttribute("data-window", idlWindow);
//
//     }
//
//     function openIfi(ev) {
//         if (!GLOBAL.inDeveloperMode) {
//             return;
//         }
//         let app = ev.invokeObject.dataset.app,
//             macro = ev.invokeObject.dataset.macro,
//             windowName = ev.invokeObject.dataset.window,
//             uri = server + "/client/index.php";
//
//         uri += "?remoteAction=open";
//         uri += "&userName=" + OCULUS.remoteUser;
//         uri += "&groupId=" + PFMBOX.PFMGRPID;
//         uri += "&filId=" + PFMBOX.sPFMFILID;
//         uri += "&app=" + app;
//         uri += "&macro=" + macro;
//         uri += "&origin=" + location.origin;
//         uri += "&dataServer=" + location.href.split('/usr')[0];
//
//         if (windows[windowName] && !windows[windowName].closed) {
//             windows[windowName].location.href = uri;
//         } else {
//             windows[windowName] = window.open(uri);
//         }
//     };
//
//     this.screenshot = screenshot;
//     this.prepareDom = prepareDom;
//     this.update = update;
//     this.openIPMF = openIPMF;
//     this.openIfi = openIfi;
//     this.refresh = refresh;
//     this.createLink = createLink;
//     this.showLocation = showLocation;
//     this.toggleCache = toggleCache;
//     this.update = update
// }).apply(devTools);
//
//
//
//
//
//
//
//
//

/* lines */
/* Load Timestamp 13:59:55.624 */
var Lines = {};
(function() {
    /**
     * voor het conditioneel verberen en weer zichbaar maken van regels
     * een bijna gelijke functionalitijd is te vinden in @see GUI.Lines
     * @type type
     */
    const maxLine = SETTINGS.maxLines + 1;
    let statelessPageId = null;

    /**
     * past regels aan of deze al dan niet zichtbaar zijn binnen een gui scherm (infowindow/edit window)
     * verzameld de juiste regels die verborgen moeten worden
     * @see GUI.update
     * @param {type} pageId als deze is ingevuld wordt er van een stateless pagina uitgegeaan
     * @returns {void}
     */
    function update() {
        const conditionalLines = XDOM.parse(SESSION.activePage.viewProperties.condHiddenLines);
        applyToAllContexts(conditionalLines, SESSION.activeData.headerData);
    }

    /**
     * past regels aan of deze al dan niet zichtbaar zijn binnen een gui scherm (infowindow/edit window)
     * verzameld de juiste regels die verborgen moeten worden
     * een bijna gelijke functionalitijd is te vinden in @see jsfcn/Lines
     * @param {type} GuiPanel
     * @returns {undefined}
     */
    function guiUpdate(GuiPanel) {
        if (!GuiPanel.condHiddenLines) {
            return;
        }
        statelessPageId = GuiPanel.id;
        applyToAllContexts(GuiPanel.condHiddenLines, GuiPanel.data);
        statelessPageId = null;
    }

    /**
     * apply's hidden lines and line offsets as a result of them
     * to all contexts
     * @param {*} conditionalLines
     * @param {*} data
     */
    function applyToAllContexts(conditionalLines, data) {
        const lineContexts = getLinesByContext(conditionalLines, data);
        reset();
        //apply hidden lines to all contexts
        lineContexts.forEach((lines, context) => {
            apply(context, lines);
        });
    }

    /**
     * clusters lines into a map using context as key
     * @param {array of line objects} conditionalLines
     * @param {data} data
     * @returns {map of array of numbers}
     */
    function getLinesByContext(conditionalLines, data) {
        const lineContexts = new Map();
        const envData = SESSION.activeData.environmentConditions || {};

        //collect all lines to be hidden
        //differentiate between contexts
        conditionalLines.forEach(line => {
            const context = line.context || '';
            if (data[line.cond.field] != 1 && envData[line.cond.env]!='true') {
                return;
            }
            if (!lineContexts.has(context)) {
                lineContexts.set(context, []);
            }
            lineContexts.get(context).push(parseInt(line.lineNbr));
        });

        return lineContexts;
    }

    /**
     * loop through the lines
     * update hidden and offset
     * @see GUI.Lines.apply
     * @returns {undefined}
     */
    function apply(context, lines) {
        lines.sort((a, b) => a - b);

        //find first line
        let line = lines[0],
            offset = 0;

        for (; line < maxLine + 1; line++) {
            if (lines.indexOf(line) > -1) {
                //line is hidden
                XDOM.setAttributesToNodeList(queryLines(context, line, false), 'data-hidden-line', 'true');
                //all folowing line's will be offset
                offset++;
                continue;
            }
            //apply the offset
            XDOM.setAttributesToNodeList(queryLines(context, line, true), 'data-y-pos', line - offset);
        }
    }

    /**
     * reset set all lines visible and remove the offset
     * @see GUI.Lines.reset
     * @returns {undefined}
     */
    function reset() {
        var query = '';
        offset = 0;
        if (statelessPageId) {
            query += "[data-stateless-page-id='" + statelessPageId + "']";
        }
        XDOM.setAttributesToNodeList("[data-hidden-line='true']" + query, 'data-hidden-line', 'false');
        XDOM.setAttributesToNodeList('[data-y-pos]' + query, 'data-y-pos', null);
    }

    /**
     * collects all ellements with the same line within the context
     * when private statelessPageId (via guiUpdate)
     * is set context wil be ignored and alle line elements of a stateles page wil be returned
     *
     * @param {string} context can be *main or id of a fieldset
     * @param {number} line
     * @param {boolean} includeFiedset wther or not it will include fieldset tags
     * @returns {NodeList} all ellements with the same line within the context
     */
    function queryLines(context, line, includeFiedset) {
        let query = '';
        const fieldSetSelector = !includeFiedset ? ':not(fieldset)' : '';

        if (statelessPageId) {
            query += `[data-stateless-page-id="${statelessPageId}"].line${line}`;
            return SCOPE.pageDoc.querySelectorAll(query);
        }

        if (context == '*MAIN') {
            query = `#DTADIV > .line${line}${fieldSetSelector}`;
        } else {
            query = `#${context} > div > .line${line}${fieldSetSelector}`;
        }
        return SCOPE.pageDoc.querySelectorAll(query);
    }

    this.guiUpdate = guiUpdate;
    this.update = update;
}.apply(Lines));

/* general */
/* Load Timestamp 13:59:55.625 */
/**
 * controleerd op het bestaan van een variabele
 * @param name variabele naam als string
 * @param windowName optioneel referentie naar window
 * @returns boolean
 */
function isSet(name, windowName) {
    if (name == null || (isNaN(name) && (!name || name == ''))) {
        return;
    } //-->
    var fsName = name.toString();
    var faParts = fsName.split('.');
    fsName = faParts[0];
    for (var l = faParts.length, i = 0; i < l; i++) {
        if (i > 0) {
            fsName += '.' + faParts[i];
        }
        if (!isSetTest(fsName, windowName)) {
            return false;
        }
    }
    return true;
}

/**
 * controleerd op het bestaan van een variabele
 * @param name variabele naam als string
 * @param windowName optioneel referentie naar window
 * @returns boolean
 */
function isSetTest(name, windowName) {
    var fsTEST = 'typeof ' + name + "!='undefined'";
    var foDOC = window;
    if (windowName) {
        foDOC = windowName;
    }
    try {
        if (foDOC.eval(fsTEST)) {
            return true;
        }
    } catch (e) {}
    return false;
}

function hasValue(fo) {
    return !(typeof fo == 'undefined' || fo == null);
}

var blockedKeyCodes = [
    123, //F12
    116, //F5
    112, //F1
    34, //page up
    33, //page down
    8 //backspace
];

var blockedShiftKeyCodes = [
    118, // shift F7
    119, // shift F8
    120, // shift F9
    121 // shift F10
];
var blockedAltKeyCodes = [
    keyCode.k1,
    keyCode.k2,
    keyCode.k3,
    keyCode.k4,
    keyCode.k5,
    keyCode.k6,
    keyCode.k7,
    keyCode.k8,
    keyCode.k9,
    keyCode.home,
    keyCode.f,
    keyCode.a,
    keyCode.h,
    keyCode.q,
    keyCode.p,
    keyCode.w,
    keyCode.m,
    keyCode.n,
    keyCode.s,
    keyCode.arrowLeft,
    keyCode.arrowRight
];

var specialBlockedKeyCodes = new Array();
specialBlockedKeyCodes[8] = {
    rejectedFields: [],
    acceptedFields: ['text', 'password', 'textarea']
};
specialBlockedKeyCodes[33] = {
    rejectedFields: ['textarea'],
    acceptedFields: ['ALL']
};
specialBlockedKeyCodes[34] = {
    rejectedFields: ['textarea'],
    acceptedFields: ['ALL']
};
OCULUS.checkKeyCode = function(e) {
    XDOM.getEvent(e);

    //console.log("KEYCODE: "+e.keyCode + " CHAR CODE: "+GLOBAL.charCode);

    if (GLOBAL.eventObject) {
        if (GLOBAL.eventObject.altKey &&
            (e.keyCode<keyCode.numpad0 && e.keyCode>keyCode.numpad9)
        ) {
            GLOBAL.eventObject.cancel();
            return false;
        }

        if (GLOBAL.eventObject.shiftKey && blockedShiftKeyCodes.indexOf(GLOBAL.charCode) >= 0) {
            GLOBAL.eventObject.cancel();
            return false;
        }

        if (blockedKeyCodes.indexOf(GLOBAL.charCode) >= 0) {
            if (GLOBAL.pressedBlockedKey != GLOBAL.charCode) {
                GLOBAL.pressedBlockedKey = GLOBAL.charCode;
            }

            if (specialBlockedKeyCodes[GLOBAL.charCode]) {
                if (specialBlockedKeyCodes[GLOBAL.charCode].rejectedFields.indexOf(GLOBAL.eventSourceElement.type) >= 0) {
                    GLOBAL.eventObject.cancel();
                    return false;
                }

                if (
                    specialBlockedKeyCodes[GLOBAL.charCode].acceptedFields.indexOf(GLOBAL.eventSourceElement.type) >= 0 ||
                    specialBlockedKeyCodes[GLOBAL.charCode].acceptedFields.indexOf('ALL') >= 0
                    || GLOBAL.eventSourceElement.tagName.indexOf('-') > -1 //webcomponent
                ) {
                    return true;
                }
            }
            GLOBAL.eventObject.cancel();
            return false;
        }
        return true;
    }
    return true;
};

OCULUS.removeKeyCode = function(e) {
    XDOM.cancelEvent();
    GLOBAL.pressedBlockedKey = null;
    return;
};
/**
 * combines two objects
 * @param {object} obj1
 * @param {object} obj2
 */
function merge(obj1, obj2) {
    var newObj = {}
    for (var key in obj1) {
        newObj[key] = obj1[key];
    }
    for (var key in obj2) {
        newObj[key] = obj2[key];
    }
    return newObj;
}

function minVersion(version){
    return (OCULUS.navigatorVersion && OCULUS.navigatorVersion >= version);
}

function getVersion() {
    if (OCULUS.navigatorVersion) {
        return OCULUS.navigatorVersion;
    }
    return '*7A';
}


function isHybrid(){
    return (window.top.pfmSystemType=='hybrid');
}

function userOrDevTitle() {
    if (OCULUS.debugMode) {
        let ret = arguments[0] || ''; //let op arguments is geen array dus gen map of join gebruiken
        for (let i = 1, l = arguments.length; i < l; i++) {
            ret += ' - ' + arguments[i];
        }
        return ret;

        return arguments.join('-');
    }
    return arguments[0] || '';
}

function screenType(){
    return SESSION.activePage.screenType;
}

/* search */
/* Load Timestamp 13:59:55.625 */
/* global SESSION */

/**
 * object voor het vastleggen van zoekscherm instellingen
 * @param {HTMLElement} obj
 * @returns {Search}
 */
function Search(obj) {
    this.programName = obj.getAttribute("data-macro-name");
    this.programLocation = obj.getAttribute("data-macro-location");
    this.field = obj.getAttribute("data-to-id");
    //this.focusField = SESSION.activePage.lastFocusedField;
    this.recordNumber = obj.getAttribute("data-record-number");
    this.additionalParams = obj.getAttribute("data-input-fields");
    this.returnTargetFields = obj.getAttribute("data-return-fields");
    this.clearFields = (obj.dataset.clearFields || '').split(' ');
    this.axis = obj.getAttribute("data-axis");
    this.targetField = this.field;
    this.inSubfile = false;
    this.environmentConditions = obj.dataset.environmentConditions;
    this.paramObjectString = obj.getAttribute('data-parm-object') || ''

    this.dom = {};
    this.targetAxis = null;

    if (this.returnTargetFields) {
        this.returnTargetFields = this.returnTargetFields.split(' ');
    }
    if (this.additionalParams) {
        this.additionalParams = this.additionalParams.split(' ');
    }
    if (this.recordNumber) {
        this.inSubfile = true;
    }
}

Search.currentInstance = null;
Search.services = [];


Search.prototype.init = function () {
};

Search.prototype.close = function (values) {
    AJAX.Page.returnToCaller();
    Service.close(); //indien er nog een service window open is.
    Search.closeSearchFrame();
    Search.currentInstance = null;
    var fieldObj = null;
    var focusObj = null;

    if (values) {
        if (this.setReturnValues(values)) {
            if (isAutoSubmitField(this.field)) {
                Command.enter();
                return;
            }
        }
    }
    Trigger.fire(this.returnTargetFields.concat(this.clearFields));
    XDOM.setOldvalue(this.clearFields);
    fieldObj = XDOM.getObject(this.field);

    if (Mask.isMask(fieldObj)) {
        focusObj = fieldObj.getAttribute("data-last-selected-part");
        if (focusObj) {
            XDOM.focus(focusObj);
        }
    } else {
        XDOM.focus(this.field);
    }
};


Search.prototype.setReturnValues = function (values) {
    var fsReturnField = '';
    var fsRetValue = '';
    var foReturnObject = null;

    if (this.recordNumber) {
        this.adaptreturnTargetFields();
    }
    //clear values if any
    XDOM.clearFields(this.clearFields);
    if (!values) {
        return false;
    } // -->
    for (var i = 0, l = this.returnTargetFields.length; i < l; i++) {
        fsReturnField = this.returnTargetFields[i];
        fsRetValue = unescape(values[i]);
        foReturnObject = XDOM.getObject(fsReturnField);

        Subfile.setChanged(this.recordNumber);
        XDOM.setObjectValue(foReturnObject, fsRetValue);
    }
    resetMessage();
    return true;
};

Search.prototype.adaptreturnTargetFields = function () {
    var fsRetParam = '';
    var faRetArray = [];
    for (var i = 0, l = this.returnTargetFields.length; i < l; i++) {
        fsRetParam = this.returnTargetFields[i];
        fsRetParam += '_' + this.recordNumber;
        faRetArray[i] = fsRetParam;
    }
    this.returnTargetFields = faRetArray;
};

Search.prototype.registerSFLEvents = function () {
};

// ***************************************************************************
// Bouwt een parameterstring op obv de opgegeven velden
// parms: fPARMS=array van reeks van velden
// return: opgebouwde parm string
// ***************************************************************************
Search.prototype.buildSflParameterString = function (fPRMAR, fUSEID) {
    var fsAxis = '';
    var fsValue = '';
    var fsRequestUri = '';
    var foField = null;
    for (var i = 0, l = this.additionalParams.length; i < l; i++) {
        fsAxis = this.additionalParams[i];
        fiParam = i + 1;
        foField = XDOM.getAxis(fsAxis, this.recordNumber);
        if (!foField) {
            foField = XDOM.getObject(fsAxis);
        }
        if (!Validate.test(foField)) {
            return 'invalid';
        }
        fsValue = XDOM.getObjectValue(foField);

        fsRequestUri += '\'' + encodeURIComponent(fsValue.toUpperCase()) + '\'';
        if (i < l - 1) {
            fsRequestUri += ' ';
        }
    }
    return fsRequestUri;
};

/**
 * Opent het zoek venster
 *
 * @returns
 */

Search.openDelayed = function () {
    var foSearch = Search.currentInstance;
    Search.currentInstance = null; // in verband met onterecht blokeren van open
    foSearch.open();
};


Search.prototype.open = function () {
    var params = '', url = '';
    //if(Mask.isMask(GLOBAL.keydownObject)) {
    if (Mask.isMask(GLOBAL.eventSourceElement)) {
        Mask.returnValues(GLOBAL.keydownObject);
    }

    if (SESSION.submitInProgress) {
        return;
    }

    //SESSION.submitInProgress = true;

    if (Search.currentInstance) {
        return;
    }
    Search.currentInstance = this;

    if (SESSION.submitInProgress) {
        setTimeout(Search.openDelayed, 20);
        XDOM.cancelEvent();
        return true;
    }

    KeepAlive.cancel(); // stopt de keep alive job om dubbele requests te voorkomen
    QuickSearch.cancelDelayedOpen();

    if (this.inSubfile) {
        params = this.buildSflParameterString();
    } else {
        params = buildParamterString(this.additionalParams);
    }

    let paramsFromRequestObject = this.ParametersFromRequestObject();


    if (params == 'invalid' && paramsFromRequestObject == 'invalid') {
        Search.currentInstance = null;
        return;
    }

    if(params == 'invalid'){
        params = '';
    }
    if(paramsFromRequestObject !== 'invalid'){
        params += paramsFromRequestObject;
    }


    SESSION.submitInProgress = true;

    SESSION.activePage.serviceIsActive = true; // Service Function activated

    closeAllModalObjects();


    if (!PFMVAR['*SCH']) {
        PFMVAR['*SCH'] = {};
    }
    Search.searchBlocker(true);
    protectPage();
    url = SESSION.alias + '/' + this.programLocation
        + '/ndmctl/' + this.programName
        + '.ndm/main?PFMJOBID=' + SESSION.jobId
        + '&mProgramParms=' + params
        + "&AUTHTOKEN=" + SESSION.AUTHTOKEN
        + "&RequirePageDef=" +!SESSION.session.debugMode;


    if (this.environmentConditions) {
        url += '&EnvConditions=' + encodeURIComponent(this.environmentConditions);
    }


    SESSION.submitFromScope = 'MAIN';
    MAIN.NAV.Session.currentInstance.checkStatus();
    AJAX.Page.setCallerCaller(SESSION.activePage.macroProperties.cacheKey);
    AJAX.get(url, AJAX.handleResponse);
    return false;
};

Search.prototype.getURL = function () {
    return SESSION.alias + '/' + this.programLocation
        + '/ndmctl/' + this.programName
        + '.ndm/main?PFMJOBID=' + SESSION.jobId;
};

Search.closeSearchFrame = function () {
    SESSION.activePage.serviceIsActive = false; // Service Function deactivated
    if (PFMVAR['*SCH']) {
        PFMVAR['*SCH'] = null;
    }

    //AJAX.Page.returnToCaller();
    //showScreen();
    showFrame(SESSION.activePage.screenType);
    setFrames('*PGM');
    Search.searchBlocker(false);
    //XDOM.getObject('mRT_SCH').value = 'true';
    setTitle();
};

/**
 * Sluit het zoek venster Als op het ontvangende veld een AUTOSBM is gedefinieerd dan wordt deze uitgevoerd.
 *
 * @param values
 *          waarde van een eventueel gekozen sleutel
 * @param returnFields
 *          veld waarin de waarde terecht moet komen
 * @param toId
 *          veld waarop de focus terecht moet komen
 * @returns {void}
 */
Search.close = function (values, returnFields, toId) {
    if (Search.currentInstance) {
        Search.currentInstance.close(values);
    }

    return;
};


function buildParamterString() {
    // ***************************************************************************
    // Bouwt een parameterstring op obv de opgegeven velden
    // parms: fPARMS=array van reeks van velden
    // return: opgebouwde parm string
    // ***************************************************************************
    var parmArray = arguments[0];

    if (!parmArray) {
        return;
    }
    var arrayLength = parmArray.length;
    var parmString = '';

    for (var a = 0; a < arrayLength; a++) {
        var parmName = parmArray[a];
        var parmNumber = a + 1;
        if (parmName.indexOf('\'') == -1) {
            var parmObject = XDOM.getObject(parmName.trim());
            if (!parmObject) {
                // SCOPE.main.Dialogue.alert(gSCH001 + parmName + gSCH002);
                return 'invalid';
                break;
            }
            if (!Validate.test(parmObject)) {
                return 'invalid';
            }

            var parmValue = XDOM.getObjectValue(parmObject).trim();

            parmString += '\'' + encodeURIComponent(parmValue.toUpperCase()) + '\'';
        } else {
            parmString += parmName;
        }
        if (a < arrayLength - 1) {
            parmString += ' ';
        }
    }
    return parmString;
}

Search.handleOnClick = function () {
    var oSearch = new Search(GLOBAL.eventSourceElement);
    oSearch.open();
    return true;
};

Search.handleHeadingClick = function () {
    var thCell = null;
    var serviceId = null;
    var serviceObject = null;

    //check of er op een columnheading TH is geklikt
    thCell = XDOM.getParentByTagName(GLOBAL.eventSourceElement, "TH");

    if (!thCell) {
        return false;
    }

    serviceId = thCell.getAttribute("data-search-click-id");
    if (!serviceId) {
        return false;
    }

    serviceObject = XDOM.getObject(serviceId);
    if (!serviceObject) {
        return false;
    }

    if (serviceObject.getAttribute("data-when") === "unavailable") {
        return false;
    }

    if (serviceObject.getAttribute("data-quicksearch-id")) {
        //it's a quicksearch so invoke click on this one
        serviceObject.click();
        return false;
    }

    XDOM.cancelEvent();
    var oSearch = new Search(serviceObject);
    oSearch.open();
    return true;
};


Search.searchBlocker = function (fbBlock) {
    var foBlocker = XDOM.getObject('searchBlocker');

    if (foBlocker) {
        if (fbBlock) {
            foBlocker.setAttribute("data-blocker", "on");

            //XDOM.classNameReplaceOrAdd(foBlocker,"inactive", "active");
        } else {
            foBlocker.setAttribute("data-blocker", "off");
            //XDOM.classNameReplaceOrAdd(foBlocker,"active", "inactive");
        }
    }
};


/**
 * @returns {string} url|"invalid"
 */
Search.prototype.ParametersFromRequestObject = function () {
    if(!this.paramObjectString){return;}
    let requestFields;
    let recordNumber = parseInt(this.recordNumber);
    let sflIndex = recordNumber - 1; //array base 0 en record number base 1,
    let requestPrefix = '';

    try {
        let paramObjectString = this.paramObjectString.replace(/'/g, '"');
        requestFields = JSON.parse(paramObjectString);
    } catch (e) {
        alert(`malformed : ${paramObjectString})} object for search ${this.programName}`);
        return '';
    }



    if (requestFields.length === 0) {
        return '';
    }
    let url = '&PRMLEN=' + requestFields.length + '&';
    let valid = true;

    url += requestFields.map((param, index) => {
        let {field, location} = param;
        let urlPart = `PRM${index + 1}=`;
        let obj = XDOM.getObject(requestPrefix + field) ||
            XDOM.getObject('trigger_' + requestPrefix + field) || //trigger field
            XDOM.getObject(field + '_' + recordNumber) //subfile field

        //input or trigger generated fields
        if (obj && obj.tagName === 'INPUT') {
            if (!Validate.test(obj)) {
                valid = false
            }
            return urlPart + encodeURIComponent(obj.value);
        }
        switch (location) {
            case 'headerData':
                return urlPart + encodeURIComponent(
                    SESSION.activePage.headerData[field]
                );
            case 'subfileData':

                if (recordNumber <= 0) {
                    return ''
                }
                ;
                obj = XDOM.getObject(field + '_' + recordNumber);
                if (obj && obj.tagName !== 'INPUT') {
                    if (!Validate.test(obj)) {
                        valid = false
                    }
                    return urlPart + encodeURIComponent(obj.value);
                }

                return urlPart + encodeURIComponent(SESSION.activePage.subfileData[sflIndex][field]);
            default:
                if (obj && obj.dataset.constValue) {
                    return urlPart + obj.dataset.constValue;
                }
        }
    }).join('&');
    if (!valid) {
        return 'invalid';
    }
    return url
}
/* topView */
/* Load Timestamp 13:59:55.626 */
/**
 * object voor het vastleggen van promptScherm instellingen
 * @param {HTMLElement} obj
 * @returns {TopView}
 */

function TopView(obj) {
    const paramObject = (obj.dataset.parmObject || '').replace(/\'/g, '"') || '{}';
    this.programName = obj.getAttribute('data-macro-name');
    this.programLocation = obj.getAttribute('data-macro-location');
    this.field = obj.getAttribute('data-to-id');
    this.targetField = this.field;
    this.titleFromTarget = obj.title;
    this.returnTargetFields = obj.getAttribute('data-return-fields') || '';
    this.recordNumber = obj.getAttribute('data-record-number');
    this.parmFields = obj.getAttribute('data-topview-parm-fields');
    this.parmNames = obj.getAttribute('data-topview-parm-names');
    this.environmentConditions  = obj.getAttribute('data-environment-conditions');
    this.requestFieldsArray = JSON.parse(paramObject);
    this.axis = obj.getAttribute('data-axis');
    this.clearFields = (obj.dataset.clearFields || '').split(' ');
    this.inSubfile = false;
    this.dom = {};


    if (this.returnTargetFields) {
        this.returnTargetFields = this.returnTargetFields.split(' ');
    }

    if (this.parmFields) {
        this.parmFields = this.parmFields.split(' ');
    }

    if (this.parmNames) {
        this.parmNames = this.parmNames.split(' ');
    }
}

TopView.currentInstance = null;
TopView.prototype.init = function() {};

TopView.prototype.getToIDField = function() {
    let field = XDOM.getObject(this.field);
    if(!field) {
        //field could be defined as subfile field but should be header field
        const headerField = this.field.replace(`_${this.recordNumber}`, '');
        field = XDOM.getObject(headerField);
    }
    return field;

}


TopView.prototype.close = function(returnValues = this.getReturnValues(), close = false) {
    let focusObj = null;
    let autoClose = SESSION.activePage.viewProperties.autoClose == 'true';

    SESSION.isSingleView = false;
    TopView.currentInstance = null;

    AJAX.Page.returnToCaller();
    TopView.closeTopViewFrame();

    let fieldObj =  this.getToIDField()

    if (autoClose || close) {
        const returnDomFields = this.setReturnValues(returnValues);
        if (hasAutoSubmitFields([...returnDomFields, fieldObj])) {
            Command.enter();
            return;
        }
        Trigger.fire(this.returnTargetFields.concat(this.clearFields));
        XDOM.setOldvalue(this.clearFields);
    }

    fieldObj = XDOM.getObject(fieldObj);

    if (Mask.isMask(fieldObj)) {
        focusObj = fieldObj.getAttribute('data-last-selected-part');
        if (focusObj) {
            XDOM.focus(focusObj);
        }
    } else {
        XDOM.focus(fieldObj);
    }
};

TopView.prototype.getReturnValues = function() {

    if (!SESSION.activePage.returnToCaller || !SESSION.activePage.data.headerData) {
        return; //==>>
    }

    //fieldNames in topView frame
    let returnFields = SESSION.activePage.returnToCaller;
    //fieldValues in topView frame
    let returnValues = SESSION.activePage.data.headerData;
    //returnFields in caller macro frame
    let targetFields = this.returnTargetFields;
    //return array with fields and values
    let returnFieldsArray = Array();

    //temporarily vars
    let fsValue = null;
    let fsField = null;

    //check if targetfields are definied
    if(!targetFields){
        return [];
    }

    for (var i = 0, l = returnFields.length; i < l; i++) {
        //check if value exists in response
        if ((fsValue = returnValues[returnFields[i]])) {
            //check if target field exists
            if ((fsField = targetFields[i])) {
                //update return array
                returnFieldsArray[i] = {
                    targetObject: fsField,
                    targetValue: fsValue
                };
            }
        }
    }

    return returnFieldsArray;
};

TopView.prototype.setReturnValues = function(returnParams) {
    var returnArray = returnParams;
    var targetObject = null;
    var targetValue = null;

    var changedFields = [];

    //if(this.recordNumber){
    //  this.adaptreturnTargetFields();
    //}

    if (!returnParams) {
        return changedFields;
    } // -->

    for (var i = 0, l = returnArray.length; i < l; i++) {
        targetObject = XDOM.getObject(returnArray[i].targetObject);
        targetValue = returnArray[i].targetValue;
        //Subfile.setChanged(this.recordNumber);

        if (targetObject && targetValue) {
            XDOM.setObjectValue(targetObject, targetValue);
            changedFields.push(targetObject)
        }
    }
    //clear values if any
    XDOM.clearFields(this.clearFields);
    resetMessage();
    return changedFields;
};

TopView.prototype.paramStringPart = function(field, index) {
    let fieldName = field.field,
        trigerFieldName = 'trigger_' + fieldName,
        recordCursor = parseInt(this.recordNumber) - 1,
        fieldObject = XDOM.getObject(fieldName) || XDOM.getObject(trigerFieldName),
        fieldValue = XDOM.getObjectValue(fieldObject),
        ret = 'parmValue' + (index + 1) + '=';

    if (fieldObject && !Validate.test(fieldObject)) {
        throw new Error('validation');
    }
    switch (field.location) {
        case 'headerData':
            fieldValue = fieldValue || SESSION.activeData.headerData[field.field];
            break;
        case 'subfileData':
            fieldName = field.field + '_' + this.recordNumber;
            trigerFieldName = trigerFieldName + '_' + this.recordNumber;
            (fieldObject = XDOM.getObject(fieldName) || XDOM.getObject(trigerFieldName)),
                (fieldValue = XDOM.getObjectValue(fieldObject) || SESSION.activeData.subfileData[recordCursor][field.field]);
            break;
        case 'directValue':
            dataValue = field.value;
            break;
        default:
            //comst value
            fieldValue = fieldObject.getAttribute('data-const-value');
    }

    return ret + encodeURIComponent(fieldValue);
};

TopView.prototype.buildNewParameterString = function() {
    if (!this.parmFields || this.parmFields.length == 0) {
        return;
    }

    let request =
        '&parmLength=' +
        this.parmFields.length +
        '&' +
        this.parmNames.map((value, index) => 'parmName' + (index + 1) + '=' + value).join('&') +
        '&' +
        this.requestFieldsArray.map((value, index) => this.paramStringPart(value, index)).join('&');
    return request;
};

TopView.prototype.buildParameterString = function() {
    if (this.requestFieldsArray) {
        return this.buildNewParameterString();
    }
    var parmFields = this.parmFields || null;
    var parmNames = this.parmNames || null;
    var parmObject = null;
    var parmObjName = null;
    var parmName = null;
    var parmValue = null;
    var parmLength = 0;
    var parmNumber = 0;
    var parmString = '';

    if (parmFields && parmFields.length > 0) {
        parmLength = parmFields.length;

        parmString += '&parmLength=' + parmLength;

        for (var count = 0, totalCount = parmFields.length; count < totalCount; count++) {
            if (parmFields[count]) {
                parmObjName = parmFields[count].trim();
            }

            if (parmNames[count]) {
                parmName = parmNames[count].trim();
            }

            parmNumber = count + 1;
            parmObject = XDOM.getObject(parmObjName);

            if (!parmObject) {
                SCOPE.main.Dialogue.alert(getCapt('gSCH001') + parmName + getCapt('gSCH002'));
                throw new Error('invalid');
                break;
            }
            if (!Validate.test(parmObject)) {
                throw new Error('invalid');
            }

            parmValue = XDOM.getObjectValue(parmObject).trim();

            if (count > 0) {
                parmString += '&';
            }

            parmString += '&parmName' + parmNumber + '=' + parmName + '&parmValue' + parmNumber + '=' + parmValue;
        }
    }

    return parmString;
};


/**
 * Opent het zoek venster
 *
 * @returns
 */

TopView.openDelayed = function() {
    var foTopView = TopView.currentInstance;

    TopView.currentInstance = null;
    foTopView.open();
};

TopView.prototype.open = function() {
    var params = '', url = '';

    if (Mask.isMask(GLOBAL.eventSourceElement)) {
        Mask.returnValues(GLOBAL.keydownObject);
    }

    if (SESSION.submitInProgress) {
        return;
    }

    if (TopView.currentInstance) {
        return;
    }
    TopView.currentInstance = this;

    if (SESSION.submitInProgress) {
        setTimeout(TopView.openDelayed, 20);
        XDOM.cancelEvent();
        return true;
    }

    KeepAlive.cancel(); // stopt de keep alive job om dubbele requests te voorkomen
    QuickSearch.cancelDelayedOpen();

    try {
        params = this.buildParameterString() || '';
    } catch (e) {
        TopView.currentInstance = null;
        return;
    }

    SESSION.submitInProgress = true;

    SESSION.activePage.serviceIsActive = true; // Service Function activated

    closeAllModalObjects();

    if (!PFMVAR['*TOPVIEW']) {
        PFMVAR['*TOPVIEW'] = {};
    }

    protectPage();

    url =
        SESSION.alias +
        '/' +
        this.programLocation +
        '/ndmctl/' +
        this.programName +
        '.ndm/main?PFMJOBID=' +
        SESSION.jobId +
        params;

    // wizard
    if(GLOBAL.eventSourceElement.dataset.eventClass === 'Wizard'){
        url += '&InitWizard=true&Wizard=true&wizardCode=' + GLOBAL.eventSourceElement.dataset.wizardName;
    }else{ //normal topview
        url += '&TopView=true';
    }

    if(this.environmentConditions){
        url +=  '&EnvConditions='+ encodeURIComponent(this.environmentConditions) ;
    }

    MAIN.NAV.Session.currentInstance.checkStatus();
    AJAX.Page.setCallerCaller(SESSION.activePage.macroProperties.cacheKey);
    SESSION.isSingleView = true;
    AJAX.get(url, AJAX.handleResponse);

    return false;
};

TopView.prototype.getURL = function() {
    return (
        SESSION.alias + '/' + this.programLocation + '/ndmctl/' + this.programName + '.ndm/main?PFMJOBID=' + SESSION.jobId
    );
};

TopView.addNavigationToFrame = function(screenType) {
    if (!SESSION.isSingleView) {
        return;
    }

    var TopViewScreen = SESSION.activeFrame.document.getElementsByTagName('body')[0];
    var exitBtn = XDOM.createElement('div', 'CANCEL', 'btn28px floatRight');

    TopViewScreen.setAttribute('data-topView-obj', 'true'); //voor css selectors

    exitBtn.setAttribute('data-title-origin', '*LBL');
    exitBtn.setAttribute('data-title-variable', 'cCANCEL_TTL');
    exitBtn.setAttribute('data-wscmd-type', '*CNL');

    if (screenType !== '*SCH') {
        exitBtn.setAttribute('data-screen-type', '*TOPVIEW');
    }

    TopViewScreen.appendChild(exitBtn);
};

TopView.closeTopViewFrame = function() {
    SESSION.activePage.serviceIsActive = false; // Service Function deactivated
    if (PFMVAR['*TOPVIEW']) {
        PFMVAR['*TOPVIEW'] = null;
    }
    showFrame(SESSION.activePage.screenType);
    setFrames('*PGM');
    TopView.topViewBlocker(false);
    SESSION.isSingleView = false;
    SESSION.subScope = null;
    setTitle();
};

/**
 * Sluit het zoek venster Als op het ontvangende veld een AUTOSBM is gedefinieerd dan wordt deze uitgevoerd.
 *
 * @param values
 *          waarde van een eventueel gekozen sleutel
 * @param returnFields
 *          veld waarin de waarde terecht moet komen
 * @param toId
 *          veld waarop de focus terecht moet komen
 * @returns {void}
 */
TopView.close = function(values) {

    // Close all 'singleView' (lol) windows
    window.SCOPE.main.Dialogue.deleteModalGroup(['singleView']);

    let returnValues;

    returnValues = values;

    if (TopView.currentInstance) {
        TopView.currentInstance.close(returnValues);
    }
    Wizard.close();
};

TopView.handleOnClick = function() {
    var foTopView = new TopView(GLOBAL.eventSourceElement);
    foTopView.open();
    return true;
};

TopView.topViewBlocker = function(fbBlock) {
    var foBlocker = XDOM.getObject('topViewBlocker');

    if (foBlocker) {
        if (fbBlock) {
            foBlocker.setAttribute('data-blocker', 'on');
        } else {
            foBlocker.setAttribute('data-blocker', 'off');
        }
    }
};

/**
 * Iterates over all dom elements in scope, having data-macro-desc as an attribute and sets the title accordingly.
 */
TopView.prepareDom = function() {
    //query the relevant dom objects destructure in an array
    const topViewIcons = [...XDOM.queryAll('[data-macro-desc]')];

    //iterate over all elements
    topViewIcons.forEach(icon=>{
        if(!icon.dataset.macroDesc) return;
        //set the title
        icon.title = icon.dataset.macroDesc;
    })
};
/* image */
/* Load Timestamp 13:59:55.627 */
oculusImage =  {}
oculusImage.prepareDom = function(){
    var Objects = XDOM.queryAllScope("[data-datatype='*IMG']");
    for(var i=0,l=Objects.length;i<l;i++){
        oculusImage.setDimentions(Objects[i]);
    }
};

oculusImage.update = function(){}

oculusImage.setObjValue = function(obj,value){

    obj.innerHTML='';
    if(!value){
        return;
    }
    var imageObject =  new Image();

    imageObject.id = obj.id +"_IMG";

    imageObject.setAttribute("data-click-action","oculusImage.expand");
    obj.appendChild(imageObject);
    XDOM.addEventListener(imageObject, 'error', oculusImage.onError);
    imageObject.src = value;
}

oculusImage.setDimentions= function(obj){
    var xPos = obj.getAttribute("data-element-xpos");
    var yPos = obj.getAttribute("data-element-ypos");
    var width = obj.getAttribute("data-element-xsize");
    var height = obj.getAttribute("data-element-ysize");
    var newHeight = obj.getAttribute("data-element-lines");

    if(!xPos){
        return;
    }

    if(yPos)      {   obj.className += ' ypos'+yPos;                   }
    if(xPos)      {   obj.className += ' xpos'+int2css(xPos, 3);       }
    if(width)     {   obj.className	+= ' xsize'+int2css(width, 2);     }
    if(height)    {   obj.className	+= ' ysize'+int2css(height, 2);    }
    if(newHeight) {   obj.className	+= ' lines'+int2css(newHeight, 2); }
};

oculusImage.onError = function(e){
    XDOM.getEvent(e);
    var imgDiv = GLOBAL.eventSourceElement.parentNode;
    if(imgDiv){
        imgDiv.innerHTML=getCapt('gIMGNOTAVAIL');
    }
};


oculusImage.expand = function(){


    var sourceImage = GLOBAL.eventSourceElement;
    if(!sourceImage.src){
        return false;
    }


    var dataDiv = XDOM.getObject("DTADIV");
    var overlay = XDOM.createElement("DIV","whiteOverlay",null);
    dataDiv.appendChild(overlay);


    var thisImage = XDOM.createElement("img", sourceImage.id, 'draggable' );
    thisImage.src = sourceImage.src;
    thisImage.setAttribute("data-mouseDown-action", "Dragger.start");
    thisImage.setAttribute("data-dragger-objId", "imgViewer");

    thisImage.onload = function(){
        var imgTop  = (dataDiv.clientHeight - thisImage.height) *0.5;
        var imgLeft = (dataDiv.clientWidth - thisImage.width) *0.5;

        // Position wrapper (flashes on Chrome)
        imgWrapper.style.left = imgLeft + 'px';
        imgWrapper.style.top = imgTop + 'px';

        thisImage.setAttribute('style', "opacity: 1;");
        overlay.setAttribute('style', "opacity: 1;");
    };
    var imgWrapper = XDOM.createElement("DIV","imgViewer","imgViewer");
    imgWrapper.setAttribute('draggable', "true");
    imgWrapper.setAttribute("data-mouseDown-action", "Dragger.start");

    // CSS
    imgWrapper.style.opacity = 0;
    imgWrapper.style.transition = 'opacity .5s ease-in';

    var imgCloseBtn = XDOM.createElement("DIV",null,"pth-close closeImagePopup");
    imgWrapper.appendChild(thisImage);
    imgWrapper.appendChild(imgCloseBtn);

    overlay.setAttribute("data-click-action","closeHighSlide")
    imgCloseBtn.setAttribute("data-click-action","closeHighSlide")

    dataDiv.appendChild(imgWrapper);

    // HACKING!!!!!! YAY
    setTimeout(()=> {
        // Set opacity to 1
        imgWrapper.style.opacity = 1;
    }, 1);

    //Dragger.dragDrop.initElement(imgWrapper);

};
/* message */
/* Load Timestamp 13:59:55.627 */
/**
 * class voor 1 losse thread van messages
 * @returns
 */
function MessageThread(){
    this.initialMessage=false;
    this.lastMessage=false;
    this.autoExit = false;
    this.hasErrors = false;
    this.threadNumber = 0;
}

/**
 * message controler
 * @returns
 */
function Messages(){
    this.threads=new Array();
    this.currentThread= null;
    this.timeOutPointer = null;
    this.popUpDomObject = null;
    this.resultable = null;
    this.scrollValue = 0;
    this.exitMessage = '';
    this.exitCode = null;
}

Messages.update = function(){
    Messages.closeWindow();
    Messages.reopen();
};

/**
 * enum van returncodes
 */
Messages.returnCode = {
    'initialMessage':'IM',
    'message':'MG',
    'noMessage':'',
    'notFound':'NF',
    'lastMessage':'LM',
    'error':'ER',
    'ok':'OK'
};


/**
 * static aanmaken van nieuwe thread
 */
Messages.newThread = function(command){
    if (command == 'ACCEPT' && SESSION.activePage.messageQueue == '*EXC') {
        var foMessage = Messages.currentInstance;
        var msgThread = new MessageThread();
        foMessage.threads.push(msgThread);

        msgThread.threadNumber = foMessage.threads.length;

        if(!foMessage.currentThread){
            foMessage.currentThread = foMessage.threads.shift();
            foMessage.timeOutPointer = setTimeout("Messages.requestMessage()", 100);
        }
    }
};

/**
 * static aanvragen van nieuwe message
 * @returns {Boolean}
 */
Messages.requestMessage = function() {

    // ***************************************************************************
    // Aanroep van het programma dat kijkt of er een bericht is.
    // parms:  tDELAY=eventueel met een vertraging uitvoeren om de server te
    //         ontlasten.
    // return: --
    // ***************************************************************************
    var fdDATE=new Date();
    var ftTMSTM=fdDATE.getTime();
    var fsDIRPT=OCULUS.monitorJobCGI
        + "/box/ndmctl/rcvnetmsg.ndm/NetMessage.xml?gCD_LNG=" + SESSION.language
        + "&JOBNR="    + SESSION.jobId
        + "&JOBKEY="   + PFMBOX.JOBKEY
        + "&PFMFILID=" + PFMBOX.gCD_ENV
        + "&AUTHTOKEN="+ SESSION.AUTHTOKEN
        + "&TMSTM="    + ftTMSTM;
    advAJAX.get({
        url : fsDIRPT,
        tag : {},
        onSuccess : function(obj) { Messages.handleResponse(obj);}
    });
    return true;
};



Messages.closeWindow = function(){
    var foMessage = Messages.currentInstance;
    if(foMessage.popUpDomObject && !foMessage.currentThread){
        Messages.close();
    }
};

/**
 * static als de pagina wordt herladen en er worden nog berichten opgehaald dan wordt
 * het venster met de vorige berichten door middel van deze functie weer getoond
 */
Messages.reopen = function(){
    var foMessage = Messages.currentInstance;
    if(!foMessage.popUpDomObject){
        return; //-->
    }

    if(foMessage.currentThread){
        if(foMessage.currentThread.hasErrors){
            setMessage( foMessage.currentThread.returnCode, foMessage.currentThread.messageText);
            var cmdDiv = XDOM.getObject("CMDDIV");
            cmdDiv.className = "STS_E";
        }
    }


//  var foMAIN=XDOM.getObject('messageWrapper');
//  foMAIN.appendChild(foMessage.popUpDomObject);
//  foMessage.timeOutPointer = setTimeout("Messages.requestMessage()", 100);
};

/**
 * static handeld andwoordt van de server af
 * @param obj
 */
Messages.handleResponse = function(obj){
    Messages.currentInstance.handleResponse(obj);
};

/**
 * static sluit het berichten scherm mits er geen berichten meer worden opgehaald
 * deze functie wordt aan het einde van elke thread bij een "last Message" (LM) aangeroepen. als er echter tussentijds
 */
Messages.close = function(){

    var foMessage = Messages.currentInstance;
    var foMAIN=XDOM.getObject('messageWrapper');
    foMAIN.className = 'hidden';

    setMessage( foMessage.exitCode, foMessage.exitMessage);
    foMessage.exitMessage = '';
    foMessage.exitCode = '';

    if(!foMessage.currentThread ){ //er is nog een nieuwe thread die berichten moet tonen er kan dus niet gesloten worden
        XDOM.removeDOMObject(foMessage.popUpDomObject);
        foMessage.popUpDomObject = null;
    }

    setCursor();

    return;
};

/**
 * static placeholder voor huidige controler
 */
Messages.currentInstance = new Messages();
// ***************************************************************************
// Afhandeling van het antwoord van de server als er een bericht is
// parms:  fOBJ=Ajax request object
// return: --
// Als er een bericht is en deze begint niet met code NF dan wordt er een
// popup JOBMSG getoond. Vervolgens wordt er een nieuwe aanvraag gedaan met
// kleine vertraging. Bij elk antwoord met code NF wordt de vertraging groter
// om de server te ontlasten.
// Als antwoord OK dan wordt de popup na .. tijd gesloten.
// ***************************************************************************
Messages.prototype.handleResponse = function(obj) {

    if(!this.currentThread) { return; } //-->
    var xmlDoc = XDOM.getXML(obj.responseText);
    this.currentThread.returnCode 	= xmlDoc.getElementsByTagName("returnCode")[0].childNodes[0].nodeValue;
    this.currentThread.autoExitCode = xmlDoc.getElementsByTagName("userExit")[0].childNodes[0].nodeValue;

    switch(this.currentThread.returnCode){

        case Messages.returnCode.initialMessage:
            this.currentThread.initialMessage = true;
            this.timeOutPointer = setTimeout("Messages.requestMessage()", 250);
            break;

        case Messages.returnCode.noMessage:
        case Messages.returnCode.notFound:
            this.timeOutPointer = setTimeout("Messages.requestMessage()", 250);
            break;

        case Messages.returnCode.lastMessage:
            if(!this.currentThread.initialMessage){
                //oude last message deze negeren dit zou niet voor mogen komen;
                this.timeOutPointer = setTimeout("Messages.requestMessage()", 250);
                return;
            }

            this.closeThread();
            break;
        case Messages.returnCode.error:
            this.currentThread.hasErrors = true;
            this.currentThread.autoExit=(this.currentThread.autoExitCode != 'U');
            this.displayMessage(obj);
            setMessage( this.currentThread.returnCode, this.currentThread.messageText);
            var cmdDiv = XDOM.getObject("CMDDIV");
            cmdDiv.className = "STS_E";

            this.timeOutPointer = setTimeout("Messages.requestMessage()", 500);
            break;
        case Messages.returnCode.ok:
            this.currentThread.autoExit=(this.currentThread.autoExitCode !='U');
            this.displayMessage(obj);
            this.timeOutPointer = setTimeout("Messages.requestMessage()", 500);
            break;
        case Messages.returnCode.message:
            this.displayMessage(obj);
            this.timeOutPointer = setTimeout("Messages.requestMessage()", 50);
            break;
    }
};

/**
 * sluit huidige messageThread
 */
Messages.prototype.closeThread = function(){
    this.currentThread.lastMessage=true;
    if(this.currentThread.hasErrors){
        this.exitCode = 'F';
    }

    if(this.currentThread.autoExit){
        setTimeout("Messages.close()",2000);
    }

    this.currentThread = this.threads.shift();
    if(!this.currentThread){
        clearTimeout(this.timeOutPointer);
    }else{
        this.timeOutPointer = setTimeout("Messages.requestMessage()", 100);
    }
    return;
};

/**
 * renderen van de popup van het boodschappenscherm
 * @param obj
 */
Messages.prototype.renderPopup = function(obj){
    if(this.popUpDomObject){return;} //-->

    var foMAIN=XDOM.getObject('messageWrapper');

    foMAIN.className = '';

    this.popUpDomObject=XDOM.createElement('div','JOBMSG');
    this.popUpDomObject.setAttribute("data-click-action", "Messages.close");

    foMAIN.appendChild(this.popUpDomObject);
    positionDiv(this.popUpDomObject);

    var fiBRWDIM=getBrowserDim();
    var fiWDT=this.popUpDomObject.offsetWidth;
    this.popUpDomObject.style.left=(fiBRWDIM.BRWWDT/2)-(fiWDT/2)+'px';
    this.popUpDomObject.style.left = "0px";
    this.popUpDomObject.innerHTML='<div class="popTitle theme-background-color">' +  getCapt('gUSER') + ': '+  PFMBOX.PFMRMTUS
        +' -' + getCapt('gJOB') + ': '+SESSION.jobId+' <div id="closeMsgBtn" class="MEXIT popup-close pth-icon"></div> </div>'
        +'<div id="JOBMSGDIV">'
        +'<table id="JOBMSGTBL">'
        +'<colgroup><col id="COL1" class="xsize03" /><col id="COL2"  /></colgroup></table></div>';

    this.resultable =XDOM.getObject('JOBMSGTBL');

    var closeBtn = XDOM.getObject('closeMsgBtn');
    closeBtn.setAttribute("data-click-action", "Messages.close");
};

function positionDiv() {
    // ***************************************************************************
    // Positioneerd het opgegeven object in het midden van de beschikbare
    // hoogte en breedte van de browser.
    // parms: foDIV=te positioneren object
    // return: --
    // ***************************************************************************
    var foDIV = arguments[0];

    var fiBRWDIM = getBrowserDim();
    var fiWDT = foDIV.offsetWidth;
    foDIV.style.left = (fiBRWDIM.BRWWDT / 2) - (fiWDT / 2) + 'px';
    return;
}




/**
 * uitschrijven van 1 bericht naar het boodschappen scherm
 * @param obj
 */
Messages.prototype.displayMessage = function(obj){

    this.renderPopup();
    //this.currentThread.messageText = obj.responseText.substr(5);

    var xmlDoc = XDOM.getXML(obj.responseText);
    if(!xmlDoc.getElementsByTagName("messageText")[0].childNodes[0]){
        return;
    }
    this.currentThread.messageText 	= xmlDoc.getElementsByTagName("messageText")[0].childNodes[0].nodeValue;


    var foTr = XDOM.createElement('TR',null);
    var foTd = XDOM.createElement('TD',null, null);
    var foIcon = XDOM.createElement('i',null,'pth-icon msg_'+this.currentThread.returnCode);
    var foTxtTd = XDOM.createElement('TD',null);
    var foTxtNode = XDOM.createTextNode(this.currentThread.messageText);

    this.resultable.appendChild(foTr);
    foTd.appendChild(foIcon);
    foTr.appendChild(foTd);
    foTr.appendChild(foTxtTd);
    foTxtTd.appendChild(foTxtNode);


    //scroll to results in msg div
    var resultContainer = XDOM.getObject('JOBMSGDIV');
    if(resultContainer){
        resultContainer.scrollTop = resultContainer.scrollHeight;
    }
    this.exitMessage = this.currentThread.messageText;
    return;
};

/* sort */
/* Load Timestamp 13:59:55.628 */
/* global Stateless, XDOM, Command, SESSION, GLOBAL */

function SortButton(){}
/**
 * static onclick handler voor sort buttons
 */
SortButton.handleOnClick = function(){
    Stateless.Page.set(GLOBAL.eventSourceElement);
    var page =  Stateless.Page.get();
    var currentFilter = XDOM.queryScope("[data-sort-active='true']");
    var oldField = '';
    var oldSequence = '';
    var sortField =  XDOM.GLOBAL.getAttribute("data-sort-field-name");
    var sequence =  XDOM.GLOBAL.getAttribute("data-sort-sequence");
    var caseSensitve =  '';

    if(XDOM.GLOBAL.getAttribute("data-sort-case-sensitve")==="*NOCASE"){
        caseSensitve = 'T';
    };

    if(currentFilter){
        currentFilter.setAttribute("data-sort-active","false");
        oldField = currentFilter.getAttribute("data-sort-field-name");
        oldSequence = currentFilter.getAttribute("data-sort-sequence");
        if(oldField===sortField && oldSequence===sequence){
            sortField = '';
            sequence = '';
            caseSensitve = '';
        }
    }
    if(page){
        page.setAdditionValue('WS_SRT', sortField.replace(page.prefix,''));
        page.setAdditionValue('WS_SEQ', sequence);
        page.setAdditionValue('WS_TRN', caseSensitve);

        page.submit('ENTER');
    }else{
        XDOM.createInputField('WS_SRT', sortField);
        XDOM.createInputField('WS_SEQ', sequence);
        XDOM.createInputField('WS_TRN', caseSensitve);
        Command.enter();
    }
    Stateless.Page.set();
    return;
};
/**
 * zet alle sorteer knoppen die geactiveerd zijn op niet geactiveerd
 * @returns {undefined}
 */
SortButton.deActivate = function(){
    var objects = XDOM.queryAll("[data-sort-active='true']");
    for(var i =0,l=objects.length;i<l;i++){
        objects[i].setAttribute("data-sort-active","false");
    }
};



/**
 * Toevoegen kolomsorterings knoppen
 * @param {string} prefix prefix alleen ingevuld in vanuit stateles pages
 */
SortButton.update = function(prefix) {

    if(!SESSION.activeData.headerData){
        return;
    }

    var sortField = SESSION.activeData.headerData['WS_SRT'] ;
    var sequence = SESSION.activeData.headerData['WS_SEQ']; // 'A' of 'D'
    SortButton.deActivate();

    if(!sortField){return;}
    if(prefix){
        sortField = prefix + sortField;
    }
    var sortButton = XDOM.query("[data-sort-field-name='" + sortField + "'][data-sort-sequence='" +sequence + "']"  );

    if(sortButton){
        sortButton.setAttribute("data-sort-active","true");
    }
    return;
};

/**
 * bereid de knoppen voor en zet het title attribute.
 * @returns {undefined}
 */
SortButton.prepareDom = function(){
    var objects = XDOM.queryAll("[data-sort-sequence='D']");
    var sortCount = XDOM.queryAll("[data-sort-sequence]");

    for(var i = 0,l=objects.length;i<l;i++){
        objects[i].title=getCapt('cSRTDSC_TTL');
    }

    objects = XDOM.queryAll("[data-sort-sequence='A']");

    for(var i = 0,l=objects.length;i<l;i++){
        objects[i].title=getCapt('cSRTASC_TTL');
    }

    if(sortCount.length > 0){
        XDOM.createInputField('WS_SRT', '');
        XDOM.createInputField('WS_SEQ', '');
        XDOM.createInputField('WS_TRN', '');
    }
    return;
};
/* barcode */
/* Load Timestamp 13:59:55.628 */
/**
 *
 * @param id van het zichbare input veld
 * @param isProtected geeft aan of veld protected is of niet
 */

Barcode = function (obj) {
    this.id								= obj.id;
    this.dom 							= {};
    this.count						= 0;
    this.totalCount				= 0;
    this.isProtected 			= false;
    this.init();
}

/**
 * @override GuiBaseObject
 */
Barcode.prototype.init = function(){
    this.dom.input 				= XDOM.getObject(this.id);
    this.dom.counter 			= XDOM.getObject(this.id + '_COUNT');
    this.dom.total 				= XDOM.getObject(this.id + '_CNT');
    this.dom.last 				= XDOM.getObject(this.id + '_LAST');
    this.dom.parentObject = XDOM.getObject('DTADIV');
    Barcode.instances[this.id] = this;
};


Barcode.prepareDom = function(){
    var pageObjects = XDOM.queryAllScope('[data-barcode="reader"]');
    var barcodeObject = null;

    for(var i=0,l=pageObjects.length;i<l;i++){
        barcodeObject = new Barcode(pageObjects[i]);
    }
};



Barcode.prototype.handleKeyUp = function(){
    var fsBarcode = XDOM.getObjectValue(this.dom.input);
    if(GLOBAL.charCode == keyCode.enter){
        if(fsBarcode.length == 0){
            SESSION.activePage.autoSubmitInputObject = GLOBAL.eventSourceElement;
            Command.enter();
        }else{
            this.addBarcode(fsBarcode);
        }
    }
    return true;
};


Barcode.prototype.addBarcode = function(fsBarcode){
    this.count++;
    this.totalCount++;
    var foInput = XDOM.createElement('INPUT',this.id + '_' + this.count);

    foInput.type="hidden";
    foInput.name = this.id + '_' + this.count;
    if(this.isProtected){
        foInput.readOnly = true;
        foInput.className += ' protect';
    }

    this.dom.parentObject.appendChild(foInput);
    XDOM.setObjectValue( foInput,fsBarcode);
    XDOM.setObjectValue( this.dom.input,'');
    XDOM.setObjectValue( this.dom.last,fsBarcode);

    XDOM.setObjectValue( this.dom.counter, this.count.toString());
    XDOM.setObjectValue( this.dom.total, 	 this.totalCount.toString());
};

Barcode.handleKeyUp = function(e){
    if((GLOBAL.eventSourceElement) && (GLOBAL.eventSourceElement.getAttribute("data-barcode")=="reader")){
        XDOM.cancelEvent(e);
        if(Barcode.instances[GLOBAL.eventSourceElement.id]){
            Barcode.instances[GLOBAL.eventSourceElement.id].handleKeyUp();
            return true;
        }
    }
    return false;
};



Barcode.handleKeyDown = function(){
    if((GLOBAL.eventSourceElement) && (GLOBAL.eventSourceElement.getAttribute("data-barcode")=="reader")){
        GLOBAL.eventSourceElement.setAttribute("data-block-autosubmit", "true");
    }
};

Barcode.update = function(){
    var pageObjects = XDOM.queryAllScope('[data-barcode="reader"]');
    var barcodeObject = null;

    for(var i=0,l=pageObjects.length;i<l;i++){
        barcodeObjectId = pageObjects[i].id;
        Barcode.instances[barcodeObjectId].resetValues();
    }
};

Barcode.prototype.resetValues = function(){

    for(var i=1,l=this.totalCount;i<=l;i++){
        XDOM.removeDOMObject(this.id+"_"+i);
    }

    this.count						= 0;
    //this.totalCount				= 0;

    XDOM.setObjectValue( this.dom.counter, this.count.toString());
    //XDOM.setObjectValue( this.dom.total, 	 this.totalCount.toString());
};
/* multiSelect */
/* Load Timestamp 13:59:55.628 */
/**
 *  aan sfl body data-subfile-clickable="*MULTISELECT" toevoegen
 *  aan de logical buton: data-click-action="ignore"
 *
 */


/* global Stateless, SESSION, GLOBAL, ENUM, Logical, XDOM, state, GUI */
/*
 * SESSION.activeData.headerAttributes (data.header)
 *
 */
var MultiSelect={pageType:"MultiSelect"};


/**
 * wordt aangeroepen bij het openen van de onderliggende macro page.updateDom
 * @returns {void}
 */
MultiSelect.updateDom = function(){
    var multiSelectObjects = null,
        multiSelectCounterField = null,
        multiSelectCounterValue = "",
        buttonHoverTitle        = "";

    multiSelectObjects = XDOM.queryAllScope("div[data-select-counter-id]");


    if(!multiSelectObjects){
        return;
    }

    for(let i=0,l=multiSelectObjects.length;i<l;i++){
        multiSelectCounterField = multiSelectObjects[i].dataset["selectCounterId"];

        if(multiSelectCounterField){
            multiSelectCounterValue = SESSION.activeData.headerData[multiSelectCounterField] || '0';
        }

        MultiSelect.updateButtonValues(multiSelectObjects[i].id, multiSelectCounterValue);
    };

    return;
};

MultiSelect.setButtonValues = function(objId){

    var objectId = null,
        objCounter = null,
        countValue = "0",
        buttonObject = null,
        buttonHoverTitle = "",

        objectId = objId;
    objCounter = XDOM.query(".logicalCounter[data-stateless-page-id='"+ objId + "']");

    if(!objectId || !objCounter){ return; }

    countValue = XDOM.getObjectValue(objCounter);

    buttonObject = XDOM.getObject(objectId);

    if(!buttonObject){ return; }

    MultiSelect.updateButtonValues(buttonObject, countValue);
};

MultiSelect.updateButtonValues = function(objId, objVal){
    var objectId = null,
        countValue = null,
        buttonObject = null,
        buttonHoverTitle = "",

        objectId = objId;
    countValue = objVal;

    if(!objectId || countValue === null){ return; }

    buttonObject = XDOM.getObject(objectId);
    if(!buttonObject){ return; }

    buttonHoverTitle = getCapt('cPMTMLTSLT_TTL1')+" "+countValue;

    //add hover title to multiselectbutton
    GUI.infoTitle.register(buttonObject, buttonHoverTitle);
    buttonObject.setAttribute("data-multiSelect-selected", countValue);
    return;
};



MultiSelect.close = function(){
    XDOM.focus(this.toId);
};


/**
 * @release
 *
 * @returns {Boolean} abbort
 */
MultiSelect.onReturnOk = function(){
    XDOM.setObjectValue(this.toId,this.data.headerData['WS_CD1_RTN'].trim());
    Stateless.panel.close(this.id);
    if (isAutoSubmitField(XDOM.getObject(this.toId))) {
        Command.execute('ENTER', true);
    }
    return true;
};


/**
 * wordt aangeroepen door de klick op een icoon
 * @param {type} obj obj kan leeg zijn of het dom object van het icoontje zijn
 * @returns {void}
 */
MultiSelect.open = function(obj){
    var callerObject = obj || GLOBAL.eventSourceElement;
    var id = callerObject.id ,
        page = Stateless.Page.get(id),
        panel = Stateless.panel.get(id);

    if(panel){ // al eerder aangeroepen geweest
        if(!XDOM.getBooleanAttribute(panel,"data-hidden")){
            //if(panel.style.display===''){
            //paneel is nog zichtbaar dus niets doen
            return;
        }
        Stateless.request.get(
            {callerObject:GLOBAL.eventSourceElement,
                onResponse:MultiSelect.onResponse,
                page:page});
        return;
    }
    Stateless.request.get(
        {callerObject:GLOBAL.eventSourceElement,
            onResponse:MultiSelect.onResponse,
            type:ENUM.requestType.all});
};

MultiSelect.Focus = function(id){
    var panel = Stateless.panel.get(id),
        obj = panel.querySelector('[data-record-number="1"][type="button"]');
    if(obj){ //eerste regel
        XDOM.focus(obj);
        return;
    }
    //nog geen regels
    //focus op het panel
    Stateless.panel.focus(id);
};

MultiSelect.onReturn = function(){};

MultiSelect.onResponse = function(response){
    Stateless.panel.open(response, MultiSelect);
    MultiSelect.Focus(response.calerId);
};

/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
MultiSelect.accept = function(){
    if(this.inputIsChanged || XDOM.GLOBAL.fieldIsChanged()){
        this.submit('ENTER'); //submit pagina want creteria zijn veranderd
        return;
    }else{
        //er zijn geen creteria veranderd
        //zet de selectie terug en sluit het scherm
        this.submit('ACCEPT');
    }

    MultiSelect.setButtonValues(this.id);
};

/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
MultiSelect.reset = function(){
    this.submit('RESET');
};
/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
MultiSelect.submit = function(){
    new Stateless.request(  {callerObject:XDOM.getObject(this.id),
        type:ENUM.requestType.data,
        onResponse:MultiSelect.onResponse});
};

MultiSelect.handleOnClick = function(body){
    var checkBox = body.querySelector("[data-datatype='*LGL']"),
        pageId = body.getAttribute("data-stateless-page-id"),
        page = Stateless.Page.get(pageId);
    Stateless.Page.setScope(page);
    Logical.toggle(checkBox);
    MultiSelect.onChange(page);
    Stateless.Page.setScope();
};


MultiSelect.prepareDom = function(){
    var tbody = XDOM.query('[data-subfile-clickable="*MULTISELECT"]'),
        checkbox = null,
        selectWrapper  = XDOM.query('.clearSelectWrapper'),
        clearSelection  = XDOM.query('.clearSelection');
    if(clearSelection){
        clearSelection.setAttribute("data-hidden","true"); //wordt onterecht als true meegegeven
    }
    if(selectWrapper){
        selectWrapper.setAttribute("data-hidden","false"); //wordt onterecht als true meegegeven
    }
    if(tbody){
        checkbox = tbody.querySelector("[data-datatype='*LGL']");
        checkbox.setAttribute("data-multiselect", "true");
    }
};


//MultiSelect.getSelection = function(id){
//  var selectedArray = [],
//      parent = XDOM.getObject(id + "-SFLTBL"),
//      checkBox = null,
//      keyInput = null,
//      keyValue = '',
//      checkBoxes = parent.querySelectorAll('[value="SLT"]');
//
//  for(var i=0,l=checkBoxes.length;i<l;i++){
//    checkBox = checkBoxes[i];
//    keyInput = checkBox.parentNode.querySelector("[type='hidden']:not([data-datatype='*LGL']");
//    keyValue = XDOM.getObjectValue(keyInput);
//    selectedArray.push(keyValue);
//  }
//  return selectedArray;
//};



MultiSelect.onChange = function(page){
    if(!page || page.type !=="MultiSelect"){
        return false;
    }
    var tbody = XDOM.getParentByTagName(GLOBAL.eventSourceElement,'TBODY');
    if(!tbody){return;}

    var recordNr = parseInt(tbody.getAttribute("data-record-number")) -1,
        selector = tbody.querySelector("input[data-datatype='*LGL']"),
        // initialValue = page.data.subfileData[recordNr]["SF_SLT_INZ"],
        currentValue = XDOM.getObjectValue(selector);

    page.data.subfileData[recordNr]["SF_SLT"] = currentValue;
    // MultiSelect.markChanged(tbody,initialValue);
    MultiSelect.updateCounter(page);
    return true;
};

MultiSelect.update = function(page){
    if(page.type=='MultiSelect'){
        MultiSelect.updateCounter(page);
    }
};

MultiSelect.updateCounter = function(page){
    var counter = XDOM.query(".logicalCounter[data-stateless-page-id='"+ page.id + "']"),
        nr =0,
        data = [];
    if(page.data.removedSubfileData){
        data = page.data.subfileData.concat(page.data.removedSubfileData);
    }else{
        data = page.data.subfileData;
    }


    for(var i =0,l=data.length;i<l;i++ ){
        if(data[i]["SF_SLT"]==="1"){
            nr++;
        }
    }
    XDOM.setObjectValue(counter,nr);
};

MultiSelect.markChanged = function(tbody,initialValue){
//  if(SESSION.activeData.macroProperties.macroType !=="*MLTSLT"){
//    return;
//  }
//  var selector = tbody.querySelector("input[data-datatype='*LGL']"),
//  currentValue = XDOM.getObjectValue(selector);
//  tbody.setAttribute("data-selector-changed", (currentValue !==initialValue ));
//
};


MultiSelect.toggleAll = function(selected){
    var page = Stateless.Page.get();
    if(!page ||  page.type !=="MultiSelect" ){
        return;
    }

    var data = page.data.subfileData;
    //sfl = XDOM.getObject(page.subfile.sflObject.id);
    // tbodys = sfl.getElementsByTagName("TBODY");


    for(var i=0,l=data.length;i<l;i++){
        if(selected){
            data[i]['SF_SLT'] = '1';
        }else{
            data[i]['SF_SLT'] = '0';
        }
//    if(tbodys[i]){
//      MultiSelect.markChanged(tbodys[i], data[i]["SF_SLT_INZ"]);
//    }
    }
    MultiSelect.updateCounter(page);
};


/* QueryList */
/* Load Timestamp 13:59:55.629 */
/* global Stateless, SESSION, GLOBAL, ENUM, Logical, XDOM, state, GUI */
/*
 * SESSION.activeData.headerAttributes (data.header)
 *
 */
var QueryList = {pageType: 'QueryList'};

/**
 * aanpassingen aan de html als deze nog een platte text is
 * dit zijn fixes die later nog op de server moeten worden gedaan
 * @param {type} htmlIn
 * @returns {QueryList.prepareHTML.html}
 */

/**
 * wordt aangeroepen bij het openen van de onderliggende macro page.updateDom
 * @returns {void}
 */
QueryList.close = function () {
    XDOM.focus(this.toId);
};

/**
 * @release
 *
 * @returns {Boolean} abbort
 */

/**
 * gets an array of field-ids and if the pagePrefix is set add it to the id's
 * @param fields string []
 * @param pagePrefix
 * @returns {string []}
 */
QueryList.fieldNames2DomIds = function (fields, pagePrefix) {
    //we need no changes if we don't have a pagePrefix.
    if (!pagePrefix)
        return fields;
    const getValidDomID = (id) => {
        //see if we can find this id in the dom
        let domElement = XDOM.getObject(id);
        if(domElement) {
            //if we have a dom element we can use it
            return id;
        }
        let prefixedId = pagePrefix + id;
        //check if this field exists with a prefix
        domElement = XDOM.getObject(prefixedId);
        if(domElement) {
            //if we have a dom element we can use it
            return prefixedId;
        }
        //now for some reason we als have a prefic including the p- prefix
        prefixedId = "p-" + prefixedId;
        domElement = XDOM.getObject(prefixedId);
        if(domElement) {
            //if we have a dom element we can use it
            return prefixedId;
        }
        //we can't find it so return an empty string istead
        return '';

    }



    //add the prefix to all fields
    return fields.map(getValidDomID)

}

QueryList.getToObject = function (prefix, toId) {
    if(XDOM.getObject( prefix + toId)) return prefix + toId;
    return toId;
}
QueryList.handleOnClick = function (body) {
    let currentPage = Stateless.Page.get(),
        icon = XDOM.getObject(currentPage.id),
        pageId = icon.dataset.statelessPageId || '',
        jobParmAction = icon.dataset.jobParmAction,
        pagePrefix = pageId ? pageId + '-' : '',
        page = null;
    let returnFieldsArray = (icon.dataset.returnFields || icon.dataset.panelId || '').split(' '),
        returnFields = QueryList.fieldNames2DomIds(returnFieldsArray,pagePrefix),
        clearFields = (icon.dataset.clearFields || '').split(' '),
        isEditWindow = false;


    const pageToId = QueryList.getToObject(pagePrefix , currentPage.toId)

    //icon out of edit window
    if (icon.dataset.parmPrefix) {
        //pagePrefix = icon.dataset.parmPrefix;
        isEditWindow = true;
    }

    // if we don't have return fields or clearFields close the panel
    if (!icon.dataset.returnFields && (!this.clearFields || this.clearFields.length === 0)) {
        Stateless.panel.close(currentPage.id);
        return;
    }

    if (pageId) {
        page = Stateless.Page.get(pageId);
    }

    const returnValues = currentPage.subfile.getReturnValues(body);

    for (let i = 0, l = returnFields.length; i < l; i++) {
        let fieldId = returnFields[i];
        let value = decodeURIComponent(returnValues[i]);
        XDOM.setObjectValue(fieldId, value);
    }

    Stateless.panel.close(currentPage.id);

    if (jobParmAction === ENUM.triggerAction.update) {
        Command.ipmfSubmitOnly();
    } else {
        if (isAutoSubmitField(pageToId) || hasAutoSubmitFields(returnFields)) {
            if (page) {
                page.submit('ENTER');
                return;
            }

            if (isEditWindow) {
                GUI.events.autoSubmit(XDOM.getObject(pageToId));
                return;
            }
            Command.execute('ENTER', true);
            return;
        }
    }
    XDOM.clearFields(clearFields);
    Trigger.fire(returnFields.concat(clearFields));
    XDOM.setOldvalue(returnFields.concat(clearFields));
    resetMessage();
};

QueryList.setReturnValues = function (body) {

}


QueryList.onReturnOk = function () {
    Stateless.panel.close(this.id);
    return true;
};

/**
 * wordt aangeroepen door de klick op een icoon
 * @param {type} obj obj kan leeg zijn of het dom object van het icoontje zijn
 * @returns {Promise<void>}
 */
QueryList.open = function (obj) {
    var callerObject = obj || GLOBAL.eventSourceElement;
    var id = callerObject.id,
        page = Stateless.Page.get(id),
        panel = Stateless.panel.get(id);

    if (panel) {
        // al eerder aangeroepen geweest

        if (callerObject.dataset.screenMode !== '*SUBVIEW' && !XDOM.getBooleanAttribute(panel, 'data-hidden')) {
            //paneel is nog zichtbaar dus niets doen
            return Promise.resolve();
        }
        return Stateless.request.get({callerObject: callerObject, onResponse: QueryList.onResponse, page: page});
    }
    return Stateless.request.get({
        callerObject: callerObject,
        onResponse: QueryList.onResponse,
        type: ENUM.requestType.all
    });
};

QueryList.Focus = function (id) {
    var panel = Stateless.panel.get(id),
        obj = panel.querySelector('[data-record-number="1"][type="button"]');
    if (obj) {
        //eerste regel
        XDOM.focus(obj);
        return;
    }
    //nog geen regels
    //focus op het panel
    Stateless.panel.focus(id);
};

QueryList.onReturn = function () {
};

QueryList.onResponse = function (response) {
    Stateless.panel.open(response, QueryList);
};

/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
QueryList.accept = function () {
    if (this.inputIsChanged || XDOM.GLOBAL.fieldIsChanged()) {
        this.submit('ENTER'); //submit pagina want creteria zijn veranderd
        return;
    } else {
        //er zijn geen creteria veranderd
        //zet de selectie terug en sluit het scherm
        this.submit('ACCEPT');
    }
};

/**
 * deze functie wordt als referentie aan een page object gehangen
 * daarom verweist this naar een instantie van het stateles page object
 */
QueryList.reset = function () {
    this.submit('RESET');
};
/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
QueryList.submit = function () {
    new Stateless.request({
        callerObject: XDOM.getObject(this.id),
        type: ENUM.requestType.data,
        onResponse: QueryList.onResponse
    });
};

QueryList.updateDom = function () {
    const promises = []
    var subviewParts = XDOM.queryAll('[data-stateless-type="*QUERYLIST"][data-screen-mode="*SUBVIEW"]'),
        part = null;
    for (var i = 0, l = subviewParts.length; i < l; i++) {
        part = subviewParts[i];
        promises.push(QueryList.open(part));
    }
    return promises;
};

/* editinfo */
/* Load Timestamp 13:59:55.629 */
/* global Stateless, SESSION, GLOBAL, ENUM, Logical, XDOM, state, GUI */
/*
 * SESSION.activeData.headerAttributes (data.header)
 *
 */
var EditInfo={pageType:"EditInfo"};


/**
 * wordt aangeroepen bij het openen van de onderliggende macro page.updateDom
 * @returns {void}
 */
EditInfo.close = function(){
    XDOM.focus(this.toId);
};


/**
 * @release
 *
 * @returns {Boolean} abbort
 */

EditInfo.onReturnOk = function(){
    Stateless.panel.close(this.id);
    return true;
};


/**
 * wordt aangeroepen door de klick op een icoon
 * @param {type} obj obj kan leeg zijn of het dom object van het icoontje zijn
 * @returns {void}
 */
EditInfo.open = function(obj){
    var callerObject = obj || GLOBAL.eventSourceElement;
    var id = callerObject.id ,
        page = Stateless.Page.get(id),
        panel = Stateless.panel.get(id);

    if(panel){ // al eerder aangeroepen geweest

        if(callerObject.dataset.screenMode!=="*SUBVIEW"  && !XDOM.getBooleanAttribute(panel,"data-hidden")){
            //paneel is nog zichtbaar dus niets doen
            return;
        }
        Stateless.request.get(
            {callerObject:callerObject,
                onResponse:EditInfo.onResponse,
                page:page});
        return;
    }
    Stateless.request.get(
        {callerObject:callerObject,
            onResponse:EditInfo.onResponse,
            type:ENUM.requestType.all});
};

EditInfo.Focus = function(id){
    var panel = Stateless.panel.get(id),
        obj = panel.querySelector('[data-record-number="1"][type="button"]');
    if(obj){ //eerste regel
        XDOM.focus(obj);
        return;
    }
    //nog geen regels
    //focus op het panel
    Stateless.panel.focus(id);
};

EditInfo.onReturn = function(){};

EditInfo.onResponse = function(response){
    Stateless.panel.open(response, EditInfo);
};

/**
 * deze functie wordt als referentie aan een page object gehangen
 * daarom verweist this naar een instantie van het stateles page object
 */
EditInfo.accept = function(){
    if(this.inputIsChanged || XDOM.GLOBAL.fieldIsChanged()){
        this.submit('ENTER'); //submit pagina want creteria zijn veranderd
        return;
    }else{
        //er zijn geen creteria veranderd
        //zet de selectie terug en sluit het scherm
        this.submit('ACCEPT');
    }
};

/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
EditInfo.reset = function(){
    this.submit('RESET');
};
/**
 * deze functie wordt als referentie aan een page object gehangen
 * darom verweist this naar een instantie van het stateles page object
 */
EditInfo.submit = function(){
    new Stateless.request(  {callerObject:XDOM.getObject(this.id),
        type:ENUM.requestType.data,
        onResponse:EditInfo.onResponse});
};


EditInfo.updateDom = function(){
    var subviewParts = XDOM.queryAll('[data-stateless-type="*EDIT"][data-screen-mode="*SUBVIEW"],[data-stateless-type="*INFO"][data-screen-mode="*SUBVIEW"]'),
        part = null;
    for(var i = 0, l=subviewParts.length; i<l; i++) {
        part = subviewParts[i];
        EditInfo.open(part);
    }
};






/* subfile */
/* Load Timestamp 13:59:55.631 */
function Subfile(id) {
    this.id = id;
    this.axisArray = [];
    this.length = 0;
    this.data = null;
    this.fields = [];
    this.index = 0;
    this.lastRenderdRecord = 0;
    this.collgroup = null;
    this.headerColgroup = null;
    this.recordTemplate = null;
    this.highlightedRecord = null;
    this.selectedRecords = null;
    this.lastSelectedKey = null;
    this.prefix = '';
    this.pageSize = null;
    this.lastRow = 0;
    this.inputIds = [];

    //scroll behavior only in search pages for now
    this.extendOnScroll = screenType()== "*SCH"
    //indicator to use when extending the sub file.
    this.doNotClear = false;
    this.doNotScroll = false;
}

Subfile.prototype.setInputIds = function () {
    var inputs = this.recordTemplate.querySelectorAll('INPUT');
    for (var i = 0, l = inputs.length; i < l; i++) {
        if (inputs[i].id.indexOf('-checkbox') > -1) {
            continue;
        }
        this.inputIds.push(
            inputs[i].id.replace(this.prefix, '').replace('_#SflRcdNbr', '')
        );
    }
};

Subfile.prototype.addAdditionalRecord = function (formFields, record, recordNr) {
    var fieldName = '';
    for (var n = 0, l = this.inputIds.length; n < l; n++) {
        fieldName = this.inputIds[n];
        formFields.append(fieldName + '_' + recordNr, record[fieldName]);
    }
};

Subfile.prototype.addAdditionalRecords = function (data, formFields) {
    var recordNr = this.index + 1;
    for (var i = 0, l = data.length; i < l; i++) {
        this.addAdditionalRecord(formFields, data[i], recordNr++);
    }
};

Subfile.prototype.prepareColGroups = function () {
    this.prepareColGroup(this.collgroup);
    this.prepareColGroup(this.headerColgroup);
};

Subfile.prototype.prepareColGroup = function (colGroup) {
    var sflWidth = colGroup.getAttribute('data-sfl-custom-width'),
        oneCol = null,
        col = null,
        colWidth = 0,
        columns = [],
        remaining = 100,
        emptyCol = null;
    if (!sflWidth || isNaN(sflWidth)) {
        return;
    }
    oneCol = 100 / sflWidth;
    columns = colGroup.getElementsByTagName('COL');
    for (var i = 0, l = columns.length; i < l; i++) {
        col = columns[i];
        colWidth = parseInt(col.getAttribute('data-column-width'));
        if (!colWidth) {
            emptyCol = col;
            continue;
        }

        colWidth *= oneCol;
        remaining -= colWidth;
        col.style.width = colWidth + '%';
    }
    if (emptyCol) {
        emptyCol.style.width = remaining + '%';
    }
};



/**
 * scroll handler for loading
 * @param e
 */
Subfile.prototype.onScroll = function (e) {
    //check to see if we need to load
    if(!scrolledDownToRange(e.target, 100)) return;

    //check to see if the last field has changed because a scroll event might come before a blur event.
    if(Subfile.checkForChange()) return;

    this.doNotClear = true //prevent removing data
    this.doNotScroll = true; //preventing scrolling to the first line after reloading
    Command.execute("PAGEDN")
}
/**
 * set scroll listner
 */
Subfile.prototype.setEventListners = function () {
    // if(!this.extendOnScroll) return;
    // const sflBody = XDOM.getObject("SFL")
    // sflBody.addEventListener("scroll",this.onScroll.bind(this) )
}
Subfile.prototype.prepareDom = function () {
    var table = XDOM.getObject(this.id);
    var headerTable = XDOM.getObject(this.id.replace('SFLTBL', 'COLHDGTBL'));

    this.collgroup = table.getElementsByTagName('colgroup')[0].cloneNode(true);
    this.headerColgroup = headerTable.getElementsByTagName('colgroup')[0];
    this.recordTemplate = table.getElementsByTagName('TBODY')[0].cloneNode(true);
    table.innerHTML = '';
    this.prepareColGroups();
    this.prepareLogical();
    this.prepareTopview();
    this.prepareTitle();
    this.prepareLink();
    this.prepareIcons()
    this.setInputIds();
    this.setFixedWidth();
    this.setEventListners();
};

Subfile.prototype.setFixedWidth = function () {
    if (SCOPE.main.Settings.get('FIXED_EXTENDED_DATA_WIDTH')) {
        let extendedObject = XDOM.getObject('extendedDataContent');

        if (!extendedObject) {
            return;
        } //==>

        let tableHeaderObject = XDOM.getObject('COLHDG'),
            tableBodyObject = XDOM.getObject('SFL');
        extendedBackgroundObject = XDOM.getObject('extendedDataBg');

        if (!tableHeaderObject || !tableBodyObject) {
            return;
        } //==>

        tableHeaderObject.setAttribute('data-fixed-width', 'true');
        tableBodyObject.setAttribute('data-fixed-width', 'true');
        extendedObject.setAttribute('data-fixed-width', 'true');
        extendedBackgroundObject.setAttribute('data-fixed-width', 'true');
    }
};

Subfile.prototype.prepareTitle = function () {
    var pageObjects = this.recordTemplate.querySelectorAll(
        '[data-title-origin="*LBL"]'
    );
    GUI.infoTitle.registerNodeList(pageObjects);
};

Subfile.prototype.prepareLink = function () {
    var aLinks = this.recordTemplate.querySelectorAll("a[data-datatype='*LNK']");
    var pLink = null;
    var aLink = null;
    var aLinkType = null;
    var isHashed = false;

    for (var i = 0, l = aLinks.length; i < l; i++) {
        aLink = aLinks[i];
        pLink = aLink.parentNode;

        aLink.setAttribute('data-axis', pLink.getAttribute('data-axis'));
        aLink.setAttribute(
            'data-value-from-id',
            pLink.getAttribute('data-value-from-id')
        );

        aLink.setAttribute(
            'data-alias-type',
            pLink.getAttribute('data-alias-type')
        );
        aLink.setAttribute(
            'data-alias-field',
            pLink.getAttribute('data-alias-field')
        );
        aLink.setAttribute('data-protocol', pLink.getAttribute('data-protocol'));
        aLink.setAttribute('target', '_blank');

        pLink.setAttribute('data-datatype', '*SYSTEM');
        pLink.removeAttribute('data-value-from-id');

        aLinkType = aLink.getAttribute('data-url-type');

        if (aLinkType && aLinkType === '*HashedUrl') {
            isHashed = true;
        }

        if (!isHashed) {
            pLink.setAttribute('data-click-action', 'Link.handleOnClick');
            aLink.setAttribute('data-click-action', 'Link.handleOnClick');
        }
    }
};

/**
 * Iterates over all dom elements in scope, having data-macro-desc as an attribute and sets the title accordingly.
 */
Subfile.prototype.prepareTopview = function () {
    //query the relevant dom objects destructure in an array
    const topViewIcons = [...this.recordTemplate.querySelectorAll('[data-macro-desc]')];

    //iterate over all elements
    topViewIcons.forEach(icon=>{
        //do we have a description
        if(!icon.dataset.macroDesc) return;
        //set the title
        icon.title = icon.dataset.macroDesc;
    })

};


Subfile.prototype.prepareLogical = function () {
    var logicals = this.recordTemplate.querySelectorAll("[data-datatype='*LGL']");
    for (var i = 0, l = logicals.length; i < l; i++) {
        logicals[i].parentNode.setAttribute(
            'data-click-action',
            'Logical.handleTdClick'
        );
    }
};

/**
 * set referencie van header en body deel naar elkaar zodat ze gevonden kunnen worden
 * bij een overgang van header naar body en vice versa
 * @param {type} prefix
 * @returns {undefined}
 */
Subfile.setHeaderBodyRef = function (prefix) {
    var headerDiv = XDOM.getObject(prefix + 'COLHDG');
    var bodyDiv = XDOM.getObject(prefix + 'SFL');
    if (!headerDiv) {
        return;
    }
    headerDiv.setAttribute('data-sfl-body-id', bodyDiv.id);
    bodyDiv.setAttribute('data-sfl-header-id', headerDiv.id);
};

/**
 * neemt data-line en data-xpos attributen over van de hidden input naar de
 * button
 * @param {type} prefix
 * @returns {undefined}
 */
Subfile.fixHeaderLogical = function (prefix) {
    var headerDiv = XDOM.getObject(prefix + 'COLHDG'),
        logical = null,
        logicalButton = null,
        logicals = headerDiv.querySelectorAll("[data-datatype='*LGL']");
    for (var i = 0, l = logicals.length; i < l; i++) {
        logical = logicals[i];
        logicalButton = XDOM.getObject(logical.id + '-checkbox'); //Hoeft nog niet aangepast te worden... rkr
        if (!logicalButton) {
            continue;
        }

        logicalButton.setAttribute('data-line', logical.getAttribute('data-line'));
        logicalButton.setAttribute('data-xpos', logical.getAttribute('data-xpos'));
    }
};

Subfile.prototype.getSelectedRecords = function () {
    if (SESSION.activePage.programResumed === 'false') {
        SESSION.activePage.subfilePos = 0;
    }
    var subfileSelectedRecords = SESSION.activePage.subfileSelectedRecords;
    this.selectedRecords = {};
    if (!subfileSelectedRecords) {
        return; //-->
    }
    for (var i = 0, l = subfileSelectedRecords.length; i < l; i++) {
        this.selectedRecords[subfileSelectedRecords[i].SF_KEY] = true;
    }
};

Subfile.prototype.updateSelectAll = function () {
    var checkBox = XDOM.getObject('SLTALL');
    if (checkBox) {
        Logical.setObjValue(checkBox, '');
    }
};

Subfile.prototype.updateColumnHeading = function (headerObj) {
    var obj = null,
        colorField = '',
        colorName = '',
        applyTo = '',
        colorValue = '',
        classPrefix = '',
        classSuffix = '';
    var colorFields = headerObj.querySelectorAll('[data-color-apply]');

    for (var i = 0, l = colorFields.length; i < l; i++) {
        obj = colorFields[i];
        colorField = obj.getAttribute('data-color-field');
        colorName = obj.getAttribute('data-color-name');
        applyTo = obj.getAttribute('data-color-apply');
        if (colorField) {
            colorValue = SESSION.activeData.headerAttributes[colorField];
            colorName = colorValue;
        } else if (colorName) {
            colorValue = colorName;
        }

        if (colorValue.indexOf('*') === 0) {
            // fixed colors (*RED, *BLUE etc)
            classSuffix = colorName.substr(1);
            if (applyTo === '*FONT') {
                classPrefix = 'font_';
            } else if (applyTo === '*BKGD') {
                classPrefix = 'bkgd_';
            }
            obj.className += ' ' + classPrefix + classSuffix.toLowerCase();
        } else {
            if (applyTo === '*FONT') {
                obj.style.color = colorValue;
            } else if (applyTo === '*BKGD') {
                obj.style.backgroundColor = colorValue;
            }
        }
    }
};

Subfile.prototype.clear = function () {
    if(this.doNotClear) {
        return;
    }
    var table = XDOM.getObject(this.id);
    table.innerHTML = '';
};

Subfile.prototype.update = function (reload = this.doNotClear) {
    var fragment = null;
    var table = XDOM.getObject(this.id);
    table.innerHTML = "";
    this.getSelectedRecords();
    this.updateSelectAll();
    fragment = document.createDocumentFragment();
    this.data =
        SESSION.activeData.subfileData || SESSION.activeData.subfile || []; //temp
    this.attributes = SESSION.activeData.subfileAttributes || {};
    this.index = 0;
    this.lastSelectedKey = null;
    this.lastRow = this.pageSize || this.data.length;
    if (reload) {
        this.lastRow = this.data.length;
    }

    if (SESSION.activeData.headerData) {
        this.lastSelectedKey = SESSION.activeData.headerData.WS_KEY;
    }

    if(!reload){
        fragment.appendChild(this.collgroup.cloneNode(true));
    }

    this.renderRecords(fragment);
    table.appendChild(fragment);
    this.selectSFKey(table);
    this.doNotClear = false;
};

/**
 *
 * @param {type} body
 * @returns {undefined}
 */
Subfile.prototype.renderRecords = function (body) {
    var lastRow = this.lastRow;
    if (lastRow > this.data.length) {
        lastRow = this.data.length;
    }
    for (; this.index < lastRow; this.index++) {
        body.appendChild(this.renderRecord());
    }
};
/**
 * check if last field was changed
 * This is done because onScroll event handler fires before blur (at least in chrome)
 */
Subfile.checkForChange = function(page) {
    if (!XDOM.fieldIsChanged(SESSION.activePage.lastFocusedField)) return false;
    if(page){
        page.submit("ENTER");
    }
    handleOnChange(XDOM.getObject(SESSION.activePage.lastFocusedField))

    return true;
};

Subfile.prototype.renderNextRecords = function () {
    var body = XDOM.getObject(this.prefix + 'SFLTBL');
    if (this.index >= this.data.length) {
        return false; // er zijn geen regels meer waar je naartoe kan scrollen
    }
    this.lastRow = this.index + this.pageSize;
    this.renderRecords(body);
    return true;
};

Subfile.prototype.renderRecord = function () {
    var record = this.recordTemplate.cloneNode(true);
    var serverIndex = scriptToServer(this.index);
    record.innerHTML = record.innerHTML.replace(/#SflRcdNbr/g, serverIndex);

    this.updateMask(record, serverIndex);
    this.updateEvents(record, serverIndex);
    this.updateInfoWindow(record, serverIndex);
    this.updateSearch(record, serverIndex);
    this.updateTopview(record, serverIndex);
    this.updateQuickSearch(record, serverIndex);
    this.updateLink(record, serverIndex);
    this.updateInput(record, serverIndex);
    this.updateImage(record, serverIndex);
    this.updateRecord(record, serverIndex);
    this.updateOutput(record, serverIndex);
    this.updateLabel(record, serverIndex);
    this.updateColor(record, serverIndex);
    this.updateWhen(record, serverIndex);
    this.updateAttentionLevel(record, serverIndex);
    this.updateRadio(record, serverIndex);
    this.updateValues(record, serverIndex);
    this.updateService(record, serverIndex);
    this.updateMaxScale(record, serverIndex);
    this.updateEditWindow(record, serverIndex);
    this.updateQueryList(record, serverIndex);
    this.updateFieldAttribute(record, serverIndex);
    this.updateDataAttribute(record, serverIndex);
    this.updateSessionLauncher(record, serverIndex);
    this.updateIcons(record, serverIndex);
    return record;
};

//Subfile.prototype.updateMultiSelect = function(record){
// MultiSelect.markChanged(record,this.data[this.index]["SF_SLT_INZ"]);
//};

Subfile.prototype.updateOutput = function (record, serverIndex) {
    var outputs = record.querySelectorAll('output[data-datatype]');
    var obj = null;
    for (var i = 0, l = outputs.length; i < l; i++) {
        obj = outputs[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
    }
};

Subfile.prototype.prepareIcons = function () {
    icons.prepareDom(this.recordTemplate);
}

Subfile.prototype.updateIcons = function (record, serverIndex) {
    icons.updateSubfileRecord(record,this.data[this.index])
}

Subfile.prototype.updateLabel = function (record, serverIndex) {
    var labels = record.getElementsByTagName('label');
    var labelObj = null;
    var captionId = null;
    var captionTxt = null;

    for (var i = 0, l = labels.length; i < l; i++) {
        labelObj = labels[i];
        if (!labelObj) {
            return;
        }

        captionId = XDOM.getAttribute(labelObj, 'data-caption-id');
        captionTxt = Captions.returnCaption(captionId);

        if (captionTxt && captionTxt !== '') {
            labelObj.innerHTML = captionTxt;
        }
    }
};

Subfile.prototype.updateEditWindow = function (record, serverIndex) {
    var editWindows = record.querySelectorAll('[data-edit-id]');
    var obj = null;
    for (var i = 0, l = editWindows.length; i < l; i++) {
        obj = editWindows[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute(
            'data-edit-id',
            obj.getAttribute('data-edit-id') + '_' + serverIndex
        );
        obj.setAttribute('data-record-number', serverIndex);
    }
};

Subfile.prototype.updateQueryList = function (record, serverIndex) {
    const querylists = record.querySelectorAll('.queryList');

    function updateAttribute(obj, attribute) {
        //attribute fields these might be a single string or a space seperated list of string
        // iterate over them and ad record postfix
        const valueArray = (obj.getAttribute(attribute) || '').split(" ");
        const value = valueArray.map(field => {
                //do we have a field or is it just an extra space
                if (!field || !field.trim()) return '';

                //add postfix
                field += '_' + serverIndex
                return field
            }
        ).join(' ')

        //set the modified input fields
        obj.setAttribute(attribute, value);
    }

    for (let i = 0, l = querylists.length; i < l; i++) {
        const obj = querylists[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);

        //update toId
        const axis = obj.getAttribute('data-to-id');
        obj.setAttribute('data-to-id', axis + '_' + serverIndex);
        updateAttribute(obj, "data-input-fields");
        updateAttribute(obj, "data-return-fields");

    }
};

Subfile.prototype.updateLink = function (record, serverIndex) {
    var obj;
    var hrefs = record.querySelectorAll("a[datatype='*LNK']");
    for (var i = 0, l = hrefs.length; i < l; i++) {
        obj = hrefs[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);
        obj.parentNode.setAttribute('data-record-number', serverIndex);
        //obj.linkOpenPreference = obj.parentNode.dataset.linkOpenPreference;
    }
};

Subfile.prototype.updateColor = function (record, serverIndex) {
    //  Aangepast door MVB
    if (!this.attributes) {
        return;
    }
    var obj = null,
        colorField = '',
        colorName = '',
        applyTo = '',
        colorValue = '',
        classPrefix = '',
        classSuffix = '';
    var tds = record.querySelectorAll('[data-color-apply]');
    var dataRecord = this.attributes[this.index];

    for (var i = 0, l = tds.length; i < l; i++) {
        obj = tds[i];
        colorField = obj.getAttribute('data-color-field');
        colorName = obj.getAttribute('data-color-name');
        applyTo = obj.getAttribute('data-color-apply');

        if (colorField) {
            colorValue = dataRecord[colorField];
            colorName = colorValue;
        } else if (colorName) {
            colorValue = colorName;
        }

        if (colorValue.indexOf('*') === 0) {
            // fixed colors (*RED, *BLUE etc)
            classSuffix = colorName.substr(1);
            if (applyTo === '*FONT') {
                classPrefix = 'font_';
            } else if (applyTo === '*BKGD') {
                classPrefix = 'bkgd_';
            }
            obj.className += ' ' + classPrefix + classSuffix.toLowerCase();
        } else {
            if (applyTo === '*FONT') {
                obj.style.color = colorValue;
            } else if (applyTo === '*BKGD') {
                obj.style.backgroundColor = colorValue;
            }
        }
    }
};

Subfile.prototype.updateValues = function (record, serverIndex) {
    var obj = null,
        value = '',
        fieldName = '',
        type = '';
    var inputs = record.getElementsByTagName('input');
    var dataRecord = this.data[this.index];

    for (var i = 0, l = inputs.length; i < l; i++) {
        obj = inputs[i];
        type = obj.getAttribute('data-datatype');

        fieldName = obj.id.replace('_' + serverIndex, '');
        fieldName = fieldName.replace(this.prefix, '');

        value = dataRecord[fieldName];

        if (
            type !== '*LGL' &&
            type !== '*MASK' &&
            type !== '*SYSTEM' &&
            obj.type !== 'button'
        ) {
            if (!hasValue(value)) {
                value = '*--*';
            }
        }

        if (isLogical(obj)) {
            fieldName = Logical.getFieldName(fieldName);
            value = dataRecord[fieldName];
            Logical.setObjValue(obj, value);
        } else {
            XDOM.setObjectValue(obj, value, this);
        }
    }
};
Subfile.prototype.updateMaxScale = function (record, serverIndex) {
    var dataRecord = this.attributes[this.index];
    var elements = record.querySelectorAll(
        '[data-datatype ="*DEC"][data-maxscale-system-limit]:not([data-maxscale-system-limit="*AUTO"])'
    );
    var obj = null,
        scaleObject = null;

    for (var i = 0, l = elements.length; i < l; i++) {
        obj = elements[i];
        if (obj.getAttribute('data-maxscale-field') !== '*IGNORE') {
            scaleObject = new MaxScale(obj, dataRecord);
            scaleObject.apply();
        }
    }
    //cleanup voor garbage collection
    obj = null;
    scaleObject = null;
    elements = null;
};

Subfile.prototype.updateInput = function (record, serverIndex) {
    let obj = null,
        inputs = record.querySelectorAll('input, a[role="button"]');

    for (var i = 0, l = inputs.length; i < l; i++) {
        obj = inputs[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.name = obj.name.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);
    }
    INP.registerEvents(inputs);
};

Subfile.prototype.updateImage = function (record, serverIndex) {
    var obj = null,
        value = '',
        fieldName = '',
        type = '';

    var imageObjects = record.querySelectorAll('[data-datatype="*IMG"]');
    var dataRecord = this.data[this.index];

    for (var i = 0, l = imageObjects.length; i < l; i++) {
        imgObj = imageObjects[i];
        fieldName = imgObj.id.replace('_' + serverIndex, '');
        value = dataRecord[fieldName];

        if (!value) {
            XDOM.removeDOMObject(imgObj);
            continue;
        }

        imgObj.id = imgObj.id.replace('#SflRcdNbr', serverIndex);
        imgObj.setAttribute('data-record-number', serverIndex);

        oculusImage.setObjValue(imgObj, value);
    }
};

Subfile.prototype.updateEvents = function (record, serverIndex) {
    var obj = null;
    var objects = record.querySelectorAll('[data-blur-action]:not(input)'); // :not(input)
    for (var i = 0, l = objects.length; i < l; i++) {
        obj = objects[i];
        XDOM.addEventListener(obj, 'blur', handleBlur);
    }

    objects = record.querySelectorAll('[data-focus-action]:not(input)');
    for (var i = 0, l = objects.length; i < l; i++) {
        obj = objects[i];
        XDOM.addEventListener(obj, 'focus', handleFocus);
    }
};

/**
 * zet de focus op de regel van lastSelectedKey;
 * Alleen als er een SF_KEY is gedefinieerd
 * @param table domobject table
 * @returns {undefined}
 */
Subfile.prototype.selectSFKey = function (table) {
    if (!table) {
        return;
    }
    if (!hasValue(this.lastSelectedKey)) {
        return;
    }
    if (this.lastSelectedKey === '') {
        return;
    }
    if (this.data.length == 0) {
        return;
    }
    if (!this.data[0]['SF_KEY']) {
        return;
    }

    var serverIndex = 0;
    var record = null;
    for (var i = 0, l = this.data.length; i < l; i++) {
        if (this.lastSelectedKey === this.data[i]['SF_KEY']) {
            serverIndex = i + 1;
            break;
        }
    }
    record = table.querySelector(
        "tbody[data-record-number='" + serverIndex + "']"
    );
    if (!record) {
        return;
    }
    Subfile.handleRowFocus(record);

    const fieldToFocus = record.querySelector('[tabindex]'); //POM-3969
    if (fieldToFocus) {
        SESSION.activePage.cursorFocus = fieldToFocus.id;
    }
};

Subfile.prototype.updateRecord = function (record, serverIndex) {
    var obj = null,
        value = '',
        rowSelectorDisplay = null;
    var dataRecord = this.data[this.index];
    var trs = record.getElementsByTagName('TR');
    var rowSelector = record.querySelector('[data-rowselector]');
    var restButton = record.querySelector('[data-reset-record]');
    var keyField = record.querySelector("[data-axis='SFL_KEY']");
    var fields = record.querySelectorAll('[data-value-from-id]');
    var valueFromId = '';
    if (keyField) {
        keyField.id = 'SFL_A_' + serverIndex;
        keyField.setAttribute('data-record-number', serverIndex); //keyField.setAttribute("data-line", this.startLine + this.index);
    }

    record.id = record.id.replace('#SflRcdNbr', serverIndex);
    record.setAttribute('data-record-number', serverIndex);

    if (restButton) {
        restButton.setAttribute('data-reset-record', serverIndex);

        restButton.id = restButton.id.replace('#SflRcdNbr', serverIndex);

        value = dataRecord['SF_STS'];
        restButton.setAttribute('data-subfile-state', value);
    }

    for (var i = 0, l = trs.length; i < l; i++) {
        obj = trs[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
    }

    for (var i = 0, l = fields.length; i < l; i++) {
        obj = fields[i];
        obj.setAttribute('data-record-number', serverIndex);
        valueFromId = obj.getAttribute('data-value-from-id');

        if (!valueFromId) {
            continue;
        }
        value = dataRecord[valueFromId];
        if (!hasValue(value)) {
            value = '*--*';
        }

        XDOM.setObjectValue(obj, value, this);
    }

    //verplaatst naar this.selectSFKey omdat de regel nu moet zijn gerenderd voor dat er de focus op kan komen
    //	if(hasValue(this.lastSelectedKey) && this.lastSelectedKey !== ""){
    //		if(hasValue(dataRecord["SF_KEY"]) && (this.lastSelectedKey === dataRecord["SF_KEY"])){
    //			Subfile.handleRowFocus(record);
    //		}
    //	}

    if (rowSelector) {
        //zet aan of uit
        rowSelector.id = rowSelector.id.replace('#SflRcdNbr', serverIndex);
        rowSelector.name = rowSelector.name.replace('#SflRcdNbr', serverIndex);
        rowSelectorDisplay = rowSelector.parentNode.querySelector(
            'input[type="button"]'
        );
        if (this.selectedRecords[this.data[serverIndex - 1].SF_KEY]) {
            rowSelector.value = 'SLT';
        } else {
            rowSelector.value = '';
        }
        Logical.updateState(rowSelector, rowSelectorDisplay);
    }
};

Subfile.prepareDom = function () {
    var tableObject = XDOM.getObject('SFLTBL');
    var clearSelectionChc = XDOM.getObject('clearSelection');
    if (tableObject) {
        SESSION.activePage.subfile = new Subfile('SFLTBL');
        SESSION.activePage.subfile.prepareDom();
        Subfile.setHeaderBodyRef('');
        Subfile.fixHeaderLogical('');
    }

    //set remove complete selection title
    if (clearSelectionChc) {
        GUI.infoTitle.register(clearSelectionChc, getCapt('cCLEARSELECTION'));
    }
};

Subfile.clear = function () {
    if (!SESSION.activePage.subfile) {
        return;
    }

    SESSION.activePage.subfile.clear();
};

Subfile.update = function () {
    if (SESSION.activePage.subfile) {
        SESSION.activePage.subfile.updateColumnHeading(XDOM.getObject('COLHDGTBL'));
        SESSION.activePage.subfile.update();

        if (SESSION.activePage.subfileSelectionCount) {
            Logical.setLogicalCounter(
                SESSION.activePage.subfileSelectionCount.SelectionCount
            );
        }
    }
};

Subfile.setScrollPos = function(){
    if(!SESSION.activePage.subfile) return;
    if (SESSION.activePage.macroSwitch.macroStackCode == 'BWD' ||
        ['*PMT_ML', '*RGS', '*UPD_ML'].includes(SESSION.activePage.macroType)) {
        Subfile.restoreSubfilePos();
    } else {
        SESSION.activePage.subfile.scrollToTop()
    }
}

Subfile.getEventRecordNr = function (obj) {
    var recordNumber = parseInt(obj.getAttribute('data-record-number'));
    var recordObject = obj;
    if (!recordNumber) {
        if (recordObject.eventObjectTAG !== 'TBODY') {
            recordObject = XDOM.getParentByTagName(recordObject, 'TBODY');
        }
        if (
            !recordObject ||
            !recordObject.id ||
            recordObject.id.indexOf('SFL_RCD') === -1
        ) {
            return null;
        }
        recordNumber = recordObject.id.replace('SFL_RCD', '');
    }
    return recordNumber;
};

Subfile.focusFirstInput = function (obj) {
    var progression = fp.get(obj);
    progression.first();
};
Subfile.handleRowFocus = function (obj) {
    var rowObject = null;
    var tbody = null;
    var subfileBody = null;
    var currentSelectedRecord = null;

    if (obj) {
        rowObject = XDOM.getParentByTagName(obj, 'TBODY');
    } else {
        rowObject = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TBODY');
    }

    if (rowObject) {
        tbody = XDOM.getParentByTagName(rowObject, 'TBODY');
        if (tbody) {
            subfileBody = tbody.parentNode;

            currentSelectedRecord = subfileBody.querySelector(
                "[data-record-selected='true']"
            );
            if (currentSelectedRecord !== null) {
                currentSelectedRecord.setAttribute('data-record-selected', 'false');
            }

            tbody.setAttribute('data-record-selected', 'true');

            if (SESSION.activePage.subfile) {
                SESSION.activePage.subfile.highlightedRecord = tbody.id;
            }
        }
    }
};

Subfile.handleRowBlur = function (obj) {
    var rowObject = null;
    var tbody = null;
    if (!SESSION.activePage) {
        return;
    }
    if (obj) {
        rowObject = XDOM.getParentByTagName(obj, 'TBODY');
    } else {
        rowObject = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TBODY');
    }

    if (SESSION.activePage.subfile) {
        SESSION.activePage.subfile.highlightedRecord = null;
    }

    if (rowObject) {
        tbody = XDOM.getParentByTagName(rowObject, 'TBODY');
        if (tbody) {
            tbody.setAttribute('data-record-selected', 'false');
        }
    }
};

Subfile.selectRow = function (obj) {
    var rowObject = obj;
    var recordNr = Subfile.getEventRecordNr(rowObject);

    if (!recordNr) {
        return;
    }
    Subfile.handleRowFocus(rowObject);
};

Subfile.deselectRow = function () {
    //	var rowObject = GLOBAL.eventSourceElement;
    //	var rowBody		= null;
    //  var recordNr 	= Subfile.getEventRecordNr(rowObject);
    //
    //  rowBody = XDOM.getObject('SFL_RCD' + recordNr);
    //  if (!rowBody) {return;}

    Subfile.handleRowBlur();
};

Subfile.prototype.closeTopView = function (obj, returnFields, returnTargetFields ) {
    var dataFields = returnFields || [];
    var returnCallerFields = returnTargetFields || [];
    var recordNumber = getClientRecordNr(obj);
    var record = this.data[recordNumber];
    var returnValuesArray = [];
    for (var i = 0, l = dataFields.length; i < l; i++) {
        returnValuesArray[i] = {
            targetObject: returnCallerFields[i],
            targetValue: record[dataFields[i]]
        };
    }
    if (TopView.currentInstance) {
        TopView.currentInstance.close(returnValuesArray, true);
    }
};

Subfile.prototype.closeSearch = function (obj) {
    var dataFields = obj.getAttribute('data-subfile-return-to-caller').split(' ');
    var recordNumber = getClientRecordNr(obj);
    var record = this.data[recordNumber];
    var returnValues = [];
    for (var i = 0, l = dataFields.length; i < l; i++) {
        returnValues.push(record[dataFields[i]]);
    }
    Search.close(returnValues);
};

Subfile.prototype.navigate = function (obj) {
    var hasTarget = false;
    var recordNumber = getClientRecordNr(obj);
    var record = this.data[recordNumber];
    var formatCode = record[obj.getAttribute('data-subfile-format-field')];

    if (SESSION.submitInProgress) {
        return;
    }

    if (formatCode === '') {
        //setMessage('S', gPRC001);
        return false;
    }

    hasTarget = SESSION.stack.setSubfileTargetFields(
        recordNumber,
        formatCode,
        null,
        SESSION.activePage
    );
    if (!hasTarget) {
        //setMessage('S', gPRC001);
        return false;
    }
    window.onbeforeunload = null;

    //sla de subfile postitie op ivm met terug keren naar ML
    Subfile.storeSubfilePos();
    Command.submit(true);
    return true;
};

/**
 * Activate Selected record
 *
 * @param {obj} obj
 */
Subfile.prototype.selectRecord = function (obj) {
    var recordNumber = getClientRecordNr(obj);
    var record = this.data[recordNumber];
    var key = record['SF_KEY'];
    var radioButtonOn = obj.querySelector('[data-radio]');
    var radioButtonOff = XDOM.queryScope("[data-radio='on']");
    if (radioButtonOff) {
        radioButtonOff.setAttribute('data-radio', 'off');
    }
    XDOM.createInputField('SF_KEY', key);
    XDOM.createInputField('SelectedSubfileRecord', scriptToServer(recordNumber));
    XDOM.createInputField('WS_CMD', 'SELECT');
    radioButtonOn.setAttribute('data-radio', 'on');
    Subfile.storeSubfilePos();
    Command.submit();
};

/**
 * als in het srcElement (in dit geval een td) een input element van het type
 * checkbox of radio zit wordt een onclick op dit element uitgevoerd en wordt
 * het event verder gecanceld in dat geval wordt true geretourneerd zodat de
 * aanroepende functie (SFLACN.ACTSUBPGM) kan worden afgebroken
 *
 * @returns {boolean}
 */
Subfile.bubbleToInput = function () {
    var inputs = [],
        divs = [];
    var parent = null;

    if (
        GLOBAL.eventSourceElement.tagName === 'TD' ||
        GLOBAL.eventSourceElement.tagName === 'TH'
    ) {
        parent = GLOBAL.eventSourceElement;
    }
    if (!parent) {
        parent = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TH');
    }
    if (!parent) {
        parent = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TH');
    }

    if (!parent) {
        return false;
    }

    inputs = parent.getElementsByTagName('INPUT');

    if (inputs.length > 0) {
        XDOM.invokeClick(inputs[0]);
        return true;
    }

    //  divs = parent.querySelectorAll("[data-to-id]");
    //  if (divs.length > 0) {
    //    XDOM.invokeClick(divs[0]);
    //    return true;
    //  }
    return false;
};

/*
 * Positioneer subfile zo dat actief record in zichtbare deel van de subfile
 * staat
 */
Subfile.setCursor = function () {
    var fsKey = XDOM.getObjectValue('WS_KEY');

    var foInp = XDOM.getObject(fsKey);
    if (!foInp) {
        return;
    }

    foInp.scrollIntoView(true);
};

Subfile.setChanged = function (fiRecordNumber) {
    var foIndicatorDiv, FoIndicatorField;
    if (!fiRecordNumber) {
        return;
    } // -->>
    foIndicatorDiv = XDOM.getObject('UPDSTS_' + fiRecordNumber);
    if (!foIndicatorDiv) {
        return;
    } // -->>
    FoIndicatorField = XDOM.getObject('SF_STS_' + fiRecordNumber);
    //foIndicatorDiv.innerHTML = '&nbsp;';
    //foIndicatorDiv.className = 'stschg';
    foIndicatorDiv.setAttribute('data-subfile-state', 'CC');
    FoIndicatorField.value = 'P';
};

Subfile.handleKeyDown = function () {
    if (
        XDOM.GLOBAL.getAttribute('data-axis') === 'SFL_KEY' &&
        GLOBAL.charCode === keyCode.enter
    ) {
        Subfile.handleOnClick();
        XDOM.cancelEvent();
        return true;
    }
    return false;
};
/**
 *
 * @returns {undefined}
 */
Subfile.handleOnClick = function () {
    //check to see if there is a submit going on.
    if (SESSION.submitInProgress)  return;
    var body = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TBODY');
    var selectedRow = null;
    if (!body) {
        return;
    }
    var clickAction = body.getAttribute('data-subfile-clickable');

    if (
        SESSION.activePage.subfile &&
        SESSION.activePage.subfile.highlightedRecord
    ) {
        selectedRow = XDOM.getObject(SESSION.activePage.subfile.highlightedRecord);
    }

    if (Subfile.bubbleToInput()) {
        return;
    }

    if (XDOM.GLOBAL.getAttribute('data-reset-record')) {
        Subfile.resetRecord();
        return;
    }

    if (GLOBAL.eventSourceElement.tagName === 'INPUT') {
        return;
    }

    switch (clickAction) {
        case '*QUERYLIST':
            QueryList.handleOnClick(body);
            Subfile.handleRowFocus(body);
            break;
        case '*MULTISELECT':
            MultiSelect.handleOnClick(body);
            break;
        case '*NAVIGATE':
            //check of we in een topview zitten en dus zonder stack.
            if (TopView.currentInstance && SESSION.isSingleView) {
                //sluit de topview en geef de paramaters mee terug.
                SESSION.activePage.subfile.closeTopView(
                    body,
                    SESSION.activePage.returnToCaller,
                    TopView.currentInstance.returnTargetFields
                );
            } else {
                //check of er een achterliggende macro is.
                if (!SESSION.activePage.subfile.navigate(body)) {
                    //check of er een triggerfield is.
                    if (!Subfile.activateTriggers(body)) {
                        //doe niets en geef een melding
                        setMessage('S', getCapt('gPRC001'));
                        return;
                    }
                }
            }
            break;
        case '*TRIGGER':
            //start trigger
            Subfile.activateTriggers(body);
            break;
        case '*SELECT_RECORD':
            SESSION.activePage.subfile.selectRecord(body);
            break;
        case '*CLOSE_SEARCH':
            SESSION.activePage.subfile.closeSearch(body);
            break;
    }

    if (selectedRow) {
        Subfile.handleRowBlur(selectedRow);
    }

    Subfile.handleRowFocus(body);
};

Subfile.resetRecord = function () {
    SESSION.activePage.subfile.resetRecord();
};

Subfile.prototype.resetRecord = function () {
    var index = XDOM.GLOBAL.getAttribute('data-reset-record');
    var record = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TBODY');
    var obj = null,
        value = '',
        fieldName = '',
        type = '';
    var inputs = record.getElementsByTagName('input');
    GLOBAL.eventSourceElement.setAttribute('data-subfile-state', '');

    var dataRecord = this.data[serverToScript(index)];
    XDOM.setObjectValue('SF_STS_' + index, '');
    for (var i = 0, l = inputs.length; i < l; i++) {
        obj = inputs[i];
        fieldName = obj.name.replace('_ENT_' + index, '_DBF');
        value = dataRecord[fieldName];
        type = obj.getAttribute('data-datatype');
        if (type !== '*MASK' && type !== '*SYSTEM' && obj.type !== 'button') {
            if (!hasValue(value)) {
                continue;
                value = '*--*';
            }

            XDOM.setObjectValue(obj, value);
        }
    }
};

/**
 * slaat positie van de subfile op
 */
Subfile.storeSubfilePos = function () {
    var foSubfile = XDOM.getObject('SFL');
    if (!foSubfile) {
        return;
    } //-->

    var foSettings = Subfile.getProgramSettings();
    foSettings.subfilePos = foSubfile.scrollTop;
};
/**
 * zet de subfile in de positie die is opgeslagen door storeSubfilePos
 */
Subfile.prototype.scrollToTop = function () {

    var foSubfile = XDOM.getObject('SFL');
    if (!foSubfile) {
        return;
    } //-->

    //we are extending the subfile so don't scroll to top
    if(this.doNotScroll) {
        //reset this
        this.doNotScroll = false;
        return;
    }
    foSubfile.scrollTop = 0;
};


/**
 * zet de subfile in de positie die is opgeslagen door storeSubfilePos
 */
Subfile.restoreSubfilePos = function () {
    var foSubfile = XDOM.getObject('SFL');
    if (!foSubfile) {
        return;
    } //-->
    var foSettings = Subfile.getProgramSettings();
    foSubfile.scrollTop = foSettings.subfilePos;
};

/**
 * geeft huidige programma instellingen terug als deze niet bestaat wordt een initiele lege settings terug gegeven
 * @returns
 */
Subfile.getProgramSettings = function () {
    var foSettings = SESSION.program[SESSION.activePage.programName];
    if (!foSettings) {
        foSettings = {};
        foSettings.subfilePos = 0;
    }
    SESSION.program[SESSION.activePage.programName] = foSettings;
    return foSettings;
};

Subfile.activateTriggers = function (foRecord) {
    var faAxises = foRecord.querySelectorAll('[data-axis]');
    var faTriggers = [];
    var faAxistriggers = null;
    var foAxis = null;
    var fsAxis = '';
    var fbRet = false;
    var recordNr = null;

    for (var i = 0, l = faAxises.length; i < l; i++) {
        foAxis = faAxises[i];
        fsAxis = foAxis.getAttribute('data-axis');
        faAxistriggers = SESSION.activePage.triggers[fsAxis];
        if (faAxistriggers) {
            Trigger.setAxisField(foAxis);
            for (var caller in faAxistriggers) {
                faTriggers[caller] = faAxistriggers[caller];
            }
            fbRet = true;
        }
    }

    for (var t in faTriggers) {
        faTriggers[t].execute();
    }

    if (fbRet) {
        recordNr = foRecord.getAttribute('data-record-number');
        if (recordNr !== null) {
            Trigger.fillIPMF(recordNr);
        }
    }

    return fbRet;
};

/**
 * bereid de een record uit een subfile voor
 * @param {type} record
 * @param {type} serverIndex
 * @returns {void}
 */
Subfile.prototype.updateInfoWindow = function (record, serverIndex) {
    var obj = null;
    var InfoWindows = record.querySelectorAll('[data-info-id]');
    for (var i = 0, l = InfoWindows.length; i < l; i++) {
        obj = InfoWindows[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);
        //check;
        obj.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
        obj.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
        obj.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
        XDOM.addEventListener(obj, 'mouseover', handleMouseOver);
        XDOM.addEventListener(obj, 'mouseout', handleMouseOut);
    }
};

Subfile.prototype.updateRadio = function (record, serverIndex) {
    var radioButton = record.querySelector('[data-radio]');
    if (!radioButton) {
        return;
    }
    var dataRecord = this.data[this.index];
    var sfKey = dataRecord['SF_KEY'];
    var wsKey = SESSION.activeData.headerData['WS_KEY'];

    radioButton.id = radioButton.id.replace('#SflRcdNbr', serverIndex);
    if (sfKey === wsKey) {
        radioButton.setAttribute('data-radio', 'on');
    }
};

/**
 *  bereid de een record uit een subfile voor
 * @param {type} record
 * @param {type} serverIndex
 * @returns {void}
 */
Subfile.prototype.updateQuickSearch = function (record, serverIndex) {
    var InfoWindows = record.querySelectorAll('[data-quicksearch-id]');
    var to = null;
    var qsId = '';
    var axis = '';
    var obj = null;


    for (var i = 0, l = InfoWindows.length; i < l; i++) {

        obj = InfoWindows[i];
        obj.addEventListener('click', QuickSearch.handleOnClick, false);
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);
        qsId = obj.getAttribute('data-quicksearch-id');
        obj.setAttribute('data-quicksearch-id', qsId + '_' + serverIndex);
        axis = obj.getAttribute('data-to-id');

        obj.setAttribute('data-to-id', axis + '_' + serverIndex);

        to = record.querySelector('[data-axis="' + axis + '"]');

        QuickSearch.prepareDomObj(obj, to);
    }
};

//POM-3545
Subfile.prototype.updateSessionLauncher = function (record, serverIndex) {
    const launchers = record.querySelectorAll('[data-new-session-id]'),
        dataRecord = this.data[this.index];

    for (let i = 0, l = launchers.length; i < l; i++) {
        let launcher = launchers[i];
        launcher.dataset.recordNumber = serverIndex;
        if (launcher.dataset.newSessionEnvironmentFieldId) {
            launcher.dataset.newSessionEnvironment =
                dataRecord[launcher.dataset.newSessionEnvironmentFieldId];
            NAV.sessionLauncher.authorize(launcher);
        }
    }
};
// Subfile.prototype.updateSessionLauncher= function(record,serverIndex){
//   const launchers = record.querySelectorAll("[data-new-session-environment-field-id]"),
//         dataRecord = this.data[this.index];

//   for(let i = 0, l=launchers.length; i<l; i++) {
//     let launcher = launchers[i];
//     launcher.dataset.recordNumber=serverIndex
//     launcher.dataset.newSessionEnvironment = dataRecord[launcher.dataset.newSessionEnvironmentFieldId] ;
//     NAV.sessionLauncher.authorize(launcher);
//   };
// };

Subfile.prototype.updateDataAttribute = function (record, serverIndex) {
    var nodelist = record.querySelectorAll(
        '[data-left-zero],[data-value-when-zero],[data-left-blank],[data-to-upper],[data-digits]'
    );
    [...nodelist].forEach(obj => DataAttribute.apply(obj));
};

Subfile.prototype.updateFieldAttribute = function (record, serverIndex) {
    var obj = record.querySelectorAll('[data-protected]');
    for (var i = 0, l = obj.length; i < l; i++) {
        FieldAttribute.protect(obj[i]);
    }
};

//Subfile.prototype.updateConditionalAttributes = function(record,serverIndex){
//  return;
//  var obj = null;
//  var data = this.attributes[this.index];
//	var conditionalObjects = XDOM.queryAll('[data-condition-attribute]');
//
//  for(var i=0,l=conditionalObjects.length;i<l;i++){
//    obj = conditionalObjects[i];
//		ConditionalAttribute.apply(obj,data);
//	}
//};

Subfile.prototype.updateWhen = function (record, serverIndex) {
    var whenObjects = record.querySelectorAll('[data-when-field]');
    var obj = null,
        field = '',
        value = '';
    var data = this.attributes[this.index];
    for (var i = 0, l = whenObjects.length; i < l; i++) {
        obj = whenObjects[i];
        value = obj.getAttribute('data-when-value');
        field = obj.getAttribute('data-when-field');
        if (value !== data[field]) {
            When.set(obj, 'unavailable');
        } else {
            When.set(obj, 'available');
        }
    }
};

Subfile.prototype.updateAttentionLevel = function (record, serverIndex) {
    var attentionLevelObjects = record.querySelectorAll(
        '[data-attention-field-id]'
    );
    var obj = null;
    for (var i = 0, l = attentionLevelObjects.length; i < l; i++) {
        obj = attentionLevelObjects[i];
        AttentionLevel.apply(obj);
    }
};

Subfile.prototype.updateTopview = function (record, serverIndex) {
    var topViewDivs = record.querySelectorAll('[data-topview-parm-names]');
    var axis = '',
        obj = null;

    for (var i = 0, l = topViewDivs.length; i < l; i++) {
        obj = topViewDivs[i];
        obj.setAttribute('data-record-number', serverIndex);
        axis = obj.getAttribute('data-to-id');
        obj.setAttribute('data-to-id', axis + '_' + serverIndex);
        parmFields = obj.getAttribute('data-topview-parm-fields').split(' ');
        obj.setAttribute(
            'data-topview-parm-fields',
            parmFields.map(field => field + '_' + serverIndex).join(' ')
        );
    }
};

Subfile.prototype.updateSearch = function (record, serverIndex) {
    var searchDivs = record.querySelectorAll('[data-search-id]');
    var axis = '',
        obj = null;

    for (var i = 0, l = searchDivs.length; i < l; i++) {
        obj = searchDivs[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);
        axis = obj.getAttribute('data-to-id');
        obj.setAttribute('data-to-id', axis + '_' + serverIndex);
    }
};

Subfile.prototype.updateService = function (record, serverIndex) {
    var serviceObjects = record.querySelectorAll('[data-service-type]');
    var axis = '',
        target = null,
        display = null,
        obj = null;
    var dataRecord = this.data[this.index];

    for (var i = 0, l = serviceObjects.length; i < l; i++) {
        obj = serviceObjects[i];
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-record-number', serverIndex);
        axis = obj.getAttribute('data-to-id');
        obj.setAttribute('data-to-id', axis + '_' + serverIndex);

        if (obj.getAttribute('data-service-type') === '*RTV') {
            target = record.querySelector('#' + axis + '_' + serverIndex);
            display = record.querySelector(
                "[data-to-axis='" + obj.getAttribute('data-to-axis') + "']"
            );
            Service.retriveSFL(obj, target, display, dataRecord[axis]);
        }
    }
};

Subfile.prototype.updateMask = function (record, serverIndex) {
    var maskDivs = record.querySelectorAll('[data-mask-container-for]');
    var maskParts = record.querySelectorAll('[data-mask]');
    var obj = null,
        nextPart = null;

    var maskFor = '',
        target = '',
        container = '',
        firstPart = '',
        lastPart = '';
    for (var i = 0, l = maskDivs.length; i < l; i++) {
        obj = maskDivs[i];
        maskFor = obj.getAttribute('data-mask-container-for');
        maskFor = maskFor.replace('#SflRcdNbr', serverIndex);
        obj.setAttribute('data-mask-container-for', maskFor);
        obj.id = obj.id.replace('#SflRcdNbr', serverIndex);
    }

    for (var i = 0, l = maskParts.length; i < l; i++) {
        obj = maskParts[i];
        target = obj.getAttribute('data-mask-target');
        if (target) {
            // niet target object
            target = target.replace('#SflRcdNbr', serverIndex);
            obj.setAttribute('data-mask-target', target);
            container = obj.getAttribute('data-mask-target');
            container = container.replace('#SflRcdNbr', serverIndex);
            obj.setAttribute('data-mask-container', container);
        }

        nextPart = obj.getAttribute('data-nextMask-part');
        if (nextPart) {
            // niet target object
            nextPart = nextPart.replace('#SflRcdNbr', serverIndex);
            obj.setAttribute('data-nextMask-part', nextPart);
        }

        lastPart = obj.getAttribute('data-mask-last-part');
        //target object
        if (lastPart) {
            firstPart = obj.getAttribute('data-mask-first-part');
            lastPart = lastPart.replace('#SflRcdNbr', serverIndex);
            firstPart = firstPart.replace('#SflRcdNbr', serverIndex);
            obj.setAttribute('data-mask-first-part', firstPart);
            obj.setAttribute('data-mask-last-part', lastPart);
        }
        obj.setAttribute('data-record-number', serverIndex);
    }
};

/* dragdrop */
/* Load Timestamp 13:59:55.631 */
/* global GLOBAL, XDOM */

var Dragger = function(){};

Dragger.start = function(obj){
    var id = obj.getAttribute("data-dragger-objId");
    Dragger.dragDrop.moveThisObject = XDOM.getObject(id);
    if(!Dragger.dragDrop.moveThisObject){
        Dragger.dragDrop.moveThisObject = obj;
    }

    Dragger.dragDrop.startDragMouse();

    XDOM.cancelEvent();
};

Dragger.dragDrop = {

    moveThisObject: undefined,
    dragHandlerObject: undefined,
    initialMouseX: undefined,
    initialMouseY: undefined,
    startX: undefined,
    startY: undefined,
    dXKeys: undefined,
    dYKeys: undefined,
    draggedObject: undefined,
    dockable:false,

    startDragMouse: function () {

        Dragger.dragDrop.startDrag(Dragger.dragDrop.moveThisObject);

        Dragger.dragDrop.initialMouseX = GLOBAL.eventObject.clientX;
        Dragger.dragDrop.initialMouseY = GLOBAL.eventObject.clientY;
        XDOM.addEventListener(SESSION.activeFrame.document,'mousemove',Dragger.dragDrop.dragMouse);
        XDOM.addEventListener(SESSION.activeFrame.document,'mouseup',Dragger.dragDrop.releaseElement);
        XDOM.addEventListener(SESSION.activeFrame.document,'onmouseout',Dragger.dragDrop.releaseElement);

        return false;
    },
    startDrag: function (obj) {
        if (Dragger.dragDrop.draggedObject) {
            Dragger.dragDrop.releaseElement();
        }

        //Dragger.dragDrop.dockable =obj.dataset.dockable;
        Dragger.dragDrop.startX = obj.offsetLeft;
        Dragger.dragDrop.startY = obj.offsetTop;
        Dragger.dragDrop.draggedObject = obj;

        // if(Dragger.dragDrop.dockable){
        //   docker.unDock(Dragger.dragDrop.draggedObject);
        // }

        obj.className += ' dragged';


    },
    dragMouse: function (e) {
        var evt = e || window.event;

        XDOM.getEvent(evt);

        var fiX = GLOBAL.eventObject.clientX - Dragger.dragDrop.initialMouseX;
        var fiY = GLOBAL.eventObject.clientY - Dragger.dragDrop.initialMouseY;
        Dragger.dragDrop.setPosition(fiX,fiY);
        // if(Dragger.dragDrop.dockable){
        //docker.show(Dragger.dragDrop.draggedObject);
        //}
        return false;
    },
    setPosition: function (fiX,fiY) {
        if(!Dragger.dragDrop.draggedObject){
            return;
        }
        Dragger.dragDrop.draggedObject.style.left = Dragger.dragDrop.startX + fiX + 'px';
        Dragger.dragDrop.draggedObject.style.top = Dragger.dragDrop.startY + fiY + 'px';
        Dragger.dragDrop.draggedObject.style.marginTop  = '0px'; //na drag en drop wordt deze eigenschap mee gerekend in de positie
        var newYpos = Dragger.dragDrop.draggedObject.style.top.substr(0, Dragger.dragDrop.draggedObject.style.top.length-2);
        var containerHeight = XDOM.getObject("DTADIV").offsetHeight - 25;


        if((newYpos) < 0){
            Dragger.dragDrop.draggedObject.style.top = '0px';
        }

        if((newYpos) > containerHeight){
            Dragger.dragDrop.draggedObject.style.top = containerHeight+'px';
        }


    },
    releaseElement: function() {

        XDOM.removeEventListener(SESSION.activeFrame.document,'mousemove',Dragger.dragDrop.dragMouse);
        XDOM.removeEventListener(SESSION.activeFrame.document,'mouseup',Dragger.dragDrop.releaseElement);
        XDOM.removeEventListener(SESSION.activeFrame.document,'onmouseout',Dragger.dragDrop.releaseElement);
        if(Dragger.dragDrop.draggedObject){
            Dragger.dragDrop.draggedObject.className = Dragger.dragDrop.draggedObject.className.replace(/dragged/,'');
            Dragger.dragDrop.draggedObject = null;
        }
    }

};

/* dragger */
/* Load Timestamp 13:59:55.632 */
const drag = {};

(function() {
    let type = '',
        allowDrop = '';
    (dropAction = ''), (objToMove = ''), (mouseStartX = 0), (mouseStartY = 0), (objToMoveX = 0), (objToMoveY = 0);

    function move() {
        const moveX = GLOBAL.eventObject.clientX - mouseStartX,
            moveY = GLOBAL.eventObject.clientY - mouseStartY;
        if (!objToMove) {
            return;
        }
        objToMove.style.left = objToMoveX + moveX + 'px';
        objToMove.style.top = objToMoveY + moveY + 'px';
    }

    function createDropZone() {
        if (type != 'panel') {
            return;
        }
        let dropzone = XDOM.getObject('propPanel');
        const dtaDiv = XDOM.getObject('DTADIV');
        zIndex = parseInt(objToMove.style.zIndex) - 1;
        if (!dropzone) {
            (dropzone = XDOM.createElement('DIV', 'propPanel')), dtaDiv.appendChild(dropzone);
        }
        dropzone.style.zIndex = zIndex;
    }

    function start(e) {
        XDOM.getEvent(e);
        type = GLOBAL.dataset.dragtype;
        allowDrop = GLOBAL.dataset.allowDropOn;
        objToMove = XDOM.getObject(GLOBAL.dataset.dragObject);
        docker.unDock(objToMove);
        mouseStartX = GLOBAL.eventObject.clientX;
        mouseStartY = GLOBAL.eventObject.clientY;
        objToMoveX = objToMove.offsetLeft;
        objToMoveY = objToMove.offsetTop;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setDragImage(document.createElement('div'), 0, 0);
        createDropZone();
    }

    function over(e) {
        XDOM.getEvent(e);
        move();
        docker.show(objToMove);
        const dropAllowedFor = (GLOBAL.dataset.allowDrop || '').split(',');
        if (allowDrop == '*ALL' || dropAllowedFor.indexOf(type) > -1) {
            e.preventDefault();
        }
    }

    function cleanup() {
        XDOM.cancelEvent();
        XDOM.removeDOMObject('propPanel');
        objToMove = null;
    }

    function drop(e) {
        XDOM.getEvent(e);
        docker.dock(objToMove);
        cleanup();
    }
    this.cleanup = cleanup;
    this.drop = drop;
    this.over = over;
    this.start = start;
}.apply(drag));

/* docker */
/* Load Timestamp 13:59:55.632 */



const docker = {};

(function () {
    const dockOffset = 50;
    let dockPanel =  null,
        parentObj = null,
        parentWith = null;

    function init(){
        parentObj = XDOM.getObject('DTADIV');
        parentWith = parentObj.offsetWidth;
        dockPanel = XDOM.getObject("dockPanel");
        dockPanel.addEventListener("drop", drag.drop);
        dockPanel.addEventListener("dragover", drag.over);
    }

    function show(obj){
        if(!obj || !obj.dataset.dockable){
            return;
        }
        const x = GLOBAL.eventObject.clientX;
        init(obj);
        if(x<dockOffset){
            dockPanel.dataset.dock = "left";
            return;
        }

        if(x > parentWith -dockOffset ){
            dockPanel.dataset.dock = "right";
            return;
        }
        dockPanel.dataset.dock = "";
    }


    function dock(obj){
        if(!obj || !obj.dataset.dockable){
            return;
        }
        const side = dockPanel.dataset.dock;

        if(!side){return};
        saveSize(obj)
        obj.removeAttribute("style");
        obj.dataset.docked=side;
        updatePanelSort(obj);
        clear()
    }

    function clear(){
        if(dockPanel){
            dockPanel.dataset.dock = "";
        }

    }


    function saveSize(obj){
        //kopieer de style voor breedte en hoogte
        obj.dataset.orgWidth = obj.style.width;
        obj.dataset.orgHeight = obj.style.height;
    }

    function cleanup(obj){
        delete obj.dataset.docked;
        delete obj.dataset.orgWidth;
        delete obj.dataset.orgHeight;
        delete obj.dataset.docked;
    }

    function resetSize(obj){
        obj.style.width = obj.dataset.orgWidth;
        obj.style.height = obj.dataset.orgHeight;
    }

    function resetPosition(obj){
        const docked = obj.dataset.docked,
            width = parseInt(obj.dataset.orgWidth.replace('px',''));

        obj.style.top = "0px";
        if(docked == "left"){
            obj.style.left = '0px';
            return;
        }

        obj.style.left = (parentWith-width) + 'px';

    }

    function unDock(obj){
        if(!obj || !obj.dataset.dockable){
            return;
        }

        if(!obj.dataset.docked){
            return;
        }
        resetPosition(obj)
        resetSize(obj)
        cleanup(obj);
    }
    this.clear = clear;
    this.unDock = unDock;
    this.show = show;
    this.dock = dock;
}).apply(docker);





/* input */
/* Load Timestamp 13:59:55.633 */
/* global Subfile, QuickSearch, XDOM, SESSION, GLOBAL, Mask, Command, keyCode, handleFocus, handleBlur, BrowserDetect, GUI, Trigger, fp */

function INP(){}
/**
 *
 */

INP.updateDom= function(){

    INP.registerEvents(XDOM.queryAll('INPUT,TEXTAREA, A.checkbox'));
    //INP.registerEvents(XDOM.queryAll('TEXTAREA'));
};





INP.handleKeyDown =  function(){
    GLOBAL.keydownValue  = GLOBAL.eventSourceElement.value;
    GLOBAL.keydownObject = GLOBAL.eventSourceElement;
    handleNumericPoint();
};

/**
 * als een veld ongeacht zijn type auto submit is zal er altijd een
 * een autosubmit volgen als bij keyup de maximale lengte is bereikt
 * ongeacht of hij veranderd is of niet
 * Keyboard handling tbv INPUT elementen
 * @returns {Boolean}
 */
INP.handleKeyUp =  function(){
    //alles betreffende FP wordt door de FP uitgevoerd en hoeft hier dus niet te gebeuren.
    if(	GLOBAL.charCode === keyCode.tab ||
        GLOBAL.charCode === keyCode.enter ||
        GLOBAL.charCode === keyCode.shift ||
        GLOBAL.charCode === keyCode.arrowUp ||
        GLOBAL.charCode === keyCode.arrowRight ||
        GLOBAL.charCode === keyCode.arrowDown ||
        GLOBAL.charCode === keyCode.F4 ||
        GLOBAL.charCode === keyCode.F2 ||
        GLOBAL.charCode === keyCode.arrowLeft
    ){
        INP.returnToErrorField();
        return;
    }

    if(XDOM.fieldIsChanged(GLOBAL.eventSourceElement)){
        Command.resetEnter();
    }

    //ook bij het invoeren van dezelfde waarde mag er een FP uitgevoerd worden.
    if(Mask.isMask(GLOBAL.eventSourceElement)){
        SESSION.activePage.lastChangedMaskId = GLOBAL.eventSourceElement.getAttribute("data-mask-target");
    }

    if(GLOBAL.eventSourceElement.value &&
        GLOBAL.eventSourceElement.value.length >= GLOBAL.eventSourceElement.maxLength){

        if(GLOBAL.keydownObject.id === GLOBAL.eventSourceElement.id){
            var isMask = Mask.isMask(GLOBAL.eventSourceElement);
            var isLastPart =  Mask.isLastPart(GLOBAL.eventSourceElement);
            if(isMask && isLastPart){
                Mask.completeAllParts(SESSION.activePage.lastChangedMaskId);
                INP.handelTriggersAndAutoSubmits(GLOBAL.eventSourceElement, isMask, isLastPart);
            }else{
                INP.handelTriggersAndAutoSubmits(GLOBAL.eventSourceElement, isMask, isLastPart);
            }
        }
    }

};
// ***************************************************************************
// Voegt events toe aan INPUT elementen
// return: --
// ***************************************************************************
INP.registerEvents = function(foNodeList) {
    var foInp = null;
    for(var i = 0,l = foNodeList.length;i<l;i++){
        foInp=foNodeList[i];

        if(foInp.hasAttribute("data-setDefault-events") && !XDOM.getBooleanAttribute(foInp, "data-setDefault-events")){
            return;
        }

        XDOM.setAttribute(foInp, "autocomplete", "off" );
        foInp.setAttribute("data-focus-action","INP.handleOnFocus");
        foInp.setAttribute("data-blur-action","INP.handleOnBlur");

        XDOM.addEventListener(foInp, 'focus', handleFocus);
        XDOM.addEventListener(foInp, 'blur', handleBlur);
    }
    return;
};





INP.handleOnFocus = function(source = GLOBAL.eventSourceElement) {

    if(GLOBAL.eventObject.currentTarget.readOnly){
        //When the current target is readonly, we use next on the related target.
        //If we were to do this on the current target changes are it is in a field set with no focusable element.
        fp.next(GLOBAL.eventObject._event.relatedTarget);
        return;
    }
    let sourceId = source.id
    if(SESSION.submitInProgress){
        return;
    }


    if(!isIn(sourceId,['ENTER','ACCEPT','RETURN'])){
        if(SESSION.activePage.lastFocusedField != sourceId){
            source.dataset.selectAllNow = true;
        }else{
            source.dataset.selectAllNow = false;
        }

        SESSION.activePage.lastSelectedInput 	= source;
        SESSION.activePage.selectedObjectId 	= sourceId;
        SESSION.activePage.lastFocusedField = sourceId;
    }



    if(SESSION.activePage.autoSubmitInputObject){
        SESSION.activePage.autoSubmitInputObject.focus();
        SESSION.activePage.autoSubmitInputObject = null;
        return false;
    }
    if(XDOM.GLOBAL.getAttribute("data-thousand-separator")==="on"){
        GLOBAL.eventSourceElement.value=unformatThousand(source.value);
        INP.select();
    }

    Mask.handleFocus(source);
    Subfile.selectRow(source);

    if(BrowserDetect.isIE){ //fix voor select in maskers bij auto FP
        INP.select();
    }

    XDOM.setAttribute(source, "data-old-value", source.value);
    return;
};



/**
 * selecteerd het input veld als deze voor het eerst wordt benaderd
 * @param {type} obj
 */
INP.select = function(obj){

    var focusedField = null;

    if(obj){
        focusedField = XDOM.getObject(obj);
    } else {
        focusedField = GLOBAL.eventSourceElement;
    }

    if(focusedField.tagName !== 'INPUT'){return;}
    if(isHidden(focusedField)){return;}

    SESSION.activePage.lastFocusedField = focusedField.id;

    if(focusedField.type==='text' || focusedField.type==='password'){
        focusedField.select();
    }
};

INP.handleOnBlur = function(e) {
    var isChanged = false;
    if(!SESSION.activePage){
        return;
    }

    XDOM.getEvent(e);

    QuickSearch.onTargetBlur();
    Subfile.deselectRow();
    isChanged = XDOM.GLOBAL.fieldIsChanged();

    if(XDOM.GLOBAL.getAttribute("data-thousand-separator")==="on"){
        GLOBAL.eventSourceElement.value=formatThousand(GLOBAL.eventSourceElement.value);
    }

    if(Mask.handleOnBlur(GLOBAL.eventSourceElement, isChanged)){
        return;
    }

    if(isChanged){
        handleOnChange(GLOBAL.eventSourceElement);
    }

    SESSION.activePage.previousField = GLOBAL.eventSourceElement;

    return;
};

INP.focusErrorField = function(foField){
    SESSION.activePage.lastErrorField = foField;
};

INP.returnToErrorField = function(){
    var foFocusField = SESSION.activePage.lastErrorField;
    SESSION.activePage.lastErrorField = null;
    if(!foFocusField){

        return false;
    }

    GLOBAL.eventObject.remapKeyCode();
    GLOBAL.eventObject.cancel();
    XDOM.focus(foFocusField);
    return true;
};





INP.handelTriggersAndAutoSubmits = function (fsField, isMask, isLastPart){
    var foField = XDOM.getObject(fsField);
    var fsPanelId = null;
    var foEdit = null;
    var fbAutosubmit = isAutoSubmitField(foField);
    var fbIsText = (XDOM.getAttribute(foField,"data-datatype")==="*TXT");
    var fbSubmit = true;
    var fbValidMsk = true;

    //POM-2652 geen autosubmit of snelzoek als veld onveranderd blijft
    if(!XDOM.fieldIsChanged(foField)){
        if(!fbIsText){
            fp.next(foField);
        }
        return;
    }

    if (((isMask && isLastPart) || !isMask) && fbAutosubmit && !XDOM.getBooleanAttribute(foField,"data-block-autosubmit")) {
        fsPanelId = XDOM.getAttribute(foField,'data-panel-id');
        if(fsPanelId){
            Stateless.setSubviewActive(foField);
            foEdit = GUI.BasePanel.instances[fsPanelId];
            foEdit.send('ENTER',foField.id.replace(fsPanelId + '-' ,''));
            return;
        }

        if(isMask){
            fbSubmit = Mask.validateAllParts(fsField);
        }

        if(fbSubmit){
            Stateless.setSubviewActive(foField);
            SESSION.activePage.autoSubmitInputObject = foField;
            Command.enter();
            return true;
        }

        return false;

    }else if(Trigger.fire([foField.id])){
        Stateless.setSubviewActive(foField);
        return true;
    }


    // inputvelenden van het data type *txt hebben geen automatisch field progression omdat deze velden erg lang kunnen zijn en je daardoor onbedoeld het volgende veld zou kunnen overschrijven
    if((!fbAutosubmit || (isMask && !isLastPart)) && !fbIsText){

        if(isMask){
            if(!Mask.validatePart(fsField)){
                fbValidMsk = false;
            }
        }

        if(fbValidMsk){
            if(isMask){
                if(Mask.selectNextPart(foField)){
                    return false;
                }
            }
            fp.next(foField);
        }
    }
    return false;
};




/* validate */
/* Load Timestamp 13:59:55.633 */
var Validate = {};
// Validation and editing definitions
// tested for characters except those in the expression
var gaREGEXP = {};
gaREGEXP['*TXT'] = new RegExp(/[^\x20-\x7E\xA0-\xFF]/); //POM-2757 reqexp \u20AC deel is het euro teken heb ik er uit gehaald om dat euro tekens niet mogen in een TXT veld was dus new RegExp(/[^\x20-\x7E\xA0-\xFF\u20AC]/);
gaREGEXP['*MEMO'] = new RegExp(/[^\x20-\x7E\x0D\x0A\xA0-\xFF\x80]/);
gaREGEXP['*UCS2'] = new RegExp(/[\uD800-\uDFFF]/); ////====>>> \u000A\u000D OVERLEG MET MVB WAAROM GEEN ENTERS?

//zie codetabel op: https://www.ascii.cl/htmlcodes.htm
// A-Z a-z 0-9 spatie *.,-_ extra: + 2B / 2F ( 28 ) 29 # 23 : 3A ; 3B = 3D | 7C
gaREGEXP['*DTA']=new RegExp(/[^\x20\x23\x2A\x2C\x2D\x2E\x5F\x30-\x39\x41-\x5A\x61-\x7A\x23\x28\x29\x2B\x3A\x3B\x3D\x2F\x7C]/);
gaREGEXP['*DEC'] = new RegExp();
gaREGEXP['*VARDEC'] = new RegExp();
gaREGEXP['*DIG'] = new RegExp(/[^\x30-\x39\x20]/); // 0-9 en spatie
gaREGEXP['*DIGITS']=new RegExp(/^[ ]*?[0-9]*[ ]*?$/);  //0-9 voor en achter spaties
gaREGEXP['*ALPHANUM'] = new RegExp(/[^a-zA-Z0-9 ]/); //niet (^) a-z of A-Z of 0-9 of " " (spatie)
gaREGEXP['*QUARTER'] = new RegExp(/[^1-4]/); // 1-4
gaREGEXP['*ALPHA'] = new RegExp(/^[a-zA-Z ]+$/);  //0-9 voor en achter spaties
//gaREGEXP['*ALPHA'] = new RegExp(/^[ ]*?[a-zA-Z]*[ ]*?$/); // a tm z en A tm Z
gaREGEXP['*QUICKSEARCH']=new RegExp(/[^\xC0-\xFF\x20\x21\x22\x23\x2A\x2C\x2D\x2E\x5F\x30-\x5A\x61-\x7A\x23\x26\x28\x29\x2B\x3A\x3B\x3D\x2F\x7C\xB4]/);

Validate.test = function(id){

    var obj = XDOM.getObject(id);

    var value = "";
    if(obj.value != null){
        value = obj.value;
    }

    var returnValue = null;

    if(!value || value.trim()=='' || obj.type == 'hidden'){
        return true;
    }
    switch(XDOM.getAttribute(obj,"data-datatype")){
        case "*MEMO":
            returnValue = TextArea.validate(obj);
            if(returnValue){
                returnValue = Validate.memo(obj);
            }
            return returnValue;

            break;
        case "*MASK":
            return Validate.mask(obj);
            break;
        case "*QUICKSEARCH":
            return Validate.quickSearch(obj);
            break;
        case '*DEC':
            return Validate.dec(obj);
            break;
        case '*DTA':
            return Validate.data(obj);
            break;
        case '*TXT':
        case '*PWD':
            return Validate.text(obj);
            break;
    }
    return true;
};



Validate.handleError = function (message, obj){
    panel = XDOM.getEditWindow(obj);
    if(panel){
        panel.footer.setMessage('F',message);
    }else{
        setMessage('F',message);
    }
    INP.focusErrorField(obj);
};

Validate.getDecimalPatern = function(signed, thousandSeparator, intLength, decimalLength){
    var patern = '';
    if(signed){
        patern = "(-)";
    }
    if(thousandSeparator){
        for(var i=0;i<intLength;i++){
            if(i%3==0 && i!=intLength && i>0){
                patern = SETTINGS.thousandSeparator + patern;
            }
            patern ='#' + patern;
        }
    }else{
        patern +='#'.times(intLength);
    }


    if(decimalLength > 0){
        patern +=',' + '#'.times(decimalLength);
    }
    return patern;
};

Validate.mask = function(obj){
    var message = '';
    if (!Mask.isValidPart(obj)) {
        message = Mask.getErrorMessage(obj);
        Validate.handleError(message,obj);
        return false;
    }
    return true;
};

Validate.quickSearch = function(obj){

    var regEx = null;
    var value = '';
    var pos =null;
    var character = '';
    var msg = '';
    var returnObj = { succeed: true, message: "" }
    value = obj.value;

    regEx = gaREGEXP['*QUICKSEARCH'];

    if(regEx.test(value)) {
        pos = value.search(regEx);
        character = value.substring(pos, pos+1);
        msg = getCapt('gVLD003') + character + getCapt('gVLD004');
        returnObj.succeed = false;
        returnObj.message = msg;
        return returnObj;
    }

    return returnObj;
};


Validate.data = function(obj){

    var regEx = null;
    var value = '';
    var pos =null;
    var character = '';

    value = obj.value;

    //controleer op voorloop spaties
    if (!XDOM.getBooleanAttribute(obj,"data-left-blank") && value.indexOf(' ')==0){
        Validate.handleError(getCapt('gVLD008'),obj);
        return false;
    }

    if(XDOM.getBooleanAttribute(obj,"data-digits")){
        return Validate.digits(obj);
    }

    if(XDOM.getBooleanAttribute(obj,"data-alpha")){
        return Validate.alpha(obj);
    }

    regEx = gaREGEXP['*DTA'];

    if(regEx.test(value)) {
        pos = value.search(regEx);
        character = value.substring(pos, pos+1);
        message = getCapt('gVLD003') + character + getCapt('gVLD004');
        Validate.handleError(message,obj);
        return false;
    }

    return true;
};

Validate.digits = function(obj){
    var regEx = gaREGEXP['*DIGITS'];
    if (!regEx.test(obj.value)){
        Validate.handleError(getCapt('gVLD007'),obj);
        return false;
    }
    return true;
};

Validate.UCS2 = function(obj){
    var regEx = gaREGEXP['*UCS2'];
    var message = "";
    var pos = null;
    var character = null;
    var charString = null;

    if (regEx.test(obj.value)){
        pos = obj.value.search(regEx);
        character  = obj.value.substring(pos, pos+1);
        charString = Validate.getInvalidKey(character);
        message = getCapt('gVLD003') + charString + getCapt('gVLD004');

        Validate.handleError(message,obj);
        return false;
    }
    return true;
};

Validate.alpha = function(obj){
    var regEx = gaREGEXP['*ALPHA'];
    if (!regEx.test(obj.value)){
        Validate.handleError(getCapt('gVLD009'),obj);
        return false;
    }
    return true;
};


Validate.text = function(obj){
    var regEx = null;
    var value = '', pos=null, character= '';

    regEx = gaREGEXP['*TXT'];
    value = obj.value;

    if(XDOM.getBooleanAttribute(obj,"data-unicode")){
        return Validate.UCS2(obj);
    }

    if (regEx.test(value)) {
        pos=value.search(regEx);
        character=value.substring(pos, pos+1);
        message = getCapt('gVLD003') + character + getCapt('gVLD004');
        Validate.handleError(message,obj);
        return false;
    }

    if(obj.getAttribute("data-to-upper")=='true'){
        value = value.toUpperCase()
    }

    if(!obj.maxLength){
        return true;
    }

    if(value.length <= parseInt(obj.maxLength)){
        return true;
    }
    Validate.handleError(getCapt('gVLD010') + obj.maxLength + getCapt('gVLD011') ,obj);
    return false
};

Validate.memo = function(obj){
    var regEx = null;
    var value = '', pos=null, character= '';
    var charString = "";
    regEx = gaREGEXP['*MEMO'];
    value = obj.value;

    if(XDOM.getBooleanAttribute(obj,"data-unicode")){
        return Validate.UCS2(obj);
    }

    if (regEx.test(value)) {
        pos = value.search(regEx);
        character  = value.substring(pos, pos+1);
        charString = Validate.getInvalidKey(character);

        let message = getCapt('gVLD003') + charString + getCapt('gVLD004');
        obj.selectionStart = pos;
        obj.selectionEnd = pos+1;
        obj.focus ();
        Validate.handleError(message,obj);
        return false;
    }
    return true;
};

Validate.getInvalidKey = function(character){

    var fsCharacter = null;
    fsCharacter = character;


    if(!fsCharacter){
        return "";
    }

    var charCode = fsCharacter.charCodeAt(0);
    switch(charCode){
        case 9:
            charString = "<tab>";
            break;
        case 8195:
            charString = "<enter>";
            break;
        default:
            charString = character;
            break;
    }

    return charString;

};

Validate.dec = function(obj){
    var result = true;
    if(obj.getAttribute("data-maxscale-system-limit")){
        result = Validate.scale(obj);
    }else{
        result = Validate.decimal(obj);
    }

    if(result && obj.value.trim()=='-'){
        obj.value='';
    }
    return result;
};


Validate.decimal = function(obj){ // MVB aangepast
    var error = false;
    var value = obj.value.trim();
    var signed = XDOM.getBooleanAttribute(obj,"data-signed");
    var thousandSeparator = (obj.getAttribute("data-thousand-separator")=="on");
    if(thousandSeparator){
        value = unformatThousand(value);
    }
    var parts = value.split(SETTINGS.decimalSeparator);
    var decimalLength = parseInt(obj.getAttribute("data-scale"));
    var intLength = parseInt(obj.getAttribute("data-precision"))-decimalLength;
    if(value.indexOf('.')>0){
        error = true;
    }
    //formaat begrijpelijk maken voor javascript (123,12 wordt 123.12)
    value = parts.join('.');

    if(value.substr(0,1) == '-' && !signed) {
        Validate.handleError(getCapt('gVLD005'),obj);
        return false;
    }

    //checken voor geldigheid nummer;
    if(isNaN(value)){
        error = true;
    }

    if(parts.length > 2){
        error = true;
    }

    var negativeCorrection = 0;
    if(value.substr(0,1) == '-'){
        //value is een negatieve waarde. Het - teken moet niet meegeteld worden bij de toegestane lengte.
        negativeCorrection = 1;
    }


    if(parts[0].length > (intLength + negativeCorrection)){
        error = true;
    }
    if(parts[1] && parts[1].length > decimalLength){
        error = true;
    }
    if(error){
        message =  getCapt('gVLD001') + Validate.getDecimalPatern(signed, thousandSeparator, intLength, decimalLength);
        Validate.handleError(message,obj);
        return false;
    }
    //er is geen fout opgetreden
    return true;

};

Validate.scale = function(obj){
    var scaleObj = new MaxScale(obj);
    var message = '';
    if(!Validate.decimal(obj)){
        message = getCapt('gVLD001') + scaleObj.getPatern();
        Validate.handleError(message,obj);
        return false;
    }
    if(!scaleObj.validate()){
        message = getCapt('gVLD001') + scaleObj.getPatern();
        Validate.handleError(message,obj);
        return false;
    }
    scaleObj.obj = null;
    scaleObj = null;
    return true;
};


Validate.All=function(){
    var faInputs = XDOM.queryAll('INPUT[data-datatype]:not([data-stateless-page-id]), TEXTAREA[data-datatype]:not([data-stateless-page-id])');
    var foInput = null;
    for(var i = 0, l = faInputs.length;i<l;i++){
        foInput = faInputs[i];
        if(!Validate.test(foInput)){
            return false;
        }else{
            addAttributes(foInput);
        }
    }

    return true;

};





/* mask */
/* Load Timestamp 13:59:55.634 */
/* global XDOM, SESSION */

/**
 * data-mask-message bericht voor een ongeldig mask element data-mask-validation verwijsing naar de regular expression
 * voor validatie van dit masker element
 */

var Mask = function () {
};
/**
 * definities voor maskers
 *
 * @type Array
 */



Mask.definitions = [];

Mask.setDefinitions = ()=> {
// DD-DD-DD
    Mask.definitions['*DMY'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskCalDay',
            'delimiter': '-',
            'delimiterCss': 'minusDelim',
            'message': getCapt('gCAL006'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskMonth',
            'delimiter': '-',
            'delimiterCss': 'minusDelim',
            'message': getCapt('gCAL009'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 6,
            'maxLength': 2,
            'css': 'dec mskYear',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        }];
//

    Mask.definitions['*DMYY'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskCalDay',
            'delimiter': '-',
            'delimiterCss': 'minusDelim',
            'message': getCapt('gCAL006'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskMonth',
            'delimiter': '-',
            'delimiterCss': 'minusDelim',
            'message': getCapt('gCAL009'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 8,
            'maxLength': 4,
            'css': 'dec mskCentury',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        }];
// DD/DD
    Mask.definitions['*YRP'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskYear',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskPeriod2',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL021'),
            'validate': '*DIG',
            'custom': false
        }];
// DD/DD/D
    Mask.definitions['*YWD'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskYear',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskWeek',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL020'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 5,
            'maxLength': 1,
            'css': 'dec mskWeekDay',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        }];
// DDDD/DD/D
    Mask.definitions['*CYWD'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 4,
            'maxLength': 4,
            'css': 'dec mskCentury',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 6,
            'maxLength': 2,
            'css': 'dec mskWeek',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL020'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 6,
            'end': 7,
            'maxLength': 1,
            'css': 'dec mskWeekDay',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        }];
// DD/DD
    Mask.definitions['*YWK'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskYear',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskWeek',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL020'),
            'validate': '*DIG',
            'custom': false
        }];
// DDDD/DD
    Mask.definitions['*CYW'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 4,
            'maxLength': 4,
            'css': 'dec mskCentury',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 6,
            'maxLength': 2,
            'css': 'dec mskWeek',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL020'),
            'validate': '*DIG',
            'custom': false
        }];
// DDDD/DD
    Mask.definitions['*CYP'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 4,
            'maxLength': 4,
            'css': 'dec mskCentury',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 6,
            'maxLength': 2,
            'css': 'dec mskPeriod2',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL021'),
            'validate': '*DIG',
            'custom': false
        }];
// DDDD/D
    Mask.definitions['*CYQ'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 4,
            'maxLength': 4,
            'css': 'dec mskCentury',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 5,
            'maxLength': 1,
            'css': 'dec mskQuarter',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL024'),
            'validate': '*DIG',
            'custom': false
        }];
// DD/D
    Mask.definitions['*YRQ'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskYear',
            'delimiter': '/',
            'delimiterCss': 'slashDelim',
            'message': getCapt('gCAL011'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 3,
            'maxLength': 1,
            'css': 'dec mskQuarter',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL024'),
            'validate': '*DIG',
            'custom': false
        }];
// //DD:DD:DD
    Mask.definitions['*HMS'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskHour',
            'delimiter': ':',
            'delimiterCss': 'colonDelim',
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskMinute',
            'delimiter': ':',
            'delimiterCss': 'colonDelim',
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 4,
            'end': 6,
            'maxLength': 2,
            'css': 'dec mskSeconds',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        }];
// DD:DD
    Mask.definitions['*HMN'] = [
        {
            'type': 'D',
            'start': 0,
            'end': 2,
            'maxLength': 2,
            'css': 'dec mskHour',
            'delimiter': ':',
            'delimiterCss': 'colonDelim',
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        },
        {
            'type': 'D',
            'start': 2,
            'end': 4,
            'maxLength': 2,
            'css': 'dec mskMinute',
            'delimiter': null,
            'delimiterCss': null,
            'message': getCapt('gCAL007'),
            'validate': '*DIG',
            'custom': false
        }];
}

Mask.isMask = function (obj) {
    var fsMask = null;
    if (obj && obj.getAttribute) {
        fsMask = obj.getAttribute("data-mask");
        if (fsMask) {
            return true;
        }
    }
    return false;
};

/**
 *
 * @param obj
 *          onderdeel van en mask of naam van origineel object van masker
 * @returns eerste invoer element van een masker terug
 */
Mask.getFirstPart = function (obj) {
    var foObj = XDOM.getObject(obj);
    var fsTarget = foObj.getAttribute("data-mask-target");
    if (fsTarget) { // foObj == masker onderdeel
        return foObj.parentNode.querySelectorAll('[data-mask-first=true]')[0];
    }// foObj == orgineel veld heeft geen data-mask-target attribute
    fsTarget = foObj.getAttribute("data-mask-first-part");
    return XDOM.getObject(fsTarget);
};

Mask.getAllParts = function (obj) {
    var foObj = XDOM.getObject(obj);
    var fsTarget = foObj.getAttribute("data-mask-target") ||
        foObj.getAttribute("data-mask-container-for") ||
        foObj.id;
    return foObj.parentNode.querySelectorAll('[data-mask-target="' + fsTarget + '"]');

};

/**
 * verkrijgt de waarde van het masker uit de zichtbare element
 * zonder deze aan te vullen
 * dit t.b.v. een snelzoek op een cutom masker
 * @param {type} id
 * @returns {undefined}
 */
Mask.getRawValue = function (id) {
    var obj = XDOM.getObject(id),
        parts = null,
        value = '';

    if (!Mask.isMask(obj)) {
        return '';
    }

    parts = Mask.getAllParts(obj);

    for (var i = 0, l = parts.length; i < l; i++) {
        value += parts[i].value;
    }
    return value;
};


/**
 *
 * @param obj
 *          onderdeel van en mask of naam van origineel object van masker
 * @returns laatste invoer element van een masker terug
 */
Mask.getLastPart = function (obj) {
    var fsObjId = obj.getAttribute("data-mask-last-part");
    return XDOM.getObject(fsObjId);
};

Mask.isLastPart = function (obj) {
    return XDOM.getBooleanAttribute(obj, "data-mask-last");
};


/**
 * set de focus op het eerste deel van het masker en selecteerd de text
 *
 * @param obj
 *          onderdeel van en mask of naam van origineel object van masker
 */
Mask.focus = function (obj) {
    var foObject = Mask.getFirstPart(obj);
    if (foObject) {
        foObject.focus();
        foObject.select();
    }
};

Mask.getContainer = function (obj) {
    var foContainer = obj;
    if (foContainer.tagName == "INPUT") {
        foContainer = XDOM.getObject(obj.id + "_container");
    }
    return foContainer;
};

Mask.setValue = function (obj, value) {
    var fbInput = obj.tagName == "INPUT";
    var foElements = null;
    var foContainer = obj;
    var foField = null;

    var faValues = Mask.spliceValue(obj, value);

    if (fbInput) {
        //set value to parent element (target)
        obj.value = value;
        foContainer = XDOM.getObject(obj.id + "_container");
        if (foContainer) {
            foElements = foContainer.querySelectorAll("[data-mask-target]");
            // foElements = foContainer.getElementsByTagName('input');
        } else {
            foElements = Mask.getAllParts(obj);
        }
    } else {
        foElements = obj.getElementsByTagName('output');
        if (value == '') {
            obj.style.display = 'none';
        } else {
            obj.style.display = '';
        }
    }

    for (var i = 0, l = foElements.length; i < l; i++) {
        foField = foElements[i];
        if (fbInput) {
            foField.value = faValues[i];
            foField.setAttribute("value", faValues[i].trim()); //voor css selectors
            setOldValue(foField);
        } else {
            if (faValues[i]) {
                foField.textContent = faValues[i];
            } else {
                foField.textContent = " ";
            }
        }
    }
};

Mask.spliceValue = function (obj, value) {
    var foDefinition = Mask.getDefinition(obj);

    var fsValue = '';
    var faReturn = [];

    for (var i = 0, l = foDefinition.length; i < l; i++) {
        fsValue = value.substring(foDefinition[i].start, foDefinition[i].end);
        if (!fsValue) {
            fsValue = '';
        }
        faReturn.push(fsValue);
    }
    return faReturn;
};


Mask.prepareDom = function () {
    Mask.setDefinitions();
    var faMasks = XDOM.queryAll('[data-mask]');
    for (var i = 0, l = faMasks.length; i < l; i++) {
        Mask.prepare(faMasks[i]);
    }
};


Mask.prepare = function (obj) {
    //var fsValue = '';
    if (obj.tagName == "INPUT") {
        // fsValue = obj.value;
        Mask.renderInput(obj);
    } else {
        Mask.renderOutput(obj);
    }
};

Mask.getDefinition = function (obj) {

    var fsMaskDef = obj.getAttribute("data-mask");
    var foDefinitions = Mask.definitions[fsMaskDef];
    var scope = "";
    if (foDefinitions) {
        return foDefinitions;
    }
    scope = obj.getAttribute("data-custom-mask-scope")
    if (scope == "*PROGRAM") {
        var recordNr = getClientRecordNr(obj);
        if (recordNr || recordNr == 0) {  // MVB aangepast
            fsMaskDef = SESSION.activeData.subfileAttributes[recordNr][fsMaskDef]
        } else {
            fsMaskDef = SESSION.activeData.headerData[fsMaskDef];
        }
    } else if (scope == "*SESSION") {
        fsMaskDef = gaMasks['*' + fsMaskDef]
    }

    foDefinitions = CustomMask.get(fsMaskDef);
    return foDefinitions;
};


/**
 * method Mask.analyzeMask
 * zet de string Mask om naar een array elements met MaskElement objecten en in een array  delimiters met string object
 * @author JVE
 * @since 01-07-2011
 * @version 1.0
 * @see Mask
 * @see MaskElement
 */

Mask.renderInput = function (obj, protect) {
    var foDefinitions = Mask.getDefinition(obj);
    var fiXpos = parseInt(obj.getAttribute("data-xpos"));
    var fiTabindex = obj.tabIndex;
    var foContainer = XDOM.createElement("DIV", obj.id + "_container", obj.className + " mask");
    var foDelimiter = null;
    var fbProtected = typeof protect !== 'undefined' ? protect : false;
    foContainer.setAttribute("data-mask-container-for", obj.id);
    var foNewPart = null;
    var foPart = obj.cloneNode();
    var foDefinition = null;
    foPart.setAttribute("data-mask-target", obj.id);

    XDOM.removeAttribute(obj, "data-line");
    XDOM.removeAttribute(obj, "data-xpos");

    //RKR DATA TYPE NIET AANPASSEN MAAR BLIJFT DATA
    //obj.setAttribute("data-datatype","*HIDDEN");

    obj.className = 'hidden';
    obj.readOnly = 'readOnly';
    obj.type = 'hidden';
    obj.maxLength = null;  // MVB maxLength

    for (var i = 0, l = foDefinitions.length; i < l; i++) {
        foDefinition = foDefinitions[i];
        foNewPart = foPart.cloneNode();
        foNewPart.value = '';
        foNewPart.id += "-" + i;
        foNewPart.name += "-" + i;
        foNewPart.tabindex = fiTabindex + i;
        foNewPart.setAttribute("data-xpos", fiXpos + i);
        foNewPart.setAttribute("data-datatype", "*MASK");
        foNewPart.setAttribute("data-focus-action", "INP.handleOnFocus");
        foNewPart.setAttribute("data-blur-action", "INP.handleOnBlur");

        XDOM.removeAttribute(foNewPart, "data-mask-element-type");


        if (fbProtected) {
            foNewPart.readOnly = 'readonly';
            foNewPart.setAttribute("data-protected", "true");
        }

        if (i == 0) {
            foNewPart.setAttribute("data-mask-first", "true");
            obj.setAttribute("data-mask-first-part", foNewPart.id);
        }
        if (i == l - 1) {
            obj.setAttribute("data-mask-last-part", foNewPart.id);
            foNewPart.setAttribute("data-mask-last", "true");
        } else {
            foNewPart.setAttribute("data-nextMask-part", obj.id + "-" + (i + 1));
        }
        if (foDefinition.custom) {
            foNewPart.className = foDefinition.inputClass;
        } else {
            foNewPart.className = foDefinition.css;
        }
        foNewPart.maxLength = foDefinition.maxLength;  // MVB maxLength
        //  foNewPart.setAttribute("maxLength",foDefinition.maxLength);       // MVB maxLength
        foNewPart.setAttribute("data-mask-type", foDefinition.type);
        foNewPart.setAttribute("data-precision", foDefinition.maxLength);    // MVB maxLength
        foNewPart.setAttribute("data-mask-message", foDefinition.message);
        foNewPart.setAttribute("data-mask-validation", foDefinition.validate);
        foNewPart.setAttribute("data-mask-custom", foDefinition.custom);
        foNewPart.setAttribute("data-mask-container", foContainer.id);
        foContainer.appendChild(foNewPart);

        if (foDefinition.delimiter) {
            foDelimiter = XDOM.createElement("DIV", null, "maskpart delimiter " + foDefinition.delimiterCss);
            foDelimiter.textContent = foDefinition.delimiter;
            foContainer.appendChild(foDelimiter);
        }
    }
    if (obj.getAttribute("data-hidden") == "true") {
        foContainer.setAttribute("data-hidden", "true");
    }

    if (obj.getAttribute("data-condition-field-id")) {
        foContainer.setAttribute("data-condition-field-id", obj.getAttribute("data-condition-field-id"));
        foContainer.setAttribute("data-condition-attribute", obj.getAttribute("data-condition-attribute"));
    }

    if (obj.parentNode) {
        obj.parentNode.insertBefore(foContainer, obj);
    }
    return foContainer;
};

Mask.renderOutput = function (obj) {
    var foDefinitions = Mask.getDefinition(obj);
    var foDefinition = null;
    //var foContainer = XDOM.createElement("DIV", null, "outputMask");
    var foNewPart = null;
    var cssClass = '';
    var foContainer = obj;
    var foDelimiter = null;
    foContainer.className += " outputMask";

    for (var i = 0, l = foDefinitions.length; i < l; i++) {
        foDefinition = foDefinitions[i];
        if (foDefinition.custom) {
            cssClass = foDefinition.outputClass;
        } else {
            cssClass = foDefinition.css;
        }
        foNewPart = XDOM.createElement("output", obj.id + "-" + i, "maskpart  " + cssClass);
        foContainer.appendChild(foNewPart);
        if (foDefinition.delimiter) {
            foDelimiter = XDOM.createElement("DIV", null, "maskpart delimiter " + foDefinition.delimiterCss);
            foDelimiter.textContent = foDefinition.delimiter;
            foContainer.appendChild(foDelimiter);
        }
    }


    //obj.appendChild(foContainer);

    return foContainer;
};


/**
 * data-mask-message bericht voor een ongeldig mask element data-mask-validation verwijzing naar de regular expression
 * voor validatie van dit masker element
 *
 * @param obj
 */
Mask.validateAllParts = function (obj) {

    var foElements = Mask.getAllParts(obj);
    var isValid = true;

    for (var i = 0, l = foElements.length; i < l; i++) {
        if (!Mask.validatePart(foElements[i])) {
            isValid = false;
        }
    }
    return isValid;
};


/**
 * data-mask-message bericht voor een ongeldig mask element data-mask-validation verwijsing naar de regular expression
 * voor validatie van dit masker element
 *
 * @param obj
 */
Mask.validatePart = function (obj) {
    var message = '';
    if (Mask.isValidPart(obj)) {
        resetMessage();
        return true;
    }
    message = Mask.getErrorMessage(obj);
    setEventsMessage('F', message);
    XDOM.focus(obj);
    return false;
};


Mask.getErrorMessage = function (obj) {
    var fsValue = obj.value;
    var fsRegExName = obj.getAttribute("data-mask-validation");
    var fsMessage = obj.getAttribute("data-mask-message");
    var fsRegExpr = gaREGEXP[fsRegExName];
    var type = obj.getAttribute("data-mask-type");
    var pos = null, char = null;
    if (fsMessage) {
        fsMessage += fsValue;
    } else {
        if (type == 'D' || type == 'I') {
            fsMessage = getCapt('gVLD007');
        } else {
            pos = fsValue.search(fsRegExpr);
            char = fsValue.substring(pos, pos + 1);
            fsMessage = getCapt('gVLD003') + char + getCapt('gVLD004');
        }
    }
    return fsMessage;
};

Mask.isValidPart = function (obj) {
    var fsValue = obj.value;
    var fsRegExName = obj.getAttribute("data-mask-validation");
    var fsRegExpr = gaREGEXP[fsRegExName];
    if (!fsRegExName || fsValue == '' || !fsRegExpr.test(fsValue)) {
        return true;
    }
    return false;
};


Mask.hasValue = function (obj) {
    var faParts = Mask.getAllParts(obj);
    var foPart = null;
    var fsValue = '';
    for (var i = 0, l = faParts.length; i < l; i++) {
        foPart = faParts[i];
        fsValue += foPart.value;
    }
    if (fsValue.trim()) {
        return true;
    }
    return false;
};

Mask.completeAllMasks = function () {

    var maskObjs = XDOM.queryAll('[data-mask-element-type="*INPUT"]');
    for (var i = 0, l = maskObjs.length; i < l; i++) {
        Mask.completeAllParts(maskObjs[i]);
    }
}

Mask.completeAllParts = function (obj) {

    obj = XDOM.getObject(obj);

    if (!Mask.hasValue(obj)) {
        obj.value = '';
        return;
    }
    var faParts = Mask.getAllParts(obj);
    var foPart = null;
    var completeAllParts = true;

    var fsValue = '';
    for (var i = 0, l = faParts.length; i < l; i++) {
        foPart = faParts[i];
        Mask.completePart(foPart, completeAllParts);
        fsValue += foPart.value;
    }

    obj.value = fsValue;
};


/**
 * bepaald of een masker in zijn totalitijd is veranderd
 * @param obj element van een masker
 * @returns {boolean}
 */
Mask.isChanged = function (id) {
    return fieldIsChanged(XDOM.getObject(id));
};


Mask.completePart = function (obj, completeAllParts) {
    if (obj.getAttribute("data-no-completion") === "true") {
        return;
    }
    var value = obj.value.trim();
    var type = obj.getAttribute("data-mask-type");
    if (value) {
        switch (type) {
            case 'A':
            case 'C':
                value = value.rgtblk(obj.maxLength);
                break;
            case 'I':
                value = value.lftzro(obj.maxLength);
                break;
            case 'N':
                value = value.lftblk(obj.maxLength);
                break;
            case 'Z':
                value = value.rgtzro(obj.maxLength);
                break;
            case 'D':
                value = value.lftzro(obj.maxLength);
                break;
        }
    } else {
        if (obj.getAttribute("data-validate-mask") == "false" && Mask.hasValue(obj)) {
            if (type == 'I') {
                value = value.lftzro(obj.maxLength);
            } else if (completeAllParts) {
                value = ' '.times(obj.maxLength);
            }
        }
    }
    obj.value = value;
};

Mask.getTarget = function (foObj) {
    var fsTarget = foObj.getAttribute("data-mask-target");
    return XDOM.getObject(fsTarget);
};

Mask.returnValues = function (obj) {
    var part = null;
    var target = obj.getAttribute("data-mask-target");
    var targetObj = Mask.getTarget(obj);
    if (!targetObj) {
        return;
    }
    var parts = obj.parentNode.querySelectorAll('[data-mask-target=' + target + ']');
    targetObj.value = '';
    for (var i = 0, l = parts.length; i < l; i++) {
        part = parts[i];
        //Mask.completePart(part);
        targetObj.value += part.value;
    }
};


/**
 * Bij een masker moet er als er op enter wordt gedrukt eerst het masker aangevuld en de waarde terug
 * geschreven worden in het oorspronkelijke invoer veld
 * @returns {boolean}
 */
Mask.handleKeyDown = function () {
    if (GLOBAL.charCode != keyCode.enter || !Mask.isMask(GLOBAL.eventSourceElement)) {
        return false;
    }

    if (Mask.validatePart(GLOBAL.eventSourceElement)) {
        //masker is gevalideerd en aangevuld geef false terug zodat de enter uiteindelijk resulteerd in een submit
        Mask.completeAllParts(GLOBAL.eventSourceElement.getAttribute("data-mask-target"));
        //Mask.completePart(GLOBAL.eventSourceElement);
        //Mask.returnValues(GLOBAL.eventSourceElement);
        return false;
    } else {
        //masker is niet gevalideerd voorkom een submit
        return true;
    }
}


/**
 * bij het verlaten van een deel van een masker
 * wordt er afgeweken van andere input elementen omdat
 * het om een samengesteld veld gaat
 * @param obj
 */
Mask.handleOnBlur = function (obj, isChanged) {
    if (!Mask.isMask(obj)) {
        return false;
    }
    if (!isChanged || Mask.validatePart(obj)) {
        Mask.completePart(obj);
        Mask.returnValues(obj);
        Mask.submitField(obj);
    }
    // SESSION.activePage.lastChangedMaskId = obj.getAttribute("data-mask-target");
    return true;
};

Mask.submitField = function (foObj) {
    var fbIsAutosubmit = isAutoSubmitField(foObj);
    var fsTarget = foObj.getAttribute("data-mask-target");
    if (Mask.isLastPart(foObj) && (fbIsAutosubmit)) {
        if (Mask.isChanged(fsTarget)) {
            INP.handelTriggersAndAutoSubmits(foObj, true, true);
        }
    }
};


/**
 * Bij een submit moet de LastChanged weer leeg gemaakt worden.
 * @param obj
 */
Mask.clearLastChanged = function () {
    SESSION.activePage.lastChangedMaskId = '';
    return;
};


/**
 * controleerd of het vorige object een mask element was en of het huidige object daar nog bij hoort
 * @param obj
 */
Mask.handleFocus = function (obj) {
    var orgMask = null;
    var maskContainer = null;
    if (SESSION.activePage.lastChangedMaskId && SESSION.activePage.lastChangedMaskId !== "") {
        if (SESSION.activePage.lastChangedMaskId !== obj.getAttribute("data-mask-target")) {
            //het masker is verlaten
            orgMask = XDOM.getObject(SESSION.activePage.lastChangedMaskId);
            Mask.handleOnChange(orgMask);
        }
    }

    if (Mask.isMask(obj)) {
        maskContainer = Mask.getContainer(obj.getAttribute("data-mask-target"));
        if (maskContainer) {
            XDOM.getObject(maskContainer).setAttribute("data-last-selected-part", obj.id);
        }
    }
};

/**
 * eventhandler voor change op masks
 * omdat we hier niet weten of het masker helmaal of slechts een masker gedeeltelijk is verlaten
 * registreren we het veranderde masker deel om dan bij het volgende onFocus of onclick event te kijken of het masker ook werkelijk verlaten is
 * is dat zo dan kan er als nog een auto submit plaatsvinden
 **/
Mask.handleOnChange = function (obj) {
    SESSION.activePage.lastChangedMaskId = '';
    Mask.completeAllParts(obj);
    handleOnChange(obj);
};

/**
 * omdat een submit bij een autosubmit niet mogelijk is op een onChange event
 * simuleren we dit
 * obj kan null zijn! in dat geval is het masker zeker verlaten
 **/
Mask.CheckChanged = function (obj) {
    if (!SESSION.activePage.lastChangedMaskId) {
        return false;
    }
    if (!obj || SESSION.activePage.lastChangedMaskId != obj.getAttribute("data-mask-target")) {

        //het masker is veranderd en heeft een autosubmit veld
        Mask.handleOnChange(XDOM.getObject(SESSION.activePage.lastChangedMaskId));
        return true;
    }

    return false;
};

/**
 * geeft aan of object een maskpart is
 * @param obj
 * @returns {Boolean}
 */
Mask.isPart = function (obj) {
    if (obj.getAttribute("data-mask-target")) {
        return true;
    }
    return false;
};

/**
 * geeft aan of object een maskpart is
 * @param obj
 * @returns {Boolean}
 */
Mask.selectNextPart = function (obj) {

    var nextMaskField = null;
    var nextMaskObject = null;
    var maskSelector = null

    maskSelector = obj.getAttribute("data-mask-target");
    if (!maskSelector) {
        return false;
    }

    if (Mask.isMask(obj) && !Mask.isLastPart(obj)) {

        nextMaskField = obj.getAttribute("data-nextMask-part");
        if (nextMaskField !== null) {
            nextMaskObject = XDOM.getObject(nextMaskField);
            if (nextMaskObject !== null) {
                return XDOM.focus(nextMaskObject);
            }
        }
    }

    return false;
};
/* customMask */
/* Load Timestamp 13:59:55.635 */
/**
 * voor het analizeren en definieeren van custom maskers
 */
CustomMask = {};

CustomMask.knownParts = ['A','C','D','N','Z','I'];

CustomMask.partDefinition = function(start, type){
    this.start = start;
    this.end = 0;
    this.maxLength = null;  // MVB maxLength
    this.inputClass = '';
    this.outputClass = '';
    this.delimiter = '';
    this.delimiterCss = null;
    this.message = '';
    this.validate = '';
    this.custom = true;
    this.type = type;
    this.validate = this.getDataType(type);
};

CustomMask.partDefinition.prototype.complete = function(end, type){
    this.end = end;

    if(!isIn(type,CustomMask.knownParts)){
        this.delimiter += type;
    }
    this.maxLength = this.end - this.start;  // MVB maxLength
    this.delimiterCss = CustomMask.getDelimiterClass(this.delimiter);
    this.getInputClass();
    this.getOutputClass();
};

CustomMask.partDefinition.prototype.getInputClass = function(){
    switch (this.type){
        case 'A':
        case 'C':
        case 'Z':
            this.inputClass =' data customInputMskDTA_';
            break;
        case 'D':
        case 'I':
        case 'N':
            this.inputClass = ' dec customInputMskDEC_';
            break;
    }
    if(this.maxLength < 9){  // MVB maxLength
        this.inputClass  += '0' ;
    }
    this.inputClass  += this.maxLength;  // MVB maxLength
};

CustomMask.partDefinition.prototype.getOutputClass = function(){
    this.outputClass = 'customOutputMsk';
    switch (this.type){
        case 'A':
        case 'C':
        case 'Z':
            this.outputClass += 'DTA_';
            break;
        case 'D':
        case 'I':
        case 'N':
            this.outputClass += 'DEC_';
            break;
    }
    if(this.maxLength < 9){
        this.outputClass  += '0' ;
    }
    this.outputClass += this.maxLength;  // MVB maxLength
};

CustomMask.partDefinition.prototype.getDataType = function(){
    switch (this.type){
        case 'A':
            return '*ALPHANUM';
            break;
        case 'Z':
        case 'C':
            return '*DTA';
            break;
        case 'D':
        case 'N':
        case 'I':
            return '*DIG';
            break;
    }
};

CustomMask.getDelimiterClass = function(fsDelimiter){
    if(!fsDelimiter){return;}
    var fsSmallDelimiters = ':/\\.,;\'\"}{[]-_)(*^!`~=+|';
    switch (fsDelimiter){

        case ':':
            return "colonDelim";
            break;
        case '/':
            return "slashDelim";
            break;
        case ' ':
            return "spaceDelim";
            break;
        case '-':
            return "minusDelim";
            break;
        case '.':
            return "periodDelim";
            break;
        default:
            if(fsSmallDelimiters.indexOf(fsDelimiter) > -1){
                return "sMaskDelimiter3";
            }else{
                if(fsDelimiter.length < 10){
                    return 'mskxsinp0' + fsDelimiter.length;
                }
                return 'mskxsinp' + fsDelimiter.length;
            }
            break;
    }
};

CustomMask.get = function (def){
    if(!def){
        return;
    }
    var defArray = def.split('');
    var currentChar = '';
    var lastChar = '';
    var partDef = null;
    var position = 0;
    Mask.definitions[def] =[];

    //opbouwen van array van mask elementen en delimiters
    for (var i = 0,l=defArray.length; i<l;i++){
        currentChar = defArray[i];
        if(lastChar!=currentChar){
            if(partDef){
                partDef.complete(position,currentChar);
            }
            if(isIn(currentChar,CustomMask.knownParts)){
                partDef = new CustomMask.partDefinition(position,currentChar);
                Mask.definitions[def].push(partDef);

            }
        }
        if(isIn(currentChar,CustomMask.knownParts)){
            position++;
        }
        lastChar = currentChar;
    }
    //laatste element afmaken
    partDef.complete(position,currentChar);
    return Mask.definitions[def];
};
/* keepAlive */
/* Load Timestamp 13:59:55.635 */
function KeepAlive(){}

KeepAlive.totalTrys  = 5;
KeepAlive.interval = 90000; //normale interval //90000
KeepAlive.intervalOnFail = 20000; //interval bij valen
KeepAlive.tryCount = KeepAlive.totalTrys;
//KeepAlive.inProgress = false;

KeepAlive.timer = null;

KeepAlive.request = function(){

    if(SESSION.submitInProgress) { return; }

    if(SESSION.session.jobState=='END'){
        return;
    }
    SESSION.submitInProgress = true;

    var fsPath = SESSION.cgiAliasDir + '/box/ndmctl/kpajob.ndm/kpajob?'+
        'PFMRMTUS=' + SESSION.remoteUser
        + '&PFMFILID=' + SESSION.enviroment
        + '&PFMJOBID=' + SESSION.jobId
        + "&AUTHTOKEN=" + SESSION.AUTHTOKEN
    advAJAX.setDefaultParameters({}); // reset AJAX

    advAJAX.get({
        url : fsPath,
        onError : KeepAlive.onError,
        onSuccess :KeepAlive.onSuccess
    });

};

KeepAlive.onError = function(){
    if(!KeepAlive){
        return; //Sessie is gesloten maar KPA request was al onderweg
    }
    SESSION.submitInProgress = false;
    if(KeepAlive.tryCount > 0){
        KeepAlive.tryCount--;
        KeepAlive.timer = setTimeout(KeepAlive.request, KeepAlive.intervalOnFail);
    }else{
        window.status= "Activeren taak " + SESSION.jobId + " niet gelukt; sessie wordt afgesloten";
    }
    return;
};

KeepAlive.update = function(){
    window.status = '';
};

KeepAlive.onSuccess = function(){
    if(!KeepAlive){
        return; //Sessie is gesloten maar KPA request was al onderweg
    }
    SESSION.submitInProgress = false;
    KeepAlive.start();
};

KeepAlive.cancel = function(){
    // ***************************************************************************
    // Keep alive job stoppen
    // ***************************************************************************
    clearTimeout(KeepAlive.timer);
    KeepAlive.tryCount = KeepAlive.totalTrys;
    return;
};

KeepAlive.start = function(){
    // ***************************************************************************
    // Keep alive job gelukt - Volgende schedulen
    // ***************************************************************************

    KeepAlive.cancel();

    KeepAlive.timer = setTimeout(KeepAlive.request, KeepAlive.interval);
    return;
};





/* upload */
/* Load Timestamp 13:59:55.636 */
/*
ID: het id van de placeholder DIV
enabled javascript true of false waarde
allow:
         *ALL		default, alles toegestaan
         *IMAGE	jpg, jpeg, png, gif, tiff
         *OFFICE 	doc, docx, xls, xlsx, ppt, pptx
         *CSV	Csv
*/

Upload = function(obj) {
    this.baseId = obj.getAttribute('data-upload-base-id');
    this.dom = {};
    this.dom.input = XDOM.getObject(this.baseId);
    this.dom.clearButton = XDOM.getObject(this.baseId + '_DEL');
    this.dom.selectButton = XDOM.getObject(this.baseId + '_SCH');
    this.dom.display = XDOM.getObject(this.baseId + '_DSP');
    this.dom.orgFile = XDOM.getObject(this.baseId + '_ORG');
    this.statusFieldId = this.dom.selectButton.getAttribute('data-upload-status-field');
    this.filenameFieldId = this.baseId;
    this.dom.statusField = XDOM.getObject(this.statusFieldId);
    this.allow = this.dom.selectButton.getAttribute('data-upload-filetype');
    this.isAutoSubmit = this.dom.input.getAttribute('data-autosubmit') === 'true';
    this.orgStatus = this.dom.statusField.value;
    this.uploadedFileName = '';
};

Upload.filter = {};
Upload.filter['*OFFICE'] =
    '.docx, .docm, .dotx, .dotm, .xlsx, .xlsm, .xltx, .xltm, .xlsb, .xlam, .pptx, .pptm, .potx, .potm, .ppam, .ppsx, .ppsm, .sldx, .sldm, .thmx, .pdf, .xls, .doc, .ppt, .xps';
Upload.filter['*DATA'] = '.csv, .xlm';
Upload.filter['*WORD'] = '.docx, .docm, .dotx, .dotm, .doc';
Upload.filter['*EXCEL'] = '.xlsx, .xlsm, .xltx, .xltm, .xlsb, .xlam, .xls';
Upload.filter['*XML'] = '.xml';
Upload.filter['*CSV'] = '.csv';
Upload.filter['*PDF'] = '.pdf';
Upload.filter['*IMAGE'] = 'image/*';
Upload.filter['*ALL'] = '*.*';

/**
 * Enumeratie om status weer te geven:
 * B, blank: veld was leeg en veld is leeg
 * S, select: veld was leeg en veld is gevuld
 * C, changed: veld was gevuld en veld is gevuld met een andere waarde
 * D, delete:  veld was gevuld en veld is leeg
 * P, processed Veld was gevuld en veld is verwerkt op server
 */
Upload.state = {
    blank: 'B',
    selected: 'S',
    changed: 'C',
    deleted: 'D',
    processed: 'P',
    error: 'E'
};

/**
 *
 **/
/*Upload.update = function(obj){
  var pageObjects = XDOM.queryAll('[data-upload-status-field]');
  var uploadObject = null;

  for(var i=0,l=pageObjects.length;i<l;i++){
    uploadObject = new Upload(pageObjects[i]);
    uploadObject.update();
  }
};*/

Upload.prepareDom = function() {
    var pageObjects = XDOM.queryAllScope('[data-upload-status-field]:not([data-component])');
    var uploadObject = null;

    for (var i = 0, l = pageObjects.length; i < l; i++) {
        uploadObject = new Upload(pageObjects[i]);
        uploadObject.prepare();
    }
};

Upload.update = function() {
    var statusFieldObjects = XDOM.queryAllScope('[data-upload-status-field]:not([data-component])');
    var uploadInputObjects = XDOM.queryAllScope('[data-upload-inputfield]:not([data-component])');

    var statusObject = null;
    var inputObject = null;
    var uploadObject = null;

    for (var i = 0, l = uploadInputObjects.length; i < l; i++) {
        inputObject = uploadInputObjects[i];
        uploadObject = new Upload(inputObject);
        uploadObject.dom.input.value = '';
        XDOM.addEventListener(inputObject, 'change', Upload.onSelect);
    }

    for (var i = 0, l = statusFieldObjects.length; i < l; i++) {
        statusObject = new Upload(statusFieldObjects[i]);
        statusObject.update();
    }

    // if (uploadInputObjects.length > 0 && !SESSION.stack.currentMacro.uploadCredentialsChecked) {
    //   Upload.identifyToServer();
    // }
};

Upload.handleClick = function() {
    if (XDOM.GLOBAL.getAttribute('data-upload-select')) {
        Upload.openFile();
        return true;
    }
    if (XDOM.GLOBAL.getAttribute('data-upload-clear')) {
        Upload.clear();
        return true;
    }
    return false;
};

Upload.prototype.prepare = function() {
    this.dom.selectButton.setAttribute('data-upload-select', 'true');
    this.dom.clearButton.setAttribute('data-upload-clear', 'true');
    this.dom.input.setAttribute('data-upload-inputfield', 'true');
    this.dom.display.setAttribute('data-upload-hasFile', 'false');
    this.dom.display.innerHTML = getCapt('gNOFILESELECTED');

    this.orgFileName = this.dom.orgFile.value;

    this.setFilter();
};

Upload.prototype.update = function() {
    this.orgStatus = SESSION.activeData.headerData[this.statusFieldId];
    if (!this.orgStatus) {
        this.orgStatus = Upload.state.blank;
    }

    this.status = this.orgStatus;
    switch (this.status) {
        case Upload.state.blank:
        case Upload.state.processed:
        case Upload.state.deleted:
            this.dom.orgFile.value = '';
            this.dom.input.value = '';
            this.dom.clearButton.style.display = 'none';
            this.orgFileName = getCapt('gNOFILESELECTED');
            this.status = Upload.state.blank;
            break;
        case Upload.state.error:
        case Upload.state.changed:
            this.status = Upload.state.selected;
            break;
        default:
            this.dom.clearButton.style.display = 'block';
            break;
    }

    if (this.orgFileName) {
        this.dom.display.innerHTML = this.orgFileName;
    }

    this.dom.statusField.value = this.status;
    this.orgStatus = this.status;
};

Upload.openFile = function(e) {
    XDOM.cancelEvent(e);
    var uploadObject = new Upload(GLOBAL.eventSourceElement);
    XDOM.invokeClick(uploadObject.dom.input);
    return false;
};

Upload.clear = function(e) {
    XDOM.cancelEvent(e);
    var uploadObject = new Upload(GLOBAL.eventSourceElement);
    uploadObject.clear();
};

Upload.onSelect = function(e) {
    XDOM.getEvent(e);
    var uploadObject = new Upload(GLOBAL.eventSourceElement);
    uploadObject.onSelect();
};

Upload.prototype.setFilter = function() {
    var allow = null;
    var filter = null;

    allow = this.dom.selectButton.getAttribute('data-upload-filetype-field');
    if (allow) {
        filter = SESSION.activeData.headerAttributes[allow];
        if (filter) {
            XDOM.setAttribute(this.dom.input, 'accept', filter);
            return;
        }
    }

    allow = this.dom.selectButton.getAttribute('data-upload-filetype');
    if (!allow) {
        return;
    }

    if (allow.indexOf('*') > -1) {
        filter = Upload.filter[this.allow];
        if (!filter) {
            setMessage('F', 'onbekende file definitie voor upload: ' + allow);
            return;
        }
    } else {
        filter = allow;
    }

    if (filter) {
        XDOM.setAttribute(this.dom.input, 'accept', filter);
    }
    return;
};

Upload.prototype.clear = function() {
    this.dom.display.setAttribute('data-upload-hasFile', 'false');
    this.dom.input.value = '';
    this.dom.clearButton.style.display = 'none';
    this.dom.display.innerHTML = getCapt('gNOFILESELECTED');

    if (this.orgStatus == Upload.state.blank) {
        this.status = Upload.state.blank;
    } else {
        this.status = Upload.state.deleted;
    }
    this.dom.statusField.value = this.status;
    this.dom.orgFile.value = '';
};

Upload.prototype.onSelect = function() {
    var fsPath = '';
    var faPath = null;
    fsPath = this.dom.input.value;
    if (fsPath != '') {
        this.dom.display.setAttribute('data-upload-hasFile', 'true');
        faPath = fsPath.split('\\');
        fsPath = faPath[faPath.length - 1];
        this.dom.display.innerHTML = fsPath;
        this.dom.orgFile.value = fsPath;
        if (this.orgStatus == Upload.state.blank) {
            this.status = Upload.state.selected;
        } else {
            this.status = Upload.state.changed;
        }
        this.dom.statusField.value = this.status;

        this.dom.clearButton.style.display = '';

        if (this.isAutoSubmit) {
            Command.enter();
        }
    } //else{
    //this.clear();
    //}
};

Upload.setFormEncType = function(command) {
    var inputObject = null;
    var uploadObject = null;
    var uploadInputObjects = XDOM.queryAllScope('[data-upload-inputfield]');

    if (command != 'ACCEPT' && command != 'ENTER') {
        for (var i = 0, l = uploadInputObjects.length; i < l; i++) {
            inputObject = uploadInputObjects[i];
            uploadObject = new Upload(inputObject);
            uploadObject.dom.input.value = '';
            uploadObject.dom.clearButton.style.display = 'none';
        }

        SESSION.activeForm.enctype = 'application/x-www-form-urlencoded';
        SESSION.activeForm.encoding = 'application/x-www-form-urlencoded';
        return;
    }

    if (XDOM.queryScope("[data-upload-hasFile='true']")) {
        SESSION.activeForm.enctype = 'multipart/form-data';
        SESSION.activeForm.encoding = 'multipart/form-data';
    } else {
        SESSION.activeForm.enctype = 'application/x-www-form-urlencoded';
        SESSION.activeForm.encoding = 'application/x-www-form-urlencoded';
    }
};

Upload.resetFormEncType = function() {
    SESSION.activeForm.enctype = 'application/x-www-form-urlencoded';
    SESSION.activeForm.encoding = 'application/x-www-form-urlencoded';
};

// /**
//  * IE11 fix bij veranderen enctype/encoding
//  * raakt hij de browser zijn credentials kwijt
//  * pom-1413
//  */
// Upload.identifyToServer = function() {
//   var fdTIME = new Date();
//   var TMSTM = fdTIME.getTime();
//   var fsDIRPT =
//     SESSION.activePage.pageUrl +
//     '?JOBNR=' +
//     SESSION.jobKey +
//     '&PFMFILID=' +
//     SESSION.enviroment +
//     '&TMSTM=' +
//     TMSTM +
//     '&CheckCredentials=true';
//   if (SESSION.submitInProgress) {
//     setTimeout(Upload.identifyToServer, 200);
//     return;
//   }
//   SESSION.submitInProgress = true;

//   advAJAX.get({
//     url: fsDIRPT,
//     onError: function(obj) {
//       console.log('Identify failed');
//     },
//     onSuccess: function(obj) {
//       SESSION.stack.currentMacro.uploadCredentialsChecked = true;
//       SESSION.submitInProgress = false;
//       console.log(SESSION.submitInProgress);
//     },
//     onRetry: function(obj) {
//       console.log('Identify retry');
//     }
//   });
// };

/* Rowselector */
/* Load Timestamp 13:59:55.636 */
/* global XDOM, NAV, Logical, GLOBAL, MultiSelect */

NAV.Rowselector = {};
NAV.Rowselector.lastRowCliked = null;

NAV.Rowselector.toggleAll = function(obj) {
    var value = XDOM.getObjectValue(obj),
        bodyId = XDOM.getParentAttribute(obj,"data-sfl-body-id") || 'SFL',
        bodyContainer = XDOM.getObject(bodyId),
        selectors = null,
        checkBoxValue = (value==="SLTALL");
    if(!bodyContainer){return;}
    selectors = bodyContainer.querySelectorAll("[data-rowselector='true'], [data-multiselect='true']");
    for ( var i = 0, l = selectors.length; i < l; i++) {
        if(checkBoxValue){
            Logical.check(selectors[i]);
        }else{
            Logical.uncheck(selectors[i]);
        }
    }
    MultiSelect.toggleAll(checkBoxValue);
    //do we have an auto sum field if so we have to auto submit
    if(SESSION.activePage.autoSumFields){
        Command.autoSum();
    }
};





NAV.Rowselector.clearAllLogicals = function() {
    var selectors = XDOM.queryAll("[data-rowselector='true'], [data-multiselect='true']");
    for ( var i = 0, l = selectors.length; i < l; i++) {
        Logical.uncheck(selectors[i]);

    }

};

NAV.Rowselector.handleClick = function(obj){
    var nr = getRecordNumber(obj);
    var value = Logical.getObjValue(obj);

    if(!NAV.Rowselector.lastRowCliked){
        NAV.Rowselector.lastRowCliked = nr;
        return;
    }
    if(!GLOBAL.eventObject.shiftKey){
        return;
    }

    if(nr<NAV.Rowselector.lastRowCliked){
        NAV.Rowselector.selectBetween(nr,NAV.Rowselector.lastRowCliked,value);
    }
    if(NAV.Rowselector.lastRowCliked<nr){
        NAV.Rowselector.selectBetween(NAV.Rowselector.lastRowCliked,nr,value);
    }
    NAV.Rowselector.lastRowCliked = null;
};

NAV.Rowselector.selectBetween = function(start, end, value) {
    var foSelector = null;
    for ( var i = start; i < end; i++) {
        foSelector = XDOM.queryScope("[data-multiselect='true'][data-record-number='" + i + "'],[data-rowselector='true'][data-record-number='" + i + "']");
        if (foSelector) {
            Logical.setObjValue(foSelector,value);
        }
    }
};
/* textarea */
/* Load Timestamp 13:59:55.636 */
function TextArea(){}

TextArea.warningTreshold = 50;

TextArea.handleKeyUp = function(){
    if(GLOBAL.eventObjectTAG != "TEXTAREA" ){
        return false
    }
    if(GLOBAL.eventSourceElement.readOnly){
        return true;
    }

    GLOBAL.eventSourceElement.setAttribute("data-block-autosubmit", "false");

    var fiTextLength = TextArea.getLength(GLOBAL.eventSourceElement);
    var fiMaxLength = GLOBAL.eventSourceElement.maxLength;

    if(fiTextLength==fiMaxLength){
        setEventsMessage('F',fiTextLength + getCapt('gTXTAREAMAX5') + fiMaxLength);
    }else if(fiTextLength>=fiMaxLength){
        setEventsMessage('F',getCapt('gTXTAREAMAX1') + fiMaxLength + getCapt('gTXTAREAMAX2'));
    }else if(fiTextLength>(fiMaxLength - TextArea.warningTreshold)){
        setEventsMessage('G',fiTextLength + getCapt('gTXTAREAMAX3') + fiMaxLength);
    }else  {
        setEventsMessage('A',fiTextLength + getCapt('gTXTAREAMAX3') + fiMaxLength);
    }
    return true;
};

TextArea.validate = function(obj){
    var fiTextLength = TextArea.getLength(obj);
    var fiMaxLength = obj.maxLength;
    if(fiTextLength > fiMaxLength){
        setMessage('F', getCapt('gTXTAREAMAX1') + fiMaxLength + getCapt('gTXTAREAMAX4'));
        return false;
    }
    return true;
};

TextArea.getLength = function(obj){
    var fsText =  XDOM.getObjectValue(obj);
    fsText = fsText.replace(/(\r\n)/g, "yy");
    fsText = fsText.replace(/(\n\r)/g, "zz");
    fsText = fsText.replace(/\r/g, "qq");
    fsText = fsText.replace(/\n/g, "--");
    return fsText.length;
};

TextArea.handleKeyDown = function(){
    if((GLOBAL.eventObjectTAG == "TEXTAREA") && (GLOBAL.charCode == keyCode.enter)){
        GLOBAL.eventSourceElement.setAttribute("data-block-autosubmit", "true");
    }
};
/* triggers */
/* Load Timestamp 13:59:55.637 */
/* global SESSION */

function Trigger(functionPointer) {
    this.functionPointer = functionPointer;
}
//placeHolder to Log the trigger to;
Trigger.log = "# Trigger sequence \n\n";
/**
 * registratie van triggers
 * @param {type} invoker
 * @param {type} caller
 * @param {type} id
 * @param {function} functionPointer
 * @returns {undefined}
 */
Trigger.register = function(invoker, id, caller, functionPointer, description) {
    if (!SESSION.activePage.triggers[invoker]) {
        SESSION.activePage.triggers[invoker] = {};
    }
    if (!SESSION.activePage.triggers[invoker][caller]) {
        SESSION.activePage.triggers[invoker][caller] = {};
    }
    const executeTrigger = () => {
        functionPointer();
        let value = XDOM.getObjectValue(invoker) || '';
        if(value){
            value =  `value: "${value}"`;
        }
        Trigger.log += `${description} ${invoker} ${value}\n`;
    };
    SESSION.activePage.triggers[invoker][caller].execute = executeTrigger;
    SESSION.activePage.triggers[invoker][caller].id = id;
};

/**
 * vuurt alle triggers af van alle velded die worden doorgegeven
 * trigger fucties worden eerst verzameld waarbij er vanuitgegaan dat het object
 * waar de trigger van is en de functie naam uniek is om te voorkomen dat fucties per object meerdere malen wordt aangesproken
 * @param fields {array} van id van velden als string
 * @returns {boolean} al dan geen triggers afgevuurd
 */
Trigger.fire = function(fields) {
    var triggersTofire = {};
    var triggerKey = '';
    var result = false;
    var triggers = null;
    var triggerObj = null;

    if (!fields) {
        return false;
    }
    //verzamel alle geldige triggers
    //omdate het kan zijn dat meerdere velden het zelfde object trigeren worden deze eerst verzameld
    //zodat elke trigger maximaal 1 keer wordt geexicuteerd
    for (var i = 0, l = fields.length; i < l; i++) {
        if(!fields[i]){ //fields can be an empty string
            continue;
        }
        triggerObj = XDOM.getObject(fields[i]);
        if (triggerObj && 'value' in triggerObj) {
            if (!XDOM.fieldIsChanged(fields[i])) {
                continue;
            }
        }

        triggers = SESSION.activePage.triggers[fields[i]];
        for (var s in triggers) {
            triggerKey = s + ':' + triggers[s].id;
            triggersTofire[triggerKey] = triggers[s].execute;
        }
    }
    for (var t in triggersTofire) {
        triggersTofire[t]();
        result = true;
    }

    return result;
};

Trigger.hasTriger = function(obj) {
    if (SESSION.activePage.triggers[obj.id]) {
        return true;
    }
    return false;
};

Trigger.setAxisField = function(obj) {
    const srcDiv =  XDOM.getObject('SCRDIV');
    var fsName = 'trigger_' + obj.getAttribute('data-axis');
    var fsValue = XDOM.getObjectValue(obj);

    var foInput = XDOM.getObject(fsName);
    if (foInput) {
        XDOM.setOldvalue(foInput);
        foInput.value = fsValue;

        return;
    }

    foInput = XDOM.createElement('input', fsName);
    foInput.setAttribute('name', fsName);
    foInput.setAttribute('type', 'hidden');
    foInput.setAttribute('value', fsValue);
    foInput.setAttribute('data-clear-after-submit', 'true');
    srcDiv.appendChild(foInput);
    return;
};

Trigger.fillIPMF = function(recordNr) {
    var macroURL = SESSION.stack.currentMacro.getCurrentUrl();
    var impfURL =
        macroURL +
        '?SubmitForIPMF=true' +
        '&SubmitFromView=true' +
        '&SelectedSubfileRecord=' +
        recordNr;

    advAJAX.get({
        url: impfURL,
        onError: function(response) {},
        onSuccess: function(response) {},
        onRetry: function(response) {}
    });

    return;
};

/* panel */
/* Load Timestamp 13:59:55.637 */
/* global XDOM, BrowserDetect, Panel, Dragger, GLOBAL, SETTINGS, SESSION, ENUM, keyCode, PdfViewer */
const popupPanel = {};

(function () {
    /**
     * renderd een popup panel t.b.v stateles onderdelen
     * data is een  json verzamelobject met de volgende properties:
     * id:     id van panel moet unique binnen een macro zijn
     * parent: id van parent object (als niet ingevuld is dit DTADIV)
     * width:  breedte in colommen
     * height: hoogte in regels
     * title: caption voor de titel in de header
     * alignTo: id van object tenopzichte waarvan p[aneel moet worden uitgeleind
     * @param {object} res
     * @returns {panel body dom object}
     */

    let panelId = '';


    function render (obj){
        const
            ds = obj.dataset || obj,
            id = obj.id || ds.id,
            title = ds.directTitle || '';

        panelId = 'popup-panel-' + id;

        const
            panelObj = XDOM.createElement('DIV',panelId,'stateless-panel includeBackground'),
            header = XDOM.createElement('DIV', null,"panelHeader theme-background-color"),
            parentObj = XDOM.getObject('DTADIV'),
            headerTextDiv = XDOM.createElement('DIV', null, "panelTitle"),
            closeIcon = XDOM.createElement('DIV',null,'popup-close pth-icon'),
            bodyDiv 	= XDOM.createElement('DIV', 'panel-body-' + id, "stateless-panel-wrapper" ),// cssclass
            titleText = title || Captions.getTitle(ds.titleOrigin, ds.popupTitle , title, getClientRecordNr(obj) ),
            titleNode =  XDOM.createTextNode(titleText),
            headerTextNode = null,
            width = parseInt(ds.cols) * SETTINGS.charWidth+ 'px', //6px voor binnekant border
            height = parseInt(ds.rows) * SETTINGS.lineHeight + 18  + 'px'; //3px voor de bovekant border

        if(ds.resizable){
            panelObj.dataset.isResizable = "true";
        }

        headerTextDiv.setAttribute("data-click-action","popupPanel.handleHeaderClick");
        header.setAttribute("data-click-action","popupPanel.handleHeaderClick");
        closeIcon.setAttribute("data-click-action","popupPanel.close");
        closeIcon.setAttribute("data-popup-panel-id",id);
        panelObj.style.width = width;
        panelObj.style.height = height;
        panelObj.setAttribute("data-popup-panel-id",id);
        panelObj.setAttribute("data-popup-type","panel");
        panelObj.setAttribute("data-update-dom-depth","true");
        panelObj.setAttribute("data-dockable", ds.dockable);
        updatePanelSort(panelObj);
        bodyDiv.id = panelId + "-body";

        setDragable(header);
        setDragable(headerTextDiv);
        setDragable(closeIcon);

        headerTextDiv.setAttribute("popup-panel-title", id);

        parentObj.appendChild(panelObj);
        panelObj.appendChild(header);
        header.appendChild(headerTextDiv);
        headerTextDiv.appendChild(titleNode);
        headerTextDiv.appendChild(closeIcon);
        panelObj.appendChild(bodyDiv);
        Stateless.panel.alignTo(panelId,id);
        return bodyDiv;
    };

    function setDragable(obj){
        //  if(!BrowserDetect.isChrome){return;}
        obj.draggable = true;
        obj.addEventListener("dragstart", drag.start);
        obj.dataset.dragtype = "panel";
        obj.dataset.dragObject = panelId;
        obj.dataset.allowDrop = "panel";
        obj.dataset.allowDropOn = "*ALL";
    }


    function open(obj){
        const callerObject = XDOM.getObject(obj) || GLOBAL.eventSourceElement;
        const placeHolder = render(callerObject);
        return placeHolder;
    }

    function close(panelId){
        drag.cleanup();
        docker.clear();
        let id = panelId,
            panel = XDOM.query('[data-show-on-top][data-popup-type]', SESSION.activeForm);

        if(!id && GLOBAL.eventSourceElement){
            GLOBAL.eventSourceElement.dataset.popupPanelId;
        }

        if(id){
            panel =  XDOM.query("[data-popup-type][data-popup-panel-id='" + id + "']");
        }


        if(panel){
            XDOM.removeDOMObject(panel);
            updatePanelSort();
            return true;
        }
        return false;
    }


    function handleHeaderClick(){
        let obj = XDOM.getParentByAttribute(GLOBAL.eventSourceElement,'data-update-dom-depth');
        updatePanelSort(obj);
    }

    this.handleHeaderClick = handleHeaderClick;
    this.open = open;
    this.close = close;
}).apply(popupPanel);










/* help */
/* Load Timestamp 13:59:55.637 */
var Help = {};

(function () {

    /**
     * checks if a url actualy exists
     * @param url
     * @returns {Promise<boolean>}
     */
    async function isURLAlive(url) {
        try {
            //get the url
            const response = await fetch(url);

            //if it is not there it should
            if(response.status==404) return false;


            //Because apache server actually does not return a 404 status we have to see if there is 404 mentioned somewhere in the title tag of the returning 404 page
            //this is VERY unreliable because custom 404 pages might be defined completely different
            //however this is implemented as a fallback. Implemented for PRSH-002564
            //get the response text
            const text = await response.text();

            // this reg expression tests if there is a title tag containing 404 somewhere.
            // this does not work for instance
            // <title>Invoeren verkooporders - Artikelgegevens - GHON0404F0</title>
            //however the node server seems to not pass status codes correctly so firs propper check should actually work
            //const regex = /<title\b[^>]*>(.*?)404(.*?)<\/title>/i;
            //do we have a 404 somewhere or not (and god help us if some joker ever decides to put a 404 string somewhere in the title
            //return !regex.test(text)
            return !text.toLowerCase().includes("<title>404 niet gevonden</title>")


        } catch (error) {
            // An error occurred, so the URL is not alive
            return false;
        }
    }



    async function mainMenu() {
        return openHelpItemDefinition( SCOPE.session.SESSION.menuDefinitionVarName);

    }
    async function procedure(ev) {
        if (!ev.invokeObject.dataset.buttonEnabled == 'true') return;
        return openHelpItemDefinition(SESSION.session.stack.currentProcedure.procedureName);
    }


    async function macro() {
        if(!SESSION.assistAvailable) return;
        //get the macroName topview overwrites currentMacro is Topview is active
        const item = TopView?.currentInstance?.programName || SESSION.stack.currentMacro.macroName;
        return openHelpItemDefinition(item);
    }

    function show(url){
        const newWindow = window.open(url, "_blank", 'height=700, width=925, title=0, titlebar=0, toolbar=0, menubar=0, location=0, directories=0, status=0, resizable=1, scrollbars=1, alwaysRaised=yes, dependent=yes');

        if (!newWindow?.opener) {
            newWindow.opener = self;
        }
        newWindow.focus();
    }

    async function openExternal(url) {
        show(url);
    }
    async function open(url) {

        const uri = url + '?TIMESTAMP=' + new Date().getTime();

        //first test if url is actualy there
        if(!await isURLAlive(uri)) {
            SCOPE.main.Dialogue.alert(getCapt('noHelpFileGenerated'));
            return;
        }
        show(uri);


    }

    function update() {
        let button = PAGEDOC.querySelector('.leftSection  [data-click="macroHelp"]');
        if (button) {
            button.setAttribute('data-button-enabled', SESSION.assistAvailable);
        }
        button = PAGEDOC.querySelector('nav.session-user-buttons [data-button-icon="help"]');

        if (!button) return;
        button.setAttribute('data-button-enabled', SESSION.assistAvailable);

        //hide procedure help when in topview !! turns falsy/truthy into real boolean.
        button.setAttribute("data-hidden", !!TopView.currentInstance)
    }


    function cheatSheet() {
        let content = `
    <div id="help-wrapper"  data-event-class="userSettings" >
      <div id="settingsTitle">
        <span id="settingsTitleLabel">${getCapt('gCHEATSHEET')}</span>
        <i role="button" tabindex="0" data-title-origin="*LBL"  data-title-variable="cCANCEL_TTL" data-click="close" data-event-class="userSettings"  class="icon pth-close  pull-right settingsCloseBtn"> </i>
      </div>

      <div class="modal-panel-content" >
      <div class="hotkey-cheat-list" >
      
      <div><span> tab </span><span>${getCapt('hotkeyTab')}</span></div>  
      <div><span> Shift + Tab </span><span>${getCapt('hotkeyShiftTab')}</span></div>
      <!--div><span> Shift + &darr; </span><span>${getCapt('hotkeyShiftDown')}</span></div-->
      <div><span> </span><span></span></div>  
        <div><span> Alt + [1-9] </span><span>${getCapt('hotkeynr')}</span></div>
        <div><span> Alt + A </span><span>${getCapt('hotkeya')}</span></div>
        <div><span> Alt + Ctrl + A </span><span>${getCapt('hotkeyCrtla')}</span></div>
        <div><span> Alt + F </span><span>${getCapt('hotkeyf')}</span></div>
        <div><span> Alt + H </span><span>${getCapt('hotkeyh')}</span></div>
        <div><span> Alt + M </span><span>${getCapt('hotkeym')}</span></div>
        <div><span> Alt + N </span><span>${getCapt('hotkeyn')}</span></div>
        <div><span> Alt + P </span><span>${getCapt('hotkeyp')}</span></div>
        <div><span> Alt + Q </span><span>${getCapt('hotkeyq')}</span></div>
        <div><span> Alt + S  </span><span>${getCapt('hotkeys')}</span></div>
        <div><span> Alt + W  </span><span>${getCapt('hotkeyw')}</span></div>
        <div><span> Alt + Home </span><span>${getCapt('hotkeyHome')}</span></div>
        <div><span> Alt + F1 </span><span>${getCapt('hotkeyAltF1')}</span></div>
 
      </div>
      <div class="hotkey-cheat-list" >
        <div><span> F4 </span><span>${getCapt('hotkeyF4')}</span></div>
        <div><span> F7 </span><span>${getCapt('hotkeyF7')}</span></div>
        <div><span> F8 </span><span>${getCapt('hotkeyF8')}</span></div>
        <div><span> F9 </span><span>${getCapt('hotkeyF9')}</span></div>
        <div><span> F10 </span><span>${getCapt('hotkeyF10')}</span></div>
        <div><span> F11 </span><span>${getCapt('hotkeyF11')}</span></div>
        <div><span> F12 ${getCapt('hotkeyOr')} ESC </span><span>${getCapt('hotkeyF12')}</span></div>
        <div><span> </span><span></span></div>  
        <div><span> Shift + F7 </span><span>${getCapt('hotkeyShiftF7')}</span></div>
        <div><span> Shift + F8 </span><span>${getCapt('hotkeyShiftF8')}</span></div>
        <div><span> Shift + F9 </span><span>${getCapt('hotkeyShiftF9')}</span></div>
        <div><span> Shift + F10 </span><span>${getCapt('hotkeyShiftF10')}</span></div>
        

      </div> 
   
      
      
      
      
      
      </div>
    </div>
    </div>`;
        ModalPanel.open(content);
    };

    function fallbackUrl(item) {
        return SCOPE.session.SESSION.assistDir + item + '.htm?TIMESTAMP=' + new Date().getTime();
    }

    async function openHelpItemDefinition(item) {
        if(!SCOPE?.session?.SESSION) return;
        const fallback = fallbackUrl(item)

        //7C, 7E, 8A support external texts , 7B en 7D does not.
        if(["*7A", "*7B", "*7D"].includes(getVersion())){
            return open(fallback);
        }

        const {language, dftLanguage, session}  = SCOPE.session.SESSION
        const environment = session.enviroment
        const {userGroup, signOnMethode,remoteUser} = OCULUS

        const url =
            '/ndscgi/box/ndmctl/HelpUrls.ndm/GetHelpUrls.json?' +
            'PFMFILID=' +
            environment +
            '&PFMGRPID=' +
            userGroup +
            '&PFMSOMTD=' +
            signOnMethode +
            '&USRID=' +
            remoteUser +
            '&UserLanguage=' +
            language +
            '&DefaultLanguage=' +
            dftLanguage +
            '&ItemId=' +
            item;

        const result =  await fetch(url).then(response => response.json());
        const {helpUrlDefaultLanguage, location} = result?.helpText;
        //fallback on old behaviour
        if(!helpUrlDefaultLanguage || location ==="notFound") return open(fallback)
        return openExternal(helpUrlDefaultLanguage);
    }

    this.cheatSheet = cheatSheet;
    this.update = update;
    this.mainMenu = mainMenu;
    this.procedure = procedure;
    this.macro = macro;
}.apply(Help));

/* link */
/* Load Timestamp 13:59:55.638 */
/* global advAJAX, OCULUS, PFMBOX, gErrorLink, MESSAGES, SESSION, XDOM, GLOBAL, self, BrowserDetect */

/**
 * object voor het vastleggen van file Links
 * @returns
 */

const Preference = {
    default: '*CONF',
    linkViewer: '*LNKVIEW',
    system: '*SYS'
};

const Link = {};
(function () {
    let uri = '',
        uriType = '',
        aliasField = '',
        extention = '',
        protocol = '',
        isFixed = false,
        aliasType = '',
        callerId = '';

    /**
     * initialises this
     * @param {HTMLElement} objIn
     */
    function init(obj = GLOBAL.eventSourceElement) {
        if (!obj) {
            return false;
        }

        const ds = obj.dataset;

        uri = (ds.uri || '').trim();
        uriType = ds.urlType;
        openPreference = ds.linkOpenPreference || Preference.default;
        protocol = ds.protocol || '';
        extention = ds.extension || '';
        isFixed = ds.viewType == '*FIXED';
        aliasType = ds.aliasType || ds.viewType;

        if (openPreference == Preference.default) {
            openPreference = SCOPE.main.Settings.get('URL_OPEN_PREFERENCE');
        }
        callerId = obj.id;
        return true;
    }

    /**
     * finds the alias
     * @param {HTMLElement} obj
     * @returns {String} alias
     */
    function getAlias(obj, sfl) {
        if (obj.dataset.fixedAlias) {
            return obj.dataset.fixedAlias;
        }

        let aliasField = obj.dataset.aliasField,
            data = SESSION.activeData.headerAttributes;
        const recordNr = obj.getAttribute('data-record-number');
        if (recordNr) {
            if (sfl && sfl.attributes) {
                return sfl.attributes[sfl.index][aliasField] || "";
            }

            if (SESSION.activePage.subfile && SESSION.activePage.subfile.attributes) {
                data = SESSION.activePage.subfile.attributes[serverToScript(recordNr)];
            } else {
                return '';
            }
        }
        return data[aliasField] || '';
    }

    /**
     * sets the alias depending on the aliastype
     * @param {HTMLElement} obj
     * @param {String} value
     * @param {object} data
     */
    function setAlias(obj, value, data = null) {
        let alias = getAlias(obj, data) || "";
        //is an alias applicable?

        extention = alias.toUpperCase();
        obj.dataset.extension = extention;
        switch (aliasType) {
            case '*LBL': //'*LBL':
                alias = getCaption(obj.dataset.aliasField);
                obj.innerHTML = alias;
                break;
            case '*VAR':
                obj.innerHTML = alias;
                break;
            case '*IMG':
                obj.setAttribute('data-icon', alias.toUpperCase()); //niet via dataset i.v.m. css
                break;
            case '*FIXED':
                break;
            default:
                obj.innerHTML = value;
                break;
        }
    }

    /**
     * voor het zetten van link objecten
     * @param obj
     * @param value
     */
    function setObjValue(obj, valueIN, data) {

        let value = (valueIN || '').trim();

        if (!init(obj)) {
            return;
        }

        if (value == '') {
            obj.classList.add('hidden');
        } else {
            obj.classList.remove('hidden');
        }

        setAlias(obj, value, data);

        if (protocol == '*HTTP' && value.indexOf('://') === -1) {
            value = 'http://' + value;
        }

        obj.dataset.uri = value;
        obj.href = 'javascript:void(0)';
        obj.dataset.clickAction = 'Link.handleOnClick';
        if (!value) {
            if (uriType === '*HashedUrl' && !isFixed) {
                obj.dataset.icon = '';
                obj.href = '';
            }
        }

        if (protocol == '*MAIL') {
            obj.href = 'mailto:' + value;
            obj.dataset.clickAction = '';
            //obj.innerHTML = value;
        }
        uri = value;
        setEmbeddedLinkViewerValue(obj);
    }

    function setEmbeddedLinkViewerValue(obj) {
        if (!isFixed) {
            return;
        }
        if (uriType === '*HashedUrl' && uri) {
            getHashedUri(obj);
            return;
        }
        openLink();
    }

    /**
     * default page update handler
     */
    function update(url) {
        openAutoLink();
        openGeneratedExcel(url);
    }

    /**
     * opens autolinks
     */
    function openAutoLink() {
        const a = XDOM.query('[data-activate-link="*AUTO"]:not([href=""]):not([href="javascript:void(0)"])');
        if (a) {
            XDOM.invokeClick(a);
        }
    }

    /**
     * opens file
     * @param {HTMLElement} obj
     */
    function open(obj) {
        if (!init(obj)) {
            return;
        }
        if (!uri || protocol == '*MAIL') {
            return;
        }

        XDOM.cancelEvent();
        if (uriType === '*HashedUrl' && hasValue(uri)) {
            getHashedUri(obj);
            return;
        }
        openLink();
    }

    /**
     * default click handler
     */
    function handleOnClick() {
        open(GLOBAL.eventSourceElement);
    }

    /**
     * returns filename without extention
     */
    function getFileName() {
        if (uriType === '*HashedUrl') {
            return '';
        }

        return uri.substring(uri.lastIndexOf('/') + 1, uri.lastIndexOf('.'));
    }

    /**
     * opens viewer object
     */
    function openViewer() {
        let args = {
            id: callerId,
            uri: uri,
            extention: extention,
            fileName: getFileName(),
            isFixed: isFixed,
            protocol: protocol
        };
        return Linkviewer.open(args);
    }

    /**
     * opens file as a new browser window or in a viewer
     */
    function openLink() {
        if ((openPreference == Preference.linkViewer || isFixed) && openViewer()) {
            return;
        }
        if (uri) {
            window.open(uri);
        }
    }

    /**
     * callback for getHashedUri when all is well
     * calls openLink
     * or logs error
     * @param {XHTTPresponse} response
     */
    function setHashedUri(response) {
        data = JSON.parse(response.target.responseText).docLinkResponse;
        if (!data) {
            setMessage('F', MESSAGES.DocNotFound);
        }

        if (data.resultCode !== 'Success') {
            setMessage('F', MESSAGES[data.resultCode] + ' [code:' + data.resultCode + ']');
            return;
        }
        init(this.callerObject);
        uri = (data.secureUrl || '').trim();
        openLink();
    }

    /**
     * requests url for hash callback setHashedUri
     * @param {HTMLEllement} callerObject
     */
    function getHashedUri(callerObject) {
        const xmlHttpRequest = new XMLHttpRequest(),
            request =
                '/ndscgi/box/ndmctl/' +
                'CreateDocLink.ndm/secure?' +
                'PFMFILID=' +
                PFMBOX.gCD_ENV +
                '&PFMGRPID=' +
                OCULUS.userGroup +
                '&PFMSOMTD=' +
                PFMBOX.PFMSOMTD +
                '&USRID=' +
                OCULUS.remoteUser +
                '&AUTHTOKEN=' +
                SESSION.AUTHTOKEN +
                '&HashCode=' +
                uri;
        xmlHttpRequest.callerObject = callerObject;
        xmlHttpRequest.addEventListener('load', setHashedUri);
        xmlHttpRequest.open('GET', request, true);
        xmlHttpRequest.send();
        return;
    }

    /**
     * creeert een A element en activeerd deze
     */
    function openGeneratedExcel(url) {
        url = url || SESSION.activePage.createdExcelUrl;
        if (!url) {
            return;
        }
        let a = SCOPE.sessionDoc.getElementById('WS_XLS_HREF');

        if (BrowserDetect.isFirefox) {
            window.open(url);
            return;
        }
        if (!a) {
            const form = SCOPE.pageDoc.getElementsByTagName('FORM')[0];
            if(!form) return;

            a = SCOPE.sessionDoc.createElement('A')
            a.id = 'WS_XLS_HREF';

            form.appendChild(a);
        }
        a.setAttribute('href', url);
        XDOM.invokeClick(a);
        return;
    }

    this.open = open;
    this.setObjValue = setObjValue;
    this.update = update;
    this.handleOnClick = handleOnClick;
}.apply(Link));

/* upload-single */
/* Load Timestamp 13:59:55.638 */
var SingleUpload = {};

(function () {
        // /**
        //  * types of file filter
        //  */
        // const filterDev = {
        //   '*OFFICE':
        //     '.docx, .docm, .dotx, .dotm, .xlsx, .xlsm, .xltx, .xltm, .xlsb, .xlam, .pptx, .pptm, .potx, .potm, .ppam, .ppsx, .ppsm, .sldx, .sldm, .thmx, .pdf, .xls, .doc, .ppt, .xps',
        //   '*DATA': '.csv, .xlm',
        //   '*WORD': '.docx, .docm, .dotx, .dotm, .doc',
        //   '*EXCEL': '.xlsx, .xlsm, .xltx, .xltm, .xlsb, .xlam, .xls',
        //   '*XML': '.xml',
        //   '*CSV': '.csv',
        //   '*PDF': '.pdf',
        //   '*IMAGE': 'image/*',
        //   '*ALL': '*.*'
        // };

        /**
         * Enumeratie om status weer te geven:
         * B, blank: field was leeg en veld is leeg
         * S, select: veld was leeg en veld is gevuld
         * C, changed: veld was gevuld en veld is gevuld met een andere waarde
         * D, delete:  veld was gevuld en veld is leeg
         * P, processed Veld was gevuld en veld is verwerkt op server
         */

        /**
         * actions to be performed by the server
         */
        const serverAction = {
            delete: 'D',
            change: 'C',
            upload: 'S',
            none: ''
        };

        /**
         * update of component
         * @param {HTMLElement} obj
         */
        function update() {
            const uploads = XDOM.queryAll('[data-component="upload"]');
            uploads.forEach(updateComponent);
        }

        /**
         * update of component
         * @param {HTMLElement} obj
         */
        function updateComponent(obj) {
            const fileInputElement = getFileInput(obj)
            Array.from(obj.children).forEach(registerEvents);
            registerEvents(obj);
            setValue(obj);

            // Add hover
            if (obj) {
                registerHoverEvent(obj);
            }

            fileInputElement.addEventListener('change', onChange, false);
            obj.addEventListener('drop', drop, false);
            obj.addEventListener('paste', paste, false);
            obj.querySelector('img').addEventListener('mouseover', UploadThumbnail.mouseover, false);
            setDeleteIcons(obj);
        }

        function showHideDelete(obj, deleteIcon) {
            // hide delete field
            deleteIcon.style.display = 'none';

            const {
                deleteField,
                state
            } = obj.dataset;

            const headerData = SESSION.activeData.headerData;

            // do we have a delete field if not we don't show delete so return
            if (!deleteField) {
                return;
            }

            // is there something to delete if not we don't show delete so return
            if (state != 'server') {
                return;
            }

            // is delete enabled field explicitly set to "1" we don't show delete so return
            if (headerData[deleteField + '_HDN'] == '1') {
                return;
            }

            // so it must be true than
            deleteIcon.style.display = 'inline-block';
        }


        /**
         * indicates weather or not the delete-field is enabled
         * @param obj
         * @param deleteIcon
         */
        function enableDelete(obj, deleteIcon) {
            const {
                deleteField,
            } = obj.dataset;


            const headerData = SESSION.activeData.headerData;
            // is the "delete enabled" field present and explicitly set to "0"
            const disabled = (headerData[deleteField + '_AVL'] == '0')
            if (disabled) {
                deleteIcon.setAttribute('data-button-enabled', 'false')
                return;
            }
            deleteIcon.setAttribute('data-button-enabled', 'true')
        }


        function setDeleteIcons(obj) {
            const deleteIcon = obj.querySelector('[data-click="deleteServer"]');
            //do we have a delete button
            if (!deleteIcon) {
                return;
            }
            showHideDelete(obj, deleteIcon);
            enableDelete(obj, deleteIcon);

        }


        /**
         * sets filter to file input object
         * @param {HTMLInputElement} obj file input object
         */
        function setFilter(obj) {
            const filter = UploadCommon.getFilter(obj),
                fileObject = getFileInput(obj);
            if (!filter || !fileObject) {
                return;
            }
            fileObject.accept = filter;
            return fileObject;
        }

        /**
         * gets the file input element
         * @param {HTMLElement} [parentObject] parent object
         * @returns {HTMLInputElement} file input element
         */
        function getFileInput(parentObject) {
            // Get input
            let input = parentObject.querySelector('input[type="file"]');

            // Clean input if no state change
            cleanInput(input);

            // Return input
            return input;
        }

        /**
         * gets the delete input element
         * @param {HTMLElement} [parentObject] parent object
         * @param {string} [status]
         */
        function setDelete(parentObject, value) {
            const el = parentObject.querySelector('input[data-upload-field-type="delete"]');
            if (!el) return;
            el.value = value;
        }

        /**
         * sets the current status
         * @param {HTMLElement} [parentObject] parent object
         * @param {string} [status]
         * @returns {HTMLInputElement} file input element
         */
        function setState(parentObject, status) {
            parentObject.querySelector('input[data-upload-field-type="status"]').value = status;
        }

        /**
         * clickhandler for showing the uploaded file
         * @param {PthEvent} ev
         */
        function click(ev) {
            if (ev.invokeObject.classList.contains('icons')) {
                Link.open(getParent(ev.invokeObject));
            }
        }

        /**
         * sets the alias if any
         * otherwise it sets the file name directly
         * @param {HTMLElement} obj
         * @param {string} uri
         */
        function setAlias(obj, uri) {
            let alias = '';
            //   switch (obj.dataset.linkAliasType) { -- MVB
            switch (obj.dataset.aliasType) {
                case '*IMG':
                    break; // no alias only an icon or thumbnail
                case '*VAR':
                    alias = SESSION.activeData.headerAttributes[obj.dataset.aliasField];
                    break;
                case '*LBL':
                    alias = getCaption(obj.dataset.linkAlias, ''); //set to one space to prevent default value
                    break;
                default:
                    alias = getFilenameFromUrl(uri);
                    break;
            }
            setFileName(obj, alias);
        }

        /**
         * set value to this object
         * @param {HTMLElement} obj
         */
        async function setValue(obj) {
            let uri = SESSION.activeData.headerData[obj.dataset.linkField] || '',
                state = uri ? 'server' : 'empty';

            obj.dataset.uri = uri;
            obj.dataset.serverHasFile = uri != '';
            obj.dataset.state = state;
            obj.dataset.extension = getExtention(uri);

            if (!checkState()) {
                // Get input and thumbnail
                let input = obj.querySelector('input[type="file"]');
                let thumbnail = obj.querySelector('.upload-image img');

                cleanInput(input);

                // Grab image from server
                if (uri) {
                    setAlias(obj, uri);
                } else {
                    setFileName(obj);
                }
                setFilter(obj);

                await UploadThumbnail.set(obj, uri);
            } else if (SESSION.activeData.headerData['STFIM_STS'] == 'D') {
                // If state is delete then make sure that data-state is set to delete
                obj.dataset.state = 'delete';
            }
        }

        function checkState() {
            // Return boolean if state has changed
            return ((SESSION.activeData.headerData['STFIM_STS'] == 'C') || (SESSION.activeData.headerData['STFIM_STS'] == 'D'));
        }

        function cleanInput(input) {
            // Check whether a change has been made
            if (!checkState()) {
                // Reset the input value
                input.value = '';
            }
        }

        function registerHoverEvent(obj) {
            // Get the image from the object and register a mouesover event for overflow handling
            let image = obj.querySelector('.upload-image img');

            image.addEventListener('mouseover', () => {
                setOverflow(image, obj);
            });
        }

        function setOverflow(element, parent) {
            // Get iframe body for height calculations (we are using the viewport width)
            let form = parent.closest('body');

            // Setup initial direction variables
            let vertical = 'top';
            let horizontal = 'left'

            // Get height and width scaled by *6
            let height = (element.clientHeight * 6) + parent.offsetTop;
            let width = (element.clientWidth * 6) + parent.offsetLeft;

            // Check height for overflow on bottom of page
            if ((height) > (form.scrollHeight - 32)) {
                vertical = 'bottom';

                element.classList.add('bottom');
                element.classList.remove('top');
            } else {
                element.classList.add('top');
                element.classList.remove('bottom');
            }

            // Check width for overflow on bottom of page
            if ((width) > (window.innerWidth - 36)) {
                horizontal = 'right';
            }

            // Set transform direction
            element.style.transformOrigin = (vertical + ' ' + horizontal);
        }

        /**
         * sets dragevents
         * @param {HTMLElement} obj
         */
        function registerEvents(obj) {
            obj.addEventListener('dragenter', dragenter, false);
            obj.addEventListener('dragleave', dragleave, false);
            obj.addEventListener('dragover', dragover, false);
        }

        /**
         * apply highlight style
         * @param {HTMLElement} obj
         */
        function highlight(obj) {
            obj.classList.add('upload-highlight');
        }

        /**
         * removes highlight style
         * @param {HTMLElement} obj
         */
        function unhighlight(obj) {
            obj.classList.remove('upload-highlight');
        }

        /**
         * drag enter event handler
         * @param {PthEvent} e
         */
        function dragenter(e) {
            highlight(getParent(e.target));
            preventDefaults(e);
        }

        /**
         * dragleave event handler
         * @param {PthEvent} e
         */
        function dragleave(e) {
            unhighlight(getParent(e.target));
            preventDefaults(e);
        }

        /**
         * dragover event handler
         * @param {PthEvent} e
         */
        function dragover(e) {
            highlight(getParent(e.target));
            preventDefaults(e);
        }

        /**
         * checks file name length when not defined by a data-length attribute in the parent it will default to (defaultlength = 200)
         * @param parentObj
         * @param file
         * @returns {boolean}
         */
        function checkLength(parentObj, file) {
            const defaultLength = 200;
            const maxLength = parseInt(parentObj.dataset.length) || defaultLength;
            if (file.name.length <= maxLength) {
                return true
            }

            //build up message
            let message = getCapt('UploadFileNameToLong1')
            message += file.name.substring(0, 20) + '... ';
            message += getCapt('UploadFileNameToLong2');
            message += file.name.length;
            message += getCapt('UploadFileNameToLong3');
            message += maxLength;
            setMessage("A", message);

            return false;

        }


        /**
         * sets selected file
         * @param {HTMLElement} parentObj
         * @param {file} file
         */
        async function setFile(parentObj, file) {
            if (parentObj.dataset.state == 'server') {
                return;
            }
            //check file length
            if (!checkLength(parentObj, file)) return;

            setFileName(parentObj, file.name);
            parentObj.dataset.state = 'local';
            setForUpload(parentObj);

            return await UploadThumbnail.set(parentObj, file);
        }

        /**
         * onChange event handler
         * @param {PthEvent} e
         */
        async function onChange(e) {
            preventDefaults(e);
            const fileInput = e.target,
                file = fileInput.files[0],
                parentObj = getParent(fileInput);
            await setFile(parentObj, file);
        }


        /**
         * drop event handler
         * @param {PthEvent} e
         */
        async function drop(e) {
            preventDefaults(e);

            const file = e.dataTransfer.files[0],
                parentObj = getParent(e.target),
                fileInput = parentObj.querySelector('input[type="file"]');

            unhighlight(parentObj);
            fileInput.files = e.dataTransfer.files;
            await setFile(parentObj, file);
        }

        async function paste(e) {

            const data = e.clipboardData || e.dataTransfer;
            const parentObj = getParent(e.target);
            const fileInput = parentObj.querySelector('input[type="file"]');
            preventDefaults(e);

            if (!data) {
                return;
            }

            unhighlight(parentObj);

            // Clipboard isn't async enabled so we need to clone it into a DataTransfer (pretty close to a clipboard clone)
            let transfer = new DataTransfer();

            // Loop the files and add them as new files into the transfer
            for (let i = 0; i < data.files.length; i++) {
                transfer.items.add(
                    new File(
                        [data.files[i].slice(0, data.files[i].size, data.files[i].type)],
                        data.files[i].name
                    )
                )
            }

            await setFile(parentObj, data.files[0]);

            fileInput.files = transfer.files;
        }

        /**
         *
         * @param {HTMLElement} parent
         * @param {String} fileName
         */
        function setFileName(parent, fileName = getCapt('lblUploadDragFileHere')) {
            parent.querySelector('.label').innerHTML = fileName;

            // Get file extension
            let fileExtension = getFileExtension(fileName);

            // Check string isn't empty and add class
            if (fileExtension) {
                parent.setAttribute('data-fileType', fileExtension);
            } else if (parent.hasAttribute('data-fileType')) {
                parent.removeAttribute('data-fileType');
            }
        }

// Get the file extension
        function getFileExtension(filename) {
            return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
        }

        /**
         * unsets file to be deleted
         * @param {PthEvent} ev
         */
        function unDeleteFile(ev) {
            const parentObj = getParent(ev.invokeObject);
            parentObj.dataset.state = 'server';
            setForUpload(parentObj);
        }

        /**
         * removes preview and set file to be deleted
         * @param {PthEvent} ev
         */
        function deleteServer(ev) {
            const parentObj = getParent(ev.invokeObject);

            //check if delete is disabled
            if (ev.invokeObject.classList.contains('disabled')) {
                return;
            }
            parentObj.dataset.state = 'delete';
            setState(parentObj, 1);
            setForDelete(parentObj);

            // Set delete state to mimic empty behaviour
            UploadThumbnail.remove(parentObj);
            setFileName(parentObj, getCapt('lblUploadDragFileHere'));
        }

        /**
         * removes local file
         * like clearing an input field
         * @param {PthEvent} ev
         */
        function deleteLocal(ev) {
            deleteServer(ev);
            const parentObj = getParent(ev.invokeObject),
                fileInput = getFileInput(parentObj);
            fileInput.files = null;
            fileInput.value = null;
            UploadThumbnail.remove(parentObj);
            setFileName(parentObj, getCapt('lblUploadDragFileHere'));
            parentObj.dataset.state = 'empty';
            setForDelete(parentObj);
        }

        /**
         * sets server action to be performed
         * for deleting
         * @param {HTMLElement} parent
         */
        function setForDelete(parent) {
            if (parent.dataset.serverHasFile) {
                setState(parent, serverAction.delete);
                setDelete(parent, '1');
            } else {
                setState(parent, serverAction.none);
                setDelete(parent, '');
            }
        }

        /**
         * sets server action to be performed
         * for uploading
         * @param {HTMLElement} parent
         */
        function setForUpload(parent) {
            setDelete(parent, '');
            if (parent.dataset.serverHasFile) {
                setState(parent, serverAction.change);
            } else {
                setState(parent, serverAction.upload);
            }
        }

        /**
         * @param {HTMLElement} obj
         * @returns {HTMLElement} parent Object
         */
        function getParent(obj) {
            return XDOM.getParentByAttribute(obj, 'data-component');
        }

        /**
         * opens native file selector object;
         * @param {PthEvent} ev
         */
        function openFileDialog(ev) {
            UploadCommon.openFileDialog(ev);
            // const parent = ev.invokeObject,
            //   fileObject = getFileInput(parent);
            // XDOM.invokeClick(fileObject);
        }

        this.openFileDialog = openFileDialog;
        this.unDeleteFile = unDeleteFile;
        this.deleteServer = deleteServer;
        this.deleteLocal = deleteLocal;
        this.update = update;
        this.click = click;
    }.apply(SingleUpload)
)
;

/* upload-multiple */
/* Load Timestamp 13:59:55.639 */
// //https://www.smashingmagazine.com/2018/01/drag-drop-file-uploader-vanilla-js/
// var multiUpload = {};

// (function () {
//     function prepareDom(){

//         SCOPE.pageDoc.querySelectorAll('[data-component="multiUpload"]').forEach(obj => render(obj))
//     }

//     function update(){
//         SCOPE.pageDoc.querySelectorAll('[data-component="multiUpload"]').forEach(obj=>{
//             fileList = obj.querySelector(".fileList");
//             const fieldNames = obj.dataset.name.split(' ');
//             fieldNames.forEach(field=>setEntry( headerData[field],'server'));
//         });
//     }

//     function render(obj){

//         obj.innerHTML = `<div class="fileList"></div>
//         <div class="footer" >
//         <div class="label">${lblUploadDragFilesHere}</div>
//         <i class="pth-icon pth-upload dataSectionButton theme-hover-color"
//         data-event-class="SingleUpload"
//         data-click="openFileDialog"
//         data-title-origin="*LBL"
//         data-title-variable="ttlUploadSelectFile" ></i>
//         </div>
//         `
//     }
//     function registerEvents(obj) {
//         obj.addEventListener('dragenter', dragenter, false);
//         obj.addEventListener('dragleave', dragleave, false);
//         obj.addEventListener('dragover', dragover, false);
//         obj.addEventListener('drop', drop, false);
//     }


//     function dragenter(e) {
//         highlight(e.currentTarget);
//         preventDefaults(e);
//     }

//     function dragleave(e) {
//         unhighlight(e.currentTarget);
//         preventDefaults(e);
//     }

//     function dragover(e) {
//         highlight(e.currentTarget);
//         preventDefaults(e);
//     }

//     function drop(e) {
//         unhighlight(e.currentTarget);
//         let dt = e.dataTransfer,
//             files = dt.files,
//             fileList = e.currentTarget.querySelector(".fileList")
//         handleFiles(files);
//         preventDefaults(e);
//     }

//     function highlight(obj) {
//         obj.classList.add('highlight');
//     }

//     function unhighlight(obj) {
//         obj.classList.remove('highlight');
//     }

//     function unDeleteFile(e) {
//         e.target.parentNode.dataset.state = "server";
//     }

//     function deleteFile(e) {
//         let obj = e.target.parentNode;
//         if (obj.dataset.state == 'local') {
//             obj.remove();
//             return;
//         }
//         obj.dataset.state = "delete";

//     }





//     function handleFiles(files) {
//         let filesIterator = ([...files])
//         //filesIterator.forEach(uploadFile);
//         filesIterator.forEach(addFile);
//     }

//     function addFile(file) {
//         let reader = new FileReader();
//         reader.readAsDataURL(file)
//         reader.onloadend = function () {setEntry( file.name,'local',reader)};
//     }

//     function setEntry(fileName,state, reader=null){
//         if(!fileName){return;}
//         let extention = fileName.substr(fileName.lastIndexOf('.') + 1).toUpperCase();
//         fileList.innerHTML += `<div class="file" data-state="${state}" data-file-name="${fileName}">
//         ${getIcon(reader,fileName, extention )}
//         <label>${fileName}</label>
//         <i  data-click="deleteFile" title="${captions.delete_file}" data-event-class="multiUpload" class="fa fa-times"></i>
//         <i  data-click="unDeleteFile" title="${captions.unDelete_file}" data-event-class="multiUpload" class="fa fa-refresh"></i>
//         </div>`
//     }

//     function getIcon(reader, fileName, extention) {
//         if (isImage(extention)) {
//             if(reader){
//                 return `<img onmouseover="multiUpload.previewImage(event)" data-event-class="multiUpload" src="${reader.result}"></img>`;
//             }else{
//                 return `<img onmouseover="multiUpload.previewImage(event)" data-event-class="multiUpload" src="${fileName}"></img>`;
//             }

//         }
//         return `<i class="fa fa-icon"  data-icon="${extention}"></i>`
//     }

//     function isImage(extention) {
//         return imageExtentions.indexOf(extention)>-1;
//     }


//     function previewImage(e) {
//         let currentPreview = document.querySelector(".multiUpload-image-preview"),
//             container = document.getElementById("DTADIV"),
//             x = 0,
//             y = 0,
//             obj = e.target.cloneNode();
//         if (currentPreview) {
//             if (currentPreview.src == obj.src) {
//                 return;
//             }
//             currentPreview.remove();
//         }
//         obj.addEventListener("mouseout", e => e.target.remove());
//         obj.className = 'multiUpload-image-preview';
//         container.appendChild(obj);
//         x = e.clientX - (obj.offsetWidth / 2);
//         y = e.clientY - (obj.offsetHeight / 2);
//         if (x + obj.offsetWidth > container.offsetWidth) {
//             x = container.offsetWidth - obj.offsetWidth - 10;
//         }
//         if (x < 0) {
//             x = 10;
//         }
//         if (y + obj.offsetHeight > container.offsetHeight) {
//             y = container.offsetHeight - obj.offsetHeight - 10;
//         }
//         if (y < 0) {
//             y = 10;
//         }
//         obj.style.left = x + 'px';
//         obj.style.top = y + 'px';
//     }

//     function uploadFile(file) {
//         console.log('uploadddddddddddd');
//         return;
//         let url = 'YOUR URL HERE'
//         let formData = new FormData()

//         formData.append('file', file)

//         fetch(url, {
//                 method: 'POST',
//                 body: formData
//             })
//             .then(() => { /* Done. Inform the user */ })
//             .catch(() => { /* Error. Inform the user */ })
//     }

//     this.prepareDom = prepareDom;
//     this.update = update;
//     this.deleteFile = deleteFile;
//     this.unDeleteFile = unDeleteFile;
//     //this.previewImage = previewImage;
// }).apply(multiUpload);
/* upload-thumbnail */
/* Load Timestamp 13:59:55.639 */
var UploadThumbnail = {};

(function() {
    /**
     * creats icon or image preview dependinig on content
     * @param {HTMLElement} parent
     * @param {File} fileName
     */
    async function set(parent, file) {

        const fileIsUrl = typeof file == 'string',
            fileName = fileIsUrl ? file : file.name;
        if (isImage(getExtention(fileName))) {
            if (fileIsUrl) {
                setFromUrl(parent,fileName);
            } else {
                await setFromFile(parent, file);
            }
        } else {
            setIcon(parent, fileName);
        }
    }

    /**
     * creats icon
     * @param {HTMLElement} parent
     * @param {String} fileName
     */
    function setIcon(parent, fileName) {
        let img = parent.querySelector('img'),
            icon = parent.querySelector('[data-icon]');
        icon.setAttribute('data-icon', getExtention(fileName));
        img.style.display = 'none';
        icon.style.display = 'inline';
    }

    function setFromUrl(parent, file) {
        let img = parent.querySelector('img'),
            icon = parent.querySelector('[data-icon]');
        icon.style.display = 'none';
        img.style.display = 'inline';
        img.src = file;
    }

    /**
     * creats image thumbnail from a file object
     * @param {HTMLElement} parent
     * @param {File} fileName
     */
    async function setFromFile(parent, file) {
        let img = parent.querySelector('img'),
            icon = parent.querySelector('[data-icon]'),
            reader = await readerAsDataURL(file);
        icon.style.display = 'none';
        img.style.display = 'inline';
        img.src = reader.result;
    }

    /**
     * hides thumbnail or icon
     */
    function remove(parent) {
        let img = parent.querySelector('img'),
            icon = parent.querySelector('[data-icon]');
        img.style.display = 'none';
        img.src = '';
        icon.style.display = 'none';
    }

    /**
     * creates a preview of an image on mouseover
     * @param {event} e
     */
    function mouseover(e) {
        /*    let currentPreview = XDOM.query('.UploadThumbnail-image-preview'),
      container = XDOM.query('#DTADIV'),
      x = 0,
      y = 0,
      obj = e.target.cloneNode();
    if (currentPreview) {
      if (currentPreview.src == obj.src) {
        return;
      }
      currentPreview.remove();
    }
    obj.addEventListener('mouseout', e => e.target.remove());
    obj.className = 'UploadThumbnail-image-preview';
    container.appendChild(obj);
    x = e.clientX - obj.offsetWidth / 2;
    y = e.clientY - obj.offsetHeight / 2;
    if (x + obj.offsetWidth > container.offsetWidth) {
      x = container.offsetWidth - obj.offsetWidth - 10;
    }
    if (x < 0) {
      x = 10;
    }
    if (y + obj.offsetHeight > container.offsetHeight) {
      y = container.offsetHeight - obj.offsetHeight - 10;
    }
    if (y < 0) {
      y = 10;
    }
    obj.style.left = x + 'px';
    obj.style.top = y + 'px'; */
    }

    this.remove = remove;
    this.set = set;
    this.mouseover = mouseover;
}.apply(UploadThumbnail));

/* upload-common */
/* Load Timestamp 13:59:55.639 */
var UploadCommon = {};

(function () {
    const filterDev = {
        '*OFFICE':
            '.docx, .docm, .dotx, .dotm, .xlsx, .xlsm, .xltx, .xltm, .xlsb, .xlam, .pptx, .pptm, .potx, .potm, .ppam, .ppsx, .ppsm, .sldx, .sldm, .thmx, .pdf, .xls, .doc, .ppt, .xps',
        '*DATA': '.csv, .xlm',
        '*WORD': '.docx, .docm, .dotx, .dotm, .doc',
        '*EXCEL': '.xlsx, .xlsm, .xltx, .xltm, .xlsb, .xlam, .xls',
        '*XML': '.xml',
        '*CSV': '.csv',
        '*PDF': '.pdf',
        '*IMAGE': 'image/*',
        '*ALL': '*.*'
    };

    function getFilter(obj) {
        let dynamicAllow = SESSION.activeData.headerAttributes[obj.dataset.uploadFiletypeField],
            allow = obj.dataset.uploadFiletype,
            filter = filterDev[allow] || filterDev['*ALL']; //fallback will alwasy be *ALL

        // in case of a dynamic field value
        if (dynamicAllow) {
            //set filter to dynamic preset from filterdev or if non existent set dynamicAllow directly
            filter = filterDev[dynamicAllow] ||  dynamicAllow;
        }

        if (!filter) {
            setMessage('F', 'onbekende file definitie voor upload: ' + allow);
            return;
        }
        return filter;
    }

    function setFilter(obj) {
        const filter = getFilter(obj),
            fileObject = getFileInput(obj);
        if (!filter || !fileObject) {
            return;
        }
        fileObject.accept = filter;
        return fileObject;
    }

    function getFileInput(obj) {
        return obj.querySelector('input[type="file"]');
    }

    /**
     * opens native file selector object;
     * @param {pthEvent} ev
     */
    function openFileDialog(ev) {
        const parent = getParent(ev.invokeObject),
            fileObject = setFilter(parent);
        XDOM.invokeClick(fileObject);
    }

    function getParent(obj) {
        return XDOM.getParentByAttribute(obj, 'data-component');
    }

    this.getFilter = getFilter;
    this.openFileDialog = openFileDialog;
}.apply(UploadCommon));

;
/* linkViewer */
/* Load Timestamp 13:59:55.639 */
/* global XDOM, BrowserDetect, Panel, Dragger, GLOBAL, SETTINGS, SESSION, ENUM, keyCode, PdfViewer */
const Linkviewer = {};
(function () {
    let placeHolder = null,
        uri = '',
        extension = '',
        uriType = '',
        callerObject = null,
        viewType = "*FIXED",
        plugins = {},
        popupSettings = {
            titleOrigin:'*LBL',
            popupTitle:'linkviewer',
            rows:'22',
            cols:'95',
            resizable:true,
            dockable:true
        }


    function getPlugin(args){
        let pluginName = args.extention || args.protocol || '';
        pluginName = pluginName.replace('*','');
        return plugins[pluginName];
    }

    function getPlaceHolder(args){
        if(args.isFixed){
            return XDOM.getObject(args.id);
        }
        popupSettings.id = args.id;
        popupSettings.directTitle = args.fileName || " ";
        return popupPanel.open(popupSettings);
    };



    function open(args){
        if(!supports(args)){return false;}
        if(!args.uri && !args.isFixed){ return false;}
        let plugin      = getPlugin(args);
        placeHolder = getPlaceHolder(args);
        if(placeHolder.dataset.lastUri == args.uri){
            return true; //huidige uri wordt al getoond niets meer doen
        }
        placeHolder.dataset.lastUri = args.uri;


        XDOM.removeAllChilds(placeHolder);
        if(!plugin){return false;}
        plugin(placeHolder, args.uri);
        return true;
    }

    function supports(args){
        let pluginName = args.extention || args.protocol || '';
        pluginName = pluginName.replace('*','');
        if(plugins[pluginName]) {return true};
        return false;
    }

    this.plugins = plugins;
    this.open = open;
    this.supports = supports;

}).apply(Linkviewer);

/* pdfViewer */
/* Load Timestamp 13:59:55.640 */

const PdfViewer = {};
(function () {
    function getViewer(viewerObj){
        XDOM.removeAllChilds(viewerObj);
        pfdViewObj = document.createElement("iframe");
        pfdViewObj.className = "pdfViewerContainer";
        viewerObj.appendChild(pfdViewObj);
        return pfdViewObj;
    };


    function setValue(viewerObj,objValue ){
        var pdfPreviewContainer =getViewer(viewerObj)
        if(!pdfPreviewContainer){
            return;
        }
        pdfPreviewContainer.setAttribute("src", SESSION.pdfViewer+"?file="+objValue);
    }


    Linkviewer.plugins.PDF = setValue;

}).apply(PdfViewer);
/* httpViewer */
/* Load Timestamp 13:59:55.640 */

const httpViewer = {};
(function () {

    function getViewer(viewerObj){
        let httpViewObj = viewerObj.querySelector("iframe");
        if(httpViewObj){
            return httpViewObj;
        }

        httpViewObj = document.createElement("iframe");
        httpViewObj.className = "pdfViewerContainer";
        viewerObj.appendChild(httpViewObj);
        return httpViewObj;
    };

    // function checkUri(viewerObj,uri){
    //   const xmlHttpRequest = new XMLHttpRequest();
    //   xmlHttpRequest.viewerObj = viewerObj;
    //   xmlHttpRequest.addEventListener('load', load);
    //   xmlHttpRequest.addEventListener('error', error);
    //   xmlHttpRequest.open("GET", uri, true);
    //   xmlHttpRequest.send();

    //   if(xmlHttpRequest.status === 404){
    //     error(viewerObj)
    //   }
    // }

    function load(resonse){
        const viewContainer =getViewer(viewerObj)
        if(!viewContainer){return;}
        viewContainer.srcdoc = this.responseText;
        viewContainer.src = "data:text/html;charset=utf-8," + escape(this.responseText);
        //viewContainer.setAttribute("src", uri);
    }

    // function error(viewerObj){

    //    viewerObj.innerHtml = "SORRY de pagina bestaat niet meer";

    // }


    function setValue(viewerObj,uri ){
        const viewContainer =getViewer(viewerObj)
        if(!viewContainer){return;}
        viewContainer.setAttribute("src",uri);
    }


    Linkviewer.plugins.HTTP = setValue;

}).apply(httpViewer);
/* imageViewer */
/* Load Timestamp 13:59:55.640 */

const ImageViewer = {};
(function () {
    function setValue(viewerObj,uri ){
        const imageObject =  new Image();
        XDOM.removeAllChilds(viewerObj);
        viewerObj.appendChild(imageObject);
        //XDOM.addEventListener(imageObject, 'error', oculusImage.onError);
        imageObject.src = uri;
    }
    //Linkviewer.plugins.JPG = setValue;

}).apply(ImageViewer);
/* ajax */
/* Load Timestamp 13:59:55.641 */
/* global SESSION */

var AJAX = function () {
};

AJAX.loadMacro = function (macro) {
    if (SESSION.activePage) {
        closeAllModalObjects();
    }
    SESSION.submitFromScope = 'MAIN';
    var url = macro.url + '&TIMESTAMP=' + new Date().getTime();
    AJAX.get(url, AJAX.handleResponse);
};


AJAX.get = function (url, onResponse) {
    time('get');
    time('get (totaal)');
    var request = new XMLHttpRequest();
    request.addEventListener('load', onResponse);
    request.open("GET", url, true);
    request.send();
};
AJAX.getForm = function () {
    var formObjects = SESSION.activeForm.querySelectorAll("input:not([type='button']),textarea"),
        fd = new FormData(),
        obj = null,
        objVal = "";

    for (var i = 0, l = formObjects.length; i < l; i++) {
        obj = formObjects[i];
        objVal = "";
        if (obj.type === "file") {
            if (obj.files[0]) {

                objVal = obj.files[0];
            }
            fd.append(obj.name, objVal);
        } else {

            if (XDOM.getBooleanAttribute(obj, "data-unicode")) {
                objVal = XDOM.hexEncode(obj.value);
            } else if (obj.getAttribute("data-datatype") == "*MEMO") {
                objVal = XDOM.rightTrim(obj.value); //strip  all enters and spaces from the end of the string.
            } else {
                objVal = obj.value;
            }

            fd.append(obj.name, objVal);
        }
    }
    for (var field in SESSION.activePage.controlerFields) {
        if (SESSION.activePage.controlerFields[field]) {
            fd.append(field, SESSION.activePage.controlerFields[field]);
        }
    }

    return fd;
};

AJAX.postPartialUpdate = () => {
    let url = SESSION.activePage.pageUrl.split('?')[0];
    url += "?AUTHTOKEN=" + SESSION.AUTHTOKEN
    const request = new XMLHttpRequest();
    request.addEventListener('load', AJAX.handlePartialUpdate);
    request.open("POST", url, true);
    request.send(AJAX.getForm());
}

AJAX.handlePartialUpdate = response => {
    // let responseResult = AJAX.resolveResponse(response);
    const responseText = response.target ? response.target.responseText : response;
    const parser = new DOMParser();
    const doc = parser.parseFromString(responseText, "application/xml");

    //data will come in as overide data
    const overrideDataTag  = doc.getElementsByTagName("overrideData")[0];
    if(!overrideDataTag){
        return;
    }
    //get cdata section of tag
    let data = overrideDataTag.firstChild.data;

    //getting the right stuff out
    const {overrideData} = JSON.parse(data);

    // removing submit for select to prevent from being set by other submits
    XDOM.removeInput('SubmitForSelect')
    SESSION.activePage.partialUpDate(overrideData);
}






AJAX.postForm = function () {
    time('post (totaal)');
    time('post');
    let url = SESSION.activePage.pageUrl.split('?')[0];
    url += "?AUTHTOKEN=" + SESSION.AUTHTOKEN;
    SESSION.activePage.controlerFields["RequirePageDef"] =SESSION.session.debugMode

    const request = new XMLHttpRequest();
    request.addEventListener('load', AJAX.handleResponse);
    request.open("POST", url, true);
    request.send(AJAX.getForm());
};

AJAX.resolveResponse = function (response) {
    var xmlDoc = null,
        ipmfAction = '',
        json = '',
        pageDef = '',
        Tag = null,
        errorCallStack = null,
        errorMessage = '',
        data = null,
        result = {},
        responseText = response.target ? response.target.responseText : response;


    try {
        xmlDoc = XDOM.getXML(responseText);
        if (xmlDoc.getElementsByTagName("action")[0]) {
            ipmfAction = xmlDoc.getElementsByTagName("action")[0].childNodes[0].nodeValue;
            if (ipmfAction && (ipmfAction == "IPMF_Update")) {
                AJAX.Page.updateAfterIpmfSubmit();
                return;
            }
        }

        json = xmlDoc.getElementsByTagName("data")[0].childNodes[0].nodeValue;
        pageDef = xmlDoc.getElementsByTagName("pageDef")[0];
        Tag = xmlDoc.getElementsByTagName("errorMessage")[0];
        if (Tag) {
            errorMessage = Tag.childNodes[0].nodeValue;
            Tag = xmlDoc.getElementsByTagName("errorCallStack")[0];
            if (Tag) {
                errorCallStack = Tag.childNodes[0].nodeValue;
            }
        }
    } catch (e) {
        console.log(responseText);
        SCOPE.main.Dialogue.alert('net.data of xml format fout zie logfile van browser');
        return;
    }
    try {
        data = JSON.parse(json);
    } catch (e) {
        console.log(json);
        SCOPE.main.Dialogue.alert('json format fout zie logfile van browser');
        return;
    }

    if(data.overrideData){
        // Or, using array extras
        Object.entries(data.overrideData).forEach(([name, value]) => {
            data.headerData[name] = value
        });
    }


    if (data.viewProperties && data.viewProperties.netDataError) {
        SCOPE.main.Dialogue.alert(data.viewProperties.netDataError);
        if (pageDef) {
            console.clear();
            console.log(pageDef.textContent);
        }
    }
    if (errorMessage) {
        SCOPE.main.Dialogue.alert('er is een net data error opgetreden op de server \n zie logfile van browser');
        console.clear();
        console.log(errorMessage);
        console.log(errorCallStack);
    }
    result.data = data;
    if (pageDef) {
        result.pageDef = pageDef.textContent;
    }
    return result;
};

AJAX.getActivePage = function (data) {
    if (!data.macroProperties) {
        //no changes were made so set the the apropriate flag
        SESSION.activePage.resubmit = true;
        return;
    }
    SESSION.activePage = SESSION.pageStore[data.macroProperties.cacheKey];

    //we changed page so this was not submited from it self
    if(SESSION.activePage){
        SESSION.activePage.resubmit = false;
    }

};


AJAX.handleResponse = function (response) {
    var responseResult = null;
    responseResult = AJAX.resolveResponse(response);

    if (!responseResult) {
        return; //==>
    }

    AJAX.getActivePage(responseResult.data);
    if (SESSION.activePage) {    //pagina is ooit eerder in deze sessie opgeroepen of is de huidige pagina
        timeEnd('AJAX.handleResponse (script)');
        SESSION.activePage.reNew(responseResult);
    } else {//pagina nog niet bekend ga het render traject in
        AJAX.Page.newPage(responseResult.pageDef, responseResult.data);
    }
};
/**
 * Onload op script tag dat het laden van taal afhankelijke onderdelen zoals captions en serversources regeld
 * pas nadat deze is geladen is alles voor de pagina binnen en kan er verder worden gegaan met de onload procedure
 * @returns {undefined}
 */
AJAX.onload = function () {
    timeEnd('load text script (server)');
    timeEnd('AJAX.handleResponse (script)');
    SESSION.activeForm = SESSION.activeFrame.document.forms[0];

    SESSION.activeFrame.document.body.setAttribute("data-session-id", SESSION.id);



    showFrame(SESSION.activePage.screenType);

    SESSION.activePage.prepareDom();
    SESSION.activePage.autoRenewDom();

    // Ensure that the SESSIONFRAME has the right theme classes - TODO: @JVE is this ok?
    SESSIONFRAME.frameElement.contentDocument.body.classList.add(mainState().state.skinMode.value);
};

//   AJAX.fetchPost =function(url = ``, data = {}) {
//   // Default options are marked with *
//     return fetch(url, {
//         method: "POST", // *GET, POST, PUT, DELETE, etc.
//         mode: "cors", // no-cors, cors, *same-origin
//         cache: "no-cache", // *default, no-cache, reload, force-cache, only-if-cached
//         credentials: "same-origin", // include, *same-origin, omit
//         headers: {
//             "Content-Type": "application/json",
//             // "Content-Type": "application/x-www-form-urlencoded",
//         },
//         redirect: "follow", // manual, *follow, error
//         referrer: "no-referrer", // no-referrer, *client
//         body: JSON.stringify(data), // body data type must match "Content-Type" header
//     })
//     .then(response => response.json()); // parses response to JSON
// }
/* actionButton */
/* Load Timestamp 13:59:55.641 */
/* global XDOM, GLOBAL, gPRC001, SESSION, Subfile, Command, msgNoSelection */

/**
 *  disabled of niet
 *  data-button-enabled-field-id = indicator veld met waarde 1/0 voor true/false
 *  data-button-default-enabled  = true/false -> als indicator niet gevonden is, is dit de waarde
 *
 *
 *  data-modef-field-id          = MODEF  (veld die aangeeft welke knop er actief is)
 *  data-modef-active-condition  = ADD/UPDATE/DELETE (wat voor knop is dit)
 *
 *  wordt op true gezet als de knop aanklikbaar is, dat wil zeggen actief en niet
 *  data-button-enabled
 *
 *  logica:
 *  een knop is disabled actief of enabled en niet actieve
 *  enabled en niet actieve
 **/

//<div id="GRDMLD" class="hidden btn28px floatRight none" data-title="GRDMLD_TTL" data-action-code="*HTM54" data-button-enabled-field-id="GRDMLD_AVL" data-button-default-enabled="true"></div>

function ActionCommand() {
}


/**
 * registreerd eventhandlers
 * al dan niet activeren van user action knoppen hangt af van de
 * de array SESSION.stack.currentMacro.userActionTargets. Dit is een associatieve array met als sleutels de userActions
 * als het attribute data-action-code als sleutel in deze array voorkomt moet hij getoond worden
 */

ActionCommand.updateDom = function () {
    var foPageObjects = XDOM.queryAll('[data-action-code]', SESSION.activeForm);
    var faActionTargets = SESSION.stack.currentMacro.getUserActionTargets();
    var fsTitle = '';
    var fsTitelCode = '';
    var fsActionCode = '';
    var fsContentCode = '';
    var foObj = null;

    if (foPageObjects.length == 0 || !faActionTargets) {
        return; //geen acction command knoppen
    }
    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        foObj = foPageObjects[i];
        fsActionCode = XDOM.getAttribute(foObj, 'data-action-code');
        fsContentCode = XDOM.getAttribute(foObj, 'data-action-char');

        if (faActionTargets[fsActionCode]) {
            foObj.setAttribute("data-hidden", "false");
        }

        var contentField = null;
        if (fsContentCode) {
            contentField = XDOM.createElement("span", null, "actionBtnContent");
            contentField.setAttribute("data-actionBtn-char", "true");
            contentField.innerHTML = fsContentCode;
            foObj.appendChild(contentField);
        }

    }
};

/**
 * wordt uitgevoerd bij het opnieuw laden van de pagina en bepaald welke MODEF knoppen er actief, inactief en disabled worden aan de hand van de data
 */
ActionCommand.update = function () {
    var foPageObjects = XDOM.queryAll('[data-action-code]', SESSION.activeForm);
    var faActionTargets = SESSION.stack.currentMacro.getUserActionTargets();
    var foObj = null;
    var fsActionCode = '';

    if (foPageObjects.length == 0) {
        return; //geen modef knoppen
    }
    SESSION.activePage.setRecord(null); //set
    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        foObj = foPageObjects[i];
        fsActionCode = XDOM.getAttribute(foObj, 'data-action-code');
        if (faActionTargets && faActionTargets[fsActionCode]) {
            foObj.setAttribute("data-hidden", "false");
        } else {
            foObj.setAttribute("data-hidden", "true");
        }
        enableButton(foObj);
    }


};

function enableButton(foObj) {
    var fsEnabledIndicatorFIeld = foObj.id + "_AVL";
    var fsEnabled = SESSION.activePage.header[fsEnabledIndicatorFIeld];

    if (fsEnabled == "0") {
        foObj.setAttribute("data-button-enabled", "false");
        return false;
    } else if (fsEnabled == "1") {
        foObj.setAttribute("data-button-enabled", "true");
        return true;
    } else if (XDOM.getBooleanAttribute(foObj, "data-button-default-enabled")) {
        foObj.setAttribute("data-button-enabled", "true");
        return true;
    } else {
        foObj.setAttribute("data-button-enabled", "false");
        return false;
    }
}

ActionCommand.isActionButton = function () {
    var actionCode = XDOM.GLOBAL.getAttribute("data-action-code");
    if (!actionCode || actionCode == "") {
        return false;
    }
    return true;
};
/**
 * controleerd in een werken met scherm of er tenminste 1 regel is geselecteerd
 * zo niet toon dan een boodschap
 * @returns {Boolean}
 */
ActionCommand.checkMinSelection = function () {
    var counterObject = XDOM.getObject("logicalCounter");
    if (!counterObject || !ActionCommand.isActionButton()) { //dit is geen werken met scherm
        return true;
    }
    if (counterObject && parseInt(XDOM.getObjectValue(counterObject)) > 0) {
        return true; //werken met scherm met een selectie
    }
    //werken met maar zonder selectie
    setMessage('M', getCapt('msgNoSelection'));
    return false;
};

ActionCommand.handleClick = function () {
    let actionBtnElement = GLOBAL.eventSourceElement;

    // no back submit from search pages
    // no close button
    if(actionBtnElement.dataset.returnFromSearch == "true" || actionBtnElement.dataset.wscmdType=="*CNL"){
        return false // no back submit from search pages
    }
    if (!XDOM.getBooleanAttribute(actionBtnElement, "data-button-enabled")) {
        if (!XDOM.getBooleanAttribute(GLOBAL.eventSourceElement, "data-actionBtn-char")) {
            return false;
        }
        actionBtnElement = GLOBAL.eventSourceElement.parentNode;
    }
    if ( ['print','close','skin','favourites','help'].includes(actionBtnElement.dataset.click) ) {
        return false;
    }

    if (actionBtnElement.getAttribute("data-button-enabled") == "false") {
        return false;
    }

    const fsActionCode = XDOM.getAttribute(actionBtnElement, "data-action-code");
    SESSION.stack.setActionTargetFields(fsActionCode, SESSION.activePage);

    if (fsActionCode != "*NEWRCD" && !ActionCommand.checkMinSelection()) {
        return true;
    }
    Subfile.storeSubfilePos();

    Command.submit(true);
    return true;
};


/* attention */
/* Load Timestamp 13:59:55.641 */
function AttentionLevel (){};

/**
 * tijdelijke update actie later als ajaxi is geimplementeerd wordt dit rechtstreeks bij het zetten van de waarde in het object aangeroepen
 */
AttentionLevel.update = function(){
    var foPageObjects = XDOM.queryAllScope('[data-attention-field-id]');
    for(var i=0,l=foPageObjects.length;i<l;i++){
        AttentionLevel.apply(foPageObjects[i]);
    }
};

AttentionLevel.apply = function(obj){
    var indicatorField = XDOM.getAttribute(obj,"data-attention-field-id");
    if(!indicatorField){return;}
    var recordNr = 	getClientRecordNr(obj);
    var level = null, parentObj = null, attributes = null;

    if(recordNr || recordNr==0){
        attributes = SESSION.activeData.subfileAttributes[recordNr];
        level = attributes[indicatorField];
        parentObj = XDOM.getParentByTagName(obj, 'TD');
        parentObj.setAttribute("data-attention-level", level);
        return;
    }
    level = SESSION.activeData.headerAttributes[indicatorField];

    if(Mask.isPart(obj) && obj.parentElement.tagName=="DIV"){
        obj.parentNode.setAttribute("data-attention-level", level);
    }
    obj.setAttribute("data-attention-level", level);

};

/* Batch */
/* Load Timestamp 13:59:55.641 */
/**
 * object voor het vastleggen van file Links
 * @param fsURL
 * @returns
 */
function Batch(){}
Batch.prepareDom  = function(){
    var textCode = '', text='';
    var messageDiv = XDOM.query('[data-message-label]',SESSION.activeForm);
    if(messageDiv){
        textCode = messageDiv.getAttribute("data-message-label");
        text = getCaption(textCode);
        setMessage("A",text);
    }
};

Batch.update  = function(){
    if(SESSION.activePage.immediateSubmit){
        FieldAttribute.hide(XDOM.getObject('ACCEPT'));
        Command.execute('ACCEPT');
    }

};

/* conditionalAttribute */
/* Load Timestamp 13:59:55.642 */
/* global ENUM, SESSION */

/**
 * Conditional attributes zijn attributen die een gedrag vertonen op basis van data buiten het eigenlijke veld
 * er zijn twee argumenten:
 * @param data-condition-attribute attribute die aangeeft wat er moet gebeuren op basis vcan het indicator veld Mogelijk waarde zijn:
 *  - *RIGHT
 *  - *CENTER
 *  - *HIDDEN
 *  - *PROTECT
 *  - *MSG     :  attention level
 *  - *INF     :  attention level
 *  - *ATN     :  attention level
 *  - *ALR     :  attention level
 *  - *ERR     :  attention level
 * @param data-condition-field-id  verwijzing naar een veld in het currentrecord.attributes deel van de json response van ajax
 * totdat we echt met ajax gaan werken komen indicators in de variabele : (SESSION.activeFrame.IdfJSON.header) die weer in SESSION.activePage.headerIndicators wordt gezet
 */

/**
 * object voor het vastleggen van Conditional Attribute's
 *
 * @returns {ConditionalAttribute}
 */

function ConditionalAttribute() {
}

/**
 * tijdelijke update actie later als ajaxi is geimplementeerd wordt dit rechtstreeks bij het zetten van de waarde in het object aangeroepen
 */
ConditionalAttribute.update = function () {

    var foPageObjects = XDOM.queryAllScope('[data-condition-attribute]');
    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        ConditionalAttribute.apply(foPageObjects[i]);
    }
};


ConditionalAttribute.apply = function (obj) {
    let attribute = obj.getAttribute("data-condition-attribute");
    if (!attribute) {
        return;
    } //--> // MVB verplaatst

    let indicatorField = obj.getAttribute("data-condition-field-id");
    let envIndicatorField = obj.dataset.conditionEnvId;
    let recordNr = getClientRecordNr(obj);
    let indicator = null;
    if (envIndicatorField && SESSION.activeData.environmentConditions) {
        indicator = SESSION.activeData.environmentConditions[envIndicatorField];
    } else if (recordNr || recordNr === 0) {
        if (attribute === '*SEL') {
            indicator = SESSION.activeData.subfileData[recordNr][indicatorField];
        } else {
            indicator = SESSION.activeData.subfileAttributes[recordNr][indicatorField];
        }
    } else {
        indicator = SESSION.activeData.headerData[indicatorField];
    }

    //check if indicator field is present
    if (!hasValue(indicator)) {
        //we are missing an indicator field

        //test is we are in developerMode
        const developerMode = SCOPE.main.Settings.get('ENABLE_DEBUG_TOOLS');

        //not developer mode just leave
        if (!developerMode) return false

        //we are in developer mode so show a message
        SCOPE.main.Dialogue.alert('Het indicatorveld: "' + indicatorField + '" voor Conditional Attribute is niet gedefinieerd',`Conditional Attribute niet gedefinieerd`);
        return false;
    }

    ConditionalAttribute.set(obj, attribute, (indicator === '1' || indicator === 'true' ));
};

ConditionalAttribute.set = function (obj, attribute, set) {
    var parentObj = obj;

    if (getClientRecordNr(obj) != null) {
        parentObj = XDOM.getParentByTagName(obj, 'TD');
    }

    switch (attribute) {
        case "*RIGHT":
            if (set) {
                parentObj.style.textAlign = ENUM.align.right;
            } else {
                parentObj.style.textAlign = '';
            }
            break;
        case "*CENTER":
            if (set) {
                parentObj.style.textAlign = ENUM.align.center;
            } else {
                parentObj.style.textAlign = '';
            }
            break;
        case '*HIDDEN':
            if (set) {
                FieldAttribute.hide(obj);
                FieldAttribute.disable(obj);

            } else {
                FieldAttribute.unHide(obj);
                FieldAttribute.enable(obj);
            }
            break;
        case '*VISIBLE':
            if (set) {
                FieldAttribute.unHide(obj);
                FieldAttribute.enable(obj);
            } else {
                FieldAttribute.hide(obj);
                FieldAttribute.disable(obj);
            }
            break;
        case '*REQUIRED':
            if (set) {
                obj.setAttribute("data-required", "true");
            } else {
                obj.setAttribute("data-required", "unknown");
            }
            break;
        case '*PROTECT':
            if (set) {
                FieldAttribute.protect(obj);
            } else {
                FieldAttribute.unProtect(obj);
            }
            break;
        case '*MSG':
        case '*INF':
        case '*ATN':
        case '*ALR':
        case '*ERR':
        case '*SEL':
            if (set) {
                parentObj.setAttribute("data-attention-level", ENUM.attentionLevelToCode[attribute]);
            } else {
                parentObj.setAttribute("data-attention-level", null);
            }
            break;
    }
};
/* dataAttribute */
/* Load Timestamp 13:59:55.642 */
/**
 * bij data attributen is de waarde in het veld bepaalend voor het uiterlijk van het veld
 *
 * de volgende data attributen zijn bekend:
 * data-left-zero
 * data-left-blank
 * data-signed
 * data-to-upper
 * data-digits
 *
 * is de waarde van deze eigenschappen "true" an dienen de aanpassingen te worden gedaan
 *
 */

function DataAttribute(){}
/**
 * verzameld alle dom objecten die een data attribute hebben en past deze velde aan op basis van die attributen
 * later bij ajax worden de velden aangepast op het moment dat ze met een waarde worden gevuld door middel van de aanroep DataAttribute.apply
 * de volgende data attributen zijn bekend:
 *
 * data-left-zero
 * data-left-blank
 * data-signed
 * data-to-upper
 * data-digits
 *
 */
DataAttribute.update = function(){
    var pageObjects = XDOM.queryAll('[data-value-when-zero]');
    for(var i=0,l=pageObjects.length;i<l;i++){
        DataAttribute.apply(pageObjects[i]);
    }
};


DataAttribute.apply = function(obj){
    if(obj.getAttribute("data-value-when-zero")=="*BLANK"){DataAttribute.whenZero(obj);}
    if(XDOM.getBooleanAttribute(obj,"data-left-zero")){ DataAttribute.leftZero(obj); }
    if(XDOM.getBooleanAttribute(obj,"data-left-blank")){ DataAttribute.leftBlank(obj); }
    if(XDOM.getBooleanAttribute(obj,"data-to-upper")){ DataAttribute.upperCase(obj); }
    if(XDOM.getBooleanAttribute(obj,"data-digits")){ DataAttribute.upperCase(obj); }
};

DataAttribute.leftZero = function(obj){
    var maxLength = obj.getAttribute("maxLength");
    if (obj.value && obj.value.length > '0') {
        obj.value=obj.value.lftzro(maxLength);
    }
};

DataAttribute.leftBlank = function(obj){
    var maxLength = obj.getAttribute("maxLength");
    obj.value=obj.value.lftblk(maxLength);
    obj.setAttribute("value", obj.value);
    return;
};

DataAttribute.upperCase = function(obj){
    if(obj.tagName=="INPUT" || obj.tagName=="TEXTAREA" ){
        obj.value=obj.value.toUpperCase();
        obj.setAttribute("value", obj.value);
    }
    return;
};

DataAttribute.whenZero = function(obj){
    if(obj.getAttribute("data-value-when-zero")!="*BLANK"){
        return;
    }
    var value = XDOM.getObjectValue(obj)
    value = value.replace(',','.');
    value = parseFloat(value);
    if(value==0){
        XDOM.setObjectValue(obj,'');
        setOldValue(obj); //zet de oldvalue ook weer op leeg ivm autosubmit
    }
}

function isAutoSubmitField(obj){
    if(!obj) return false;
    return (XDOM.getBooleanAttribute(obj,"data-autosubmit") ||
        XDOM.getBooleanAttribute(obj,"data-refresh-caller"));
}

/**
 * zoekt in de lijst van velden of er een veld is dat een autosubmit heeft
 * @param fields
 */
function hasAutoSubmitFields(fields){
    for(let i=0,l=fields.length;i<l;i++){
        if(isAutoSubmitField(fields[i])){
            return true;
        }
    }
}
/* scale */
/* Load Timestamp 13:59:55.642 */
/**
 * scaling:
 * Alleen geldig voor voor *DEC velden met een  data-maxscale-system-limit attribute
 *
 * data-precision:               alle cijfers dus voor en na de comma samen
 * data-scale:                   alle cijfers na de comma
 * data-maxscale-system-limit    maximaal aantal cyfers na de comma voor de hele omgeving
 * data-maxscale-field
 * data-maxscale-appearance      wordt dynamisch bepaald voor toepassen van let style ten behoeven van de uitlijning
 *
 * @see P:\20 Productontwikkeling\50 Werkdocumenten\30 Ontwerpen systeemprogrammatuur\01 Versiebeheer\Release 9\Maxscale attributen.docx
 *
 */

/**
 * aanpassen css classes voor output *DEC
 *
 * @param obj
 */
function formatMaxScale(value, globalMaxScale, maxScale, decimalSeparator) {
    var fsDecimalSeparator = SETTINGS.decimalSeparator;
    if (decimalSeparator) {
        fsDecimalSeparator = decimalSeparator;
    }
    var faValue = value.split(fsDecimalSeparator);
    var fsIntPart = faValue[0];
    var fsDecPart = faValue[1];
    if (!fsDecPart) {
        fsDecPart = '';
    }
    var fsShowPart = fsDecPart.substr(0, maxScale);
    var fsHidePart = fsDecPart.substr(maxScale, fsDecPart.length - maxScale);
    var fiDecLength = maxScale;
    var foReturn = {value: '', cssClass: '', valid: false};

    if (fsHidePart == "" || parseInt(fsHidePart) == 0) {
        //geldige opmaak
        fsHidePart = '';
        foReturn.valid = true;
    } else { // ongeldig alles laten zien
        fsShowPart = fsDecPart;
        fiDecLength = fsShowPart.length;

    }

    foReturn.cssClass = 'dec_pos' + fiDecLength + '_' + globalMaxScale;

    if (fsShowPart == '') {
        foReturn.value = fsIntPart;
    } else {
        foReturn.value = fsIntPart + fsDecimalSeparator + fsShowPart;
    }

    return foReturn;
}


function MaxScale(obj, subFileData) {
    this.obj = obj;
    this.isInput = true;
    this.decimalLength = 0;
    this.IntLength = 0;
    this.systemLimit = 0;
    this.decimalValue = '';
    this.intValue = '';
    this.value = '';
    this.subfileData = subFileData;
    this.init();
}

MaxScale.prototype.init = function () {
    this.getObjectValue();
    this.getObjectProperties();
};

MaxScale.prototype.getObjectValue = function () {

    this.isInput = (this.obj.tagName == "INPUT");

    var value = XDOM.getObjectValue(this.obj);
    var aValue = value.split(SETTINGS.decimalSeparator);
    this.intValue = aValue[0];
    if (aValue[1]) {
        this.decimalValue = aValue[1];
    }

};

MaxScale.prototype.getObjectProperties = function () {
    var scale = this.getScale();
    var precision = parseInt(this.obj.getAttribute("data-precision"));
    this.IntLength = precision - parseInt(this.obj.getAttribute("data-scale"));
    this.decimalLength = scale;
};

MaxScale.prototype.getScale = function () {
    var maxScale = null;
    var scaleField = this.obj.getAttribute("data-maxscale-field");
    var returnValue = 0;
    this.systemLimit = parseInt(this.obj.getAttribute("data-maxscale-system-limit"));
    if (this.subfileData) {
        maxScale = this.subfileData[scaleField];
    } else {
        maxScale = SESSION.activeData.headerAttributes[scaleField];
    }

    if (maxScale) {
        returnValue = parseInt(maxScale);
    } else {
        maxScale = this.obj.getAttribute("data-scale");
        if (maxScale) {
            returnValue = parseInt(maxScale);
        } else {
            returnValue = this.systemLimit;
        }
    }


    return returnValue;
};

MaxScale.prototype.validate = function () {

    var fiIntvalue = this.intValue;

    fiIntvalue = fiIntvalue.replace(/\./g, ''); 	//<-- Verwijder eerst alle punten
    fiIntvalue = fiIntvalue.replace(/\,/g, '.');	//<-- Verandere alle komma's door punten ivm Amerikaanse nummer opmaak.

    if (isNaN(this.decimalValue) || isNaN(fiIntvalue)) {
        this.valid = false;
        return false;
    }
    this.decimalValue = this.decimalValue.removeTrailingZeros();
    if (this.isInput) {
        this.valid = (this.decimalValue.length <= this.decimalLength) && (fiIntvalue.length <= this.IntLength);
    } else {
        this.valid = (this.decimalValue.length <= this.decimalLength);
    }
    return this.valid;
};


MaxScale.prototype.complete = function () {
    this.validate();
    this.value = this.intValue;
    if (this.decimalValue == "") {
        this.decimalValue = "0";
    }
    if (this.systemLimit > 0 && this.isInput) {
        this.value += SETTINGS.decimalSeparator + this.decimalValue.rgtzro(this.systemLimit);
    }

    if (this.decimalLength > 0 && !this.isInput) {
        this.value += SETTINGS.decimalSeparator + this.decimalValue.rgtzro(this.decimalLength);
    }
};


/**
 * de patern is opgebouwd als volgd:
 * #####,##00
 * waarbij geld:
 * #### hier wordt # * IntLength getoond
 * ,    alleen getoond indien er spraken is van getallen achter de comma (duh)
 * ##   hier wordt # * this.decimalLength getoond
 * 00   decimalen die de decimalLength overschrijden maar wel binnen de systemLimit vallen
 */
MaxScale.prototype.getPatern = function () {
    var patern = "#".times(this.IntLength);
    var trailingZeros = 0;
    if (this.systemLimit > 0) {
        patern += SETTINGS.decimalSeparator;
        patern += "#".times(this.decimalLength);
        trailingZeros = this.systemLimit - this.decimalLength;
        patern += "0".times(trailingZeros);
    }
    return patern;
};


MaxScale.prototype.apply = function () {
    this.complete();
    if (this.isInput) {
        this.applyToInput();
    } else {
        this.applyToOutput();
    }
    //cleanup voor garbage collection
    this.obj = null;
};

MaxScale.prototype.applyToInput = function () {
    if (this.valid) {
        this.obj.value = this.value;
        this.obj.setAttribute("value", this.value)
        this.obj.setAttribute("data-maxscale-appearance", null);
        this.obj.setAttribute("data-old-value",this.value);
    } else {
        this.obj.setAttribute("data-maxscale-appearance", "valueError");
    }
};


MaxScale.prototype.applyToOutput = function () {
    if (this.valid) {
        this.obj.setAttribute("data-maxscale-appearance", this.decimalLength + "_" + this.systemLimit);
        XDOM.setObjectValue(this.obj, this.value);
    } else {
        this.obj.setAttribute("data-maxscale-appearance", "valueError");
    }
};


MaxScale.update = function () {
    var foPageObjects = XDOM.queryAll('[data-datatype ="*DEC"][data-maxscale-system-limit]:not([data-maxscale-system-limit="*AUTO"])');
    var obj = null;

    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        obj = foPageObjects[i]
        if (obj.getAttribute("data-maxscale-field") != "*IGNORE") {
            obj = new MaxScale(foPageObjects[i]);
            obj.apply();
        }
    }

    //cleanup voor garbage collection
    obj = null;
    foPageObjects = null;
};

/**
 * when data-scale is set but no data-maxscale-system-limit
 * scale will not be set by MaxScale.update
 * in that case we can format the value only based upon data-scale
 */
MaxScale.formatScaleOnly = (obj, value) => {
    const scale = obj.dataset.scale || '';
    //set the test value and make sure it will be a string
    let testValue = value || "";
    //replace "," and "." see if the remaining string actualy has a value
    testValue = parseInt(testValue.replace(".","").replace(",",""));

    //*blank and no value or 0 or "0.0"or "0,0" just return the value
    if (obj.getAttribute("data-value-when-zero")=="*BLANK" && !testValue){
        //clear the string
        return '';
    }
    if (!scale || obj.getAttribute("data-maxscale-system-limit")) {
        //ignore this field and don't format
        //excluding fields having data-maxscale-system-limit or no scale
        return value;
    }



    const decimalLength = parseInt(scale)

    //do we have decimalLength
    if (isNaN(decimalLength)) {
        return value;
    }

    //format the part

    //split
    const parts = value.split(SETTINGS.decimalSeparator);

    //get intPart
    const intPart = parts[0] || '0';

    //format decimalPart
    const decimalPart = (parts[1] || '').substring(0, decimalLength).padEnd(decimalLength, '0');


    //check if the decimal part exists
    if(!decimalPart){ //nope just return the intpart
        return intPart;
    }

    //join them
    return intPart + SETTINGS.decimalSeparator + decimalPart;

}
/* fieldAttribute */
/* Load Timestamp 13:59:55.643 */
function FieldAttribute() {
};

/**
 * tijdelijke update actie later als ajaxi is geimplementeerd wordt dit rechtstreeks bij het zetten van de waarde in het object aangeroepen
 */
FieldAttribute.prepareDom = function () {

    var foPageObjects = XDOM.queryAll('[data-protected]');

    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        FieldAttribute.protect(foPageObjects[i]);
    }
};


FieldAttribute.unHide = function (obj) {
    if (Mask.isPart(obj) && obj.parentElement.tagName == "DIV") {
        obj.parentElement.setAttribute("data-hidden", null)
    }
    if (isLogical(obj)) {
        Logical.unHide(obj);
    }
    obj.setAttribute("data-hidden", null)
};

FieldAttribute.hide = function (obj) {
    if (Mask.isPart(obj) && obj.parentElement.tagName == "DIV") {
        obj.parentElement.setAttribute("data-hidden", "true")
    }
    if (isLogical(obj)) {
        Logical.hide(obj);
    }
    obj.setAttribute("data-hidden", "true")
};

FieldAttribute.disable = function (obj) {
    obj.setAttribute("data-disable", "true")
};
FieldAttribute.enable = function (obj) {
    obj.setAttribute("data-disable", "false")
};

FieldAttribute.unProtect = function (foObj) {
//protected is set on a fieldset so buble through al lembeded items
    foObj.setAttribute("data-protected", null);
    if (foObj.tagName == 'FIELDSET') {
        FieldAttribute.unProtectFieldset(foObj)
        return;
    }
    var oParent = foObj.parentElement;
    foObj.readOnly = '';

    if (Mask.isPart(foObj) && oParent.tagName == "DIV") {
        oParent.setAttribute("data-protected", null);
    }
    if (isLogical(foObj)) {
        Logical.unProtect(foObj)
    }

    return;
};
FieldAttribute.unProtectFieldset = function (obj) {
    obj.querySelector(".fieldset-protection-div")?.remove();
}

FieldAttribute.protectFieldset = function (obj) {
    const protectionDiv = document.createElement("div");
    protectionDiv.className = "fieldset-protection-div";
    obj.append(protectionDiv);
}


FieldAttribute.protect = function (foObj) {
    // ***************************************************************************
    // Apply protection
    // parms:  this
    // return: --
    // ***************************************************************************
    var oParent = foObj.parentElement;
    //protected is set on a fieldset so buble through al lembeded items
    foObj.setAttribute("data-protected", "true");
    if (foObj.tagName == 'FIELDSET') {
        FieldAttribute.protectFieldset(foObj);
        return;
    }
    foObj.readOnly = 'readonly';


    //protect aan style toevoegen this onderdeel van een mask mask is
    if (Mask.isPart(foObj) && oParent.tagName == "DIV") {
        oParent.setAttribute("data-protected", "true");
    }

    if (isLogical(foObj)) {
        Logical.protect(foObj);
    }

    return;
};

FieldAttribute.setAttentionLevel = function (foObj) {

    if (foObj.fieldAttrAttention) {
        foObj.dom.domObject.setAttribute("data-attention-level", foObj.fieldAttrAttention);
    }

    return;
};
/* fieldAuthorization */
/* Load Timestamp 13:59:55.643 */
// /* global ENUM, SESSION, XDOM, id, FieldAttribute */

// function FieldAuthorization() {}

// FieldAuthorization.update = function() {
//   var foAuthObjects = SESSION.activePage.authorizationFields;
//   for (var i = 0, l = foAuthObjects.length; i < l; i++) {
//     FieldAuthorization.apply(foAuthObjects[i]);
//   }
// };

// FieldAuthorization.apply = function(obj) {
//   var PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-service-type="*CHC"]'); //choice;
//   PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-quicksearch-id]', PageObjects); //snelzoek
//   PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-search-id]', PageObjects); //zoek
//   PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-button-icon="multiSelect"]', PageObjects); //multiselect
//   PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-service-type="*CAL"]', PageObjects); //calendar
//   PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-service-type="*RTV"]', PageObjects); //retrieve
//   PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"].topView', PageObjects); //topView

//   const topview = XDOM.query('[data-to-id="' + obj.id + '"].topView');
//   if(topview){
//     PageObjects = XDOM.queryAllAppend(`[for="${topview.id}"]`, PageObjects); //labels for Topview (indirectly related)
//   }


//   if (obj.authorizationLevel == ENUM.authorizationLevel.hidden) {
//     PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"][data-service-type="*DSP"]', PageObjects); //service display
//     PageObjects = XDOM.queryAllAppend(`[for="${obj.id}"]`, PageObjects); //labels
//     PageObjects = XDOM.queryAllAppend('[data-to-id="' + obj.id + '"].infoProgram', PageObjects); //info window
//   }

//   for (var i = 0, l = PageObjects.length; i < l; i++) {
//     FieldAttribute.hide(PageObjects[i]);
//     When.setHeader(PageObjects[i], 'unavailable');
//   }

//   return;
// };

/* fieldColors */
/* Load Timestamp 13:59:55.643 */

function FieldColors(){};

/**
 * tijdelijke update actie later als ajaxi is geimplementeerd wordt dit rechtstreeks bij het zetten van de waarde in het object aangeroepen
 */

FieldColors.update = function(){

    var foPageObjects = XDOM.queryAllScope('[data-color-apply]');
    for(var i=0,l=foPageObjects.length;i<l;i++){
        FieldColors.setColors(foPageObjects[i]);
    }
};


FieldColors.setColors = function (fieldObj) {

    var colorField = '', colorName = '', applyTo = '', colorValue = '', classPrefix = '', classSuffix = '';

    colorField = fieldObj.getAttribute('data-color-field');
    colorName = fieldObj.getAttribute('data-color-name');
    applyTo = fieldObj.getAttribute('data-color-apply');

    if(colorField){
        colorValue = SESSION.activeData.headerAttributes[colorField];
        colorName  = colorValue;
    }else if(colorName) {
        colorValue = colorName;
    }

    if(!colorValue || colorValue == "" || colorValue == "#" ){
        if(applyTo=="*FONT"){
            fieldObj.setAttribute("data-font-color", "null" );
        }else if(applyTo=="*BKGD" ){
            fieldObj.setAttribute("data-background-color", "null" );
        }
        XDOM.removeAttribute(fieldObj, "style")
        return;
    }

    if(colorValue.indexOf('*') == 0){ // fixed colors (*RED, *BLUE etc)
        classSuffix = colorName.substr(1);
        if(applyTo=="*FONT"){
            fieldObj.setAttribute('data-font-color', classSuffix.toLowerCase());
        }else if(applyTo=="*BKGD" ){
            fieldObj.setAttribute('data-background-color', classSuffix.toLowerCase());
        }
    }else{
        if(applyTo=="*FONT"){
            fieldObj.style.color = colorValue;
        }else if(applyTo=="*BKGD" ){
            fieldObj.style.backgroundColor = colorValue;
        }
    }

};
/* modef */
/* Load Timestamp 13:59:55.643 */
/**
 *  disabled of niet
 *  data-button-enabled-field-id = indicator veld met waarde 1/0 voor true/false
 *  data-button-default-enabled  = true/false -> als indicator niet gevonden is, is dit de waarde
 *
 *
 *  data-modef-field-id          = Modef  (veld die aangeeft welke knop er actief is)
 *  data-modef-active-condition  = ADD/UPDATE/DELETE (wat voor knop is dit)
 *
 *  wordt op true gezet als de knop aanklikbaar is, dat wil zeggen actief en niet
 *  data-button-enabled
 *
 *  logica:
 *  een knop is disabled actief of enabled en niet actieve
 *  enabled en niet actieve
 *
 *   modef-add-disabled
 *   modef-add-enabled
 *   modef-add-active
 *
 *   modef-update-disabled
 *   modef-update-enabled
 *   modef-update-active
 *
 *   modef-delete-disabled
 *   modef-delete-enabled
 *   modef-delete-active
 *
 */
var Modef = {};

/**
 * wordt uitgevoerd bij het opnieuw laden van de pagina en bepaald welke Modef knoppen er actief, inactief en disabled worden aan de hand van de data
 */
Modef.update = function(){
    var modefButtons = XDOM.queryAll('[data-modef-field-id]',SESSION.activeForm);
    var commandButtons = XDOM.queryAll('[data-wscmd-type]',SESSION.activeForm);

    for(var i=0,l=modefButtons.length;i<l;i++){
        Modef.set(modefButtons[i]);
    }

    for(var i=0,l=commandButtons.length;i<l;i++){
        Modef.set(commandButtons[i]);
    }


};

/**
 *
 **/
Modef.set = function(obj){
    let defaultEnabled = obj.getAttribute("data-button-default-enabled"),
        enabledField   = obj.getAttribute("data-button-enabled-field-id"),
        hiddenField    = obj.getAttribute("data-button-hidden-field-id"),
        modef          = obj.getAttribute("data-modef-active-condition"),
        headerAttributes = SESSION.activeData.headerAttributes || {},
        isEnabled       =( (headerAttributes[enabledField]==1) || defaultEnabled=="true"),
        isHidden        =(headerAttributes[hiddenField]==1);

    if(isHidden){ Modef.setHidden(obj); }else{	Modef.setVisible(obj);  }

    if(SESSION.activeData.headerData.MODEF && (SESSION.activeData.headerData.MODEF == modef)){
        Modef.setActive(obj);
    }else if(isEnabled){
        Modef.setEnabled(obj);
    }else{
        Modef.setDisabled(obj);
    }

};

/**
 * Maakt de modef knop waarop geklikt is actief en de andere actieve knop
 * inactief. Daarna wordt het commando ENTER uitgevoerd.
 */
Modef.handleOnClick = function(){
    if(!XDOM.GLOBAL.getBooleanAttribute("data-button-clickable")){
        return false;
    }
    var activeButton = XDOM.query('[data-button-state="active"]',SESSION.activeForm);
    if (activeButton) {
        Modef.setEnabled(activeButton);
    }
    XDOM.setObjectValue('MODEF',XDOM.GLOBAL.getAttribute("data-modef-active-condition"));
    Modef.setActive(GLOBAL.eventSourceElement);
    Command.enter();
    return true;
};


Modef.setEnabled = function(foObj){
    foObj.setAttribute("data-button-enabled","true");
    foObj.setAttribute("data-button-clickable","true");
    foObj.setAttribute("data-button-state","inactive");
};

Modef.setDisabled = function(foObj){
    foObj.setAttribute("data-button-enabled","false");
    foObj.setAttribute("data-button-clickable","false");
    foObj.setAttribute("data-button-state","inactive");
};

Modef.setActive = function(foObj){
    foObj.setAttribute("data-button-enabled","true");
    foObj.setAttribute("data-button-clickable","false");
    foObj.setAttribute("data-button-state","active");
};


Modef.setVisible = function(foObj){
    foObj.setAttribute("data-hidden","false");
};

Modef.setHidden = function(foObj){
    foObj.setAttribute("data-hidden","true");;
};

/* page */
/* Load Timestamp 13:59:55.644 */
/**
 * representatie van een pagina
 */
AJAX.Page = function () {
    this.dom = null;
    this.domString = '';
    this.header = {};
    this.headerData = {};
    this.macroSwitch = {};
    this.lastChangedMaskId = '';
    this.selectedObject = null;
    this.previousField = null;
    this.macroType = '';
    this.screenType = '';
    this.previousMacroType = '';
    this.lastErrorField = null;
    this.serviceIsActive = false; // status Service Function activated
    //this.activeButtonId = null; //actieve button onderaan scherm (controleren, uitvoeren, opvragen etc)
    this.subfile = null;
    this.lastFocusedField = '';
    this.autoSubmitInputObject = null;
    this.lastSelectedInput = null;
    this.modalObject = null;
    this.subfilePos = null;
    this.messageQueue = null;
    this.programResumed = null;
    this.cursorFocus = null;
    this.messageLevel = null;
    this.focusedCommand = null;
    this.programName = null;
    this.blockSearch = false;
    //this.fieldProgression = null;
    this.headerFileName = '';
    this.subfileName = '';
    this.pageUrl = '';
    this.triggers = {};
    this.controlerFields = {};
    this.resubmit = false;
};

AJAX.Page.returnToCaller = function () {
    var currentCacheKey = SESSION.popupStack.pop();
    SESSION.activePage = SESSION.pageStore[currentCacheKey];
    SESSION.activeData = SESSION.activePage.data;
};

AJAX.Page.setCallerCaller = function (macro) {
    SESSION.popupStack.push(macro);
};

/**
 * initalisatie van een pagepart
 * @param {type} data
 * @returns {undefined}
 */
AJAX.Page.prototype.updateData = function (data) {
    var macroProperties = data.macroProperties;
    this.data = data;
    this.macroSwitch = data.serverMacroSwitch;
    this.wizardState = null;
    this.header = data.headerAttributes; //SESSION.activeData.headerAttributes
    this.headerData = data.headerData; //SESSION.activeData.headerData
    this.subfileData = data.subfileData; //SESSION.activeData.subfileData
    this.subfileAttributes = data.subfileAttributes; //SESSION.activeData.subfileData
    this.subfileSelectionCount = data.subfileSelectionCount;
    this.subfileSelectedRecords = data.subfileSelectedRecords;
    this.viewProperties = data.viewProperties;
    this.autoSumFields =  this.viewProperties.autoSumFields;
    this.immediateSubmit = this.viewProperties.immediateSubmit;
    this.programParms = this.viewProperties.programParms;
    this.authorizationFields = this.viewProperties.fieldAuthorisation;
    this.cursorFocus = this.viewProperties.cursorFocus;
    this.messageLevel = this.viewProperties.messageLevel;
    this.focusedCommand = this.viewProperties.focusedCommand;
    this.messageQueue = this.viewProperties.messageQueue;
    this.createdExcelUrl = this.viewProperties.createdExcelUrl;
    this.programResumed = this.viewProperties.programResumed;
    //this.returnToCaller = this.viewProperties.returnToCaller;

    if (this.viewProperties.returnToCaller) {
        this.returnToCaller = this.viewProperties.returnToCaller.split(' ');
    }

    if (data.resubmitConstants) {
        this.resubmitConstants = data.resubmitConstants;
    }

    this.resubmitVariables = data.resubmitVariables;
    if (macroProperties) {
        this.macroProperties = data.macroProperties;
        this.headerFileName = macroProperties.headerFileName;
        this.subfileName = macroProperties.subfileName;
        this.macroType = macroProperties.macroType;
        this.screenType = macroProperties.screenType;
        this.programName = macroProperties.programName;
        this.macroName = macroProperties.macroName;
        this.loadedSubProcedure = macroProperties.loadedSubProcedure;
        this.screenSize = macroProperties.screenSize;
        this.autoRenew = macroProperties.autoRenew;
        this.retainFocusOnAccept = macroProperties.retainFocusOnAccept === '1';
        this.viewDataUri = macroProperties.viewDataUri;
        SESSION.pageStore[macroProperties.cacheKey] = this;
    } else {
        this.data.macroProperties = this.macroProperties;
    }
    if (data.wizardState) {
        this.wizardState = data.wizardState;
    }

};

AJAX.Page.prototype.setDom = function () {
    if (this.dom || this.domString) {
        if (this.dom === SESSION.activeForm) {
            return;
        }

        XDOM.removeDOMObject(SESSION.activeForm);
        SESSION.activeFrame.document.body.appendChild(this.dom);
        SESSION.activeForm = this.dom;

        return;
    }
    this.dom = SESSION.activeForm;
    this.dom.dataset.macroName = this.macroName;
    APP = SESSION.activeFrame.document;
    SCOPE.pageDoc = SESSION.activeFrame.document;
    SCOPE.page = SESSION.activeFrame;
};
AJAX.Page.prototype.setWizardURL = function () {
    if (!inWizard()) {
        return;
    }
    const app = SCOPE.session.wizardDefinition.steps.filter(d => d.stepCode == this.macroName, this)[0].stepAppCode;
    this.pageUrl = SESSION.alias + '/' + app + '/ndmctl/' + this.macroName + '.ndm/main?PFMJOBID=' + SESSION.jobId

}
/**
 *  zet de pageUrl voor deze pagina
 */
AJAX.Page.prototype.getURL = function () {
    if (this.screenType === '*SCH') {
        this.pageUrl = Search.currentInstance.getURL();
    } else if (SESSION.isSingleView) {
        if (this.wizardState) {
            this.setWizardURL()
            return;
        }
        this.pageUrl = TopView.currentInstance.getURL();
    } else {
        this.pageUrl = SESSION.stack.currentMacro.getCurrentUrl();
    }
};

AJAX.Page.prototype.autoRenewDom = function () {
    clearInterval(SESSION.stack.currentSession.autoRenewInterval);
    SESSION.stack.currentSession.autoRenewInterval = null;

    if (this.autoRenew) {
        if (this.autoRenew == '*NONE') {
            return;
        }
        SESSION.stack.currentSession.autoRenewInterval = setTimeout('autoRenew()', parseInt(this.autoRenew));
    }
};

/**
 * leest pas de dom aan en voert de permanente wijzigingen uit zoals: het zetten
 * van labels, het opmaken van maskers
 */
AJAX.Page.prototype.prepareDom = async function () {
    time('prepareDom (script)');
    SESSION.session.updateScope();
    //this.fieldProgression = new FieldProgression();
    if (this.viewProperties.dataAvailable === 'true') {
        InlineActionButton.prepare();
        Mask.prepareDom();
        oculusImage.prepareDom();

        Upload.prepareDom();
        Barcode.prepareDom();
        GUI.Signature.prepareDom();
        Subfile.prepareDom();
        SortButton.prepareDom();
        NAV.sessionLauncher.prepareDom();
        icons.prepareDom();
        FieldAttribute.prepareDom();
        GUI.infoTitle.prepareDom();
        QuickSearch.prepareDom();
        TopView.prepareDom();
        //  multiUpload.prepareDom();

    }
    MESSAGES.prepare();

    DevTools.renderToolBar();

    Command.prepareDom();

    Batch.prepareDom();
    setPrintButton();
    hideColourPicker();

    setLabels();
    setTitle();
    setHelpText();
    this.createProgramParams();
    SESSION.submitFromScope = 'MAIN';
    await this.updateDom();
    this.setFocusOnMain();
    SCOPE.main.directLink.update(window);
    timeEnd('prepareDom (script)');
};


AJAX.Page.prototype.setFocusOnMain = function(){
    //set the scope back to main just to be sure we get the right field
    //Stateless.Page.setScope(null);
    let obj = XDOM.getObject(SESSION.activePage.cursorFocus) || XDOM.getObject(this.mainSubmitField);
    //check if field is in a main page

    if(isStatelessObject(obj)){
        //field is not in main page use the mainSubmitField
        SESSION.activePage.cursorFocus =  this.mainSubmitField;
    }

    SESSION.activePage.cursorFocus = this.mainSubmitField

    setCursor('MAIN'); //in verband met ff cursor pas setten als pagina echt zichtbaar is
}

/**
 * determen if page is in overLay mode
 * @returns {boolean}
 */
AJAX.Page.prototype.isOverlay = () => {
    return (SESSION.activePage.screenType == "*SCH" || SESSION.isSingleView)
};

AJAX.Page.prototype.updateDom = async function () {
    time('updateDom (script)');
    let stateLessPromises = [];
    this.setDom();
    MAIN.focusMenu();
    if (this.viewProperties.programResumed === 'false') {
        closeAllModalObjects();
    }

    NAV.Stack.clearFields(this);
    KeepAlive.start();
    Mask.clearLastChanged();
    updateNav();
    //  MAIN.Theme.updateFromSession(SESSION.session);
    MAIN.SCREEN.handleMacroLoad(SESSION.activePage.screenSize, this.screenType, SESSION.isSingleView);
    this.getURL();
    SESSION.subScope = XDOM.getObject('SCRDIV'); //RKR Dit was de DTADIV alleen vallen objecten hier buiten.
    SESSION.activeData = this.data;
    this.mainSubmitField = this.data.viewProperties.cursorFocus;

    if (this.viewProperties.dataAvailable === 'true') {
        Subfile.clear();
        this.setValues();
        When.update();
        Modef.update();
        ActionCommand.update();
        stateLessPromises = updateStatelessParts()

        ActionCommand.updateDom();
        EditInfo.updateDom();
        Service.update();
        Upload.update();
        Barcode.update();
        INP.updateDom();
        MultiSelect.updateDom();
        SortButton.update();
        Link.update();
        MaxScale.update();
        FieldColors.update();
        Subfile.update();
        formatThousandAll();
        DataAttribute.update();
        AttentionLevel.update();
        // ConditionalAttribute.update();
        FieldAuthorization.update();
        icons.updateDom(this.headerData)
        GUI.infoTitle.update();
        GUI.Signature.update();
        updateDoubleSearchIcons(); //na when snelzoek en ConditionalAttribute
        Bi.update();
        Lines.update();
        NAV.sessionLauncher.update(); //na when snelzoek en ConditionalAttribute i.v.m. authorisatie
        //devTools.update();
        Wizard.update(SESSION);
        SingleUpload.update();
    }
    // SESSION.session.changeTheme();
    Command.update();
    Help.update();
    KeepAlive.update();
    //Messages.update();
    registerEvents();
    setfavourites();
    setTitle();
    setMessage(this.viewProperties.messageLevel, this.viewProperties.messageText, this.viewProperties.longMessageText);
    this.autoSubmitInputObject = null;

    //executeNextAction(); // uitvoeren van eventueel overschakelen naar ander procedure of subprocedure

    SESSION.submitInProgress = false;
    SESSION.session.cancelBlurEvent = false;
    SESSION.stack.currentSession.clearRetrieveJobSts();
    Batch.update(); //als laatste in verband met SESSION.submitInProgress


    //await all promisses before closing the topview

    await Promise.all(stateLessPromises);

    //update ConditionalAttribute.update
    //this is done after the resolving of the stateless promis because in developer mode innerHTML will be renewed
    //when a subview is set to protect this will be overwritten in the renew off the subview stateless content
    ConditionalAttribute.update();



    if (SESSION.isSingleView) {
        if (this.viewProperties.autoClose == 'true') {
            TopView.close();
        }
    }

    MacroTab.updateFromMain();
    SCOPE.main.Favourites.updateDom();
    Service.autoOpen();


    SESSION.subScope = null;

    //insertTestElement()


    var flashFrame = XDOM.getObject('antiFlashFrame');
    flashFrame.contentDocument.body.innerHTML = '';
    flashFrame.style.display = 'none';
    timeEnd('updateDom (script)');
    timeEnd('post (totaal)');
    timeEnd('get (totaal)');


    releasePage();
};

function updateStatelessParts() {
    return  [
        ...GUI.InfoWindow.updateDom(),
        ...GUI.EditWindow.updateDom(),
        ...QuickSearch.updateDom(), //let op quicksearch na search in verband met dubbele zoek;
        ...QueryList.updateDom()
    ]
}

//partialUpDate

AJAX.Page.prototype.partialUpDate = async function (data) {
    KeepAlive.start();
    //updating fields
    const autoSumFields = XDOM.queryAll('[data-auto-sum="true"]');
    autoSumFields.forEach(field=>{

        const value = data[field.id];
        if(value){
            // console.log(`set value ${value} to ${field.id}`);
            XDOM.setObjectValue(field,value);
        }
    })


    releasePage()
    showLoading(false);
    SESSION.submitInProgress = false;
}

AJAX.Page.prototype.reNew = async function (res) {
    if (SESSION.session.debugMode) {
        SESSION.activePage.devModeReNew(res.pageDef, res.data);
        return;
    }

    setFrames(SESSION.activePage.screenType);
    this.updateData(res.data);
    await this.updateDom();
    showFrame(SESSION.activePage.screenType);
    SESSION.submitFromScope = 'MAIN';
    Subfile.setScrollPos();

    this.autoRenewDom();

    //set cursor again because stateless pages might have changed the cursor
    // SESSION.activePage.cursorFocus =  SESSION.mainSubmitField;
    this.setFocusOnMain();
    //reset resubmit this is used for stateless parts top indicate the part is reloaded from the same context
    this.resubmit = false;
};

AJAX.Page.loadScriptTagPromised = function (uri, onload) {
    return new Promise(function (resolve, reject) {
        const scriptObj = XDOM.createElement('script'),
            parent = SESSION.activeFrame.document.getElementsByTagName('head')[0];

        scriptObj.src = uri;
        scriptObj.onload = function () {
            onload();
            resolve();
        }
        scriptObj.onError = function (error) {
            reject(error, scriptObj);
        }
        parent.appendChild(scriptObj);
    });
};

AJAX.Page.loadScriptTag = function (uri, onload) {
    var scriptObj = XDOM.createElement('script'),
        parent = SESSION.activeFrame.document.getElementsByTagName('head')[0];
    scriptObj.src = uri;
    scriptObj.onload = onload;
    parent.appendChild(scriptObj);
};
AJAX.Page.prototype.devModeReNew = function (pageDef, data) {
    var scriptObj = null,
        parent = null,
        formObj = null;

    setFrames(SESSION.activePage.screenType);
    showFrame(SESSION.activePage.screenType);
    this.dom = null;

    parent = SESSION.activeFrame.document.getElementsByTagName('body')[0];
    formObj = SESSION.activeFrame.document.getElementsByTagName('form')[0];

    //omdat IE anders zijn referentie kwijt is
    XDOM.removeDOMObject(formObj);

    parent.innerHTML = pageDef;
    SESSION.activePage.domCaptions = new Captions(data);

    SESSION.activePage.updateData(data);
    SESSION.activeData = data;
    XDOM.removeDOMObject('captionDef');

    scriptObj = XDOM.createElement('script', 'captionDef', null);
    scriptObj.src = SESSION.activePage.viewDataUri;
    scriptObj.onload = AJAX.onload;

    parent = SESSION.activeFrame.document.getElementsByTagName('head')[0];
    parent.appendChild(scriptObj);
    time('load text script (server)');
};

AJAX.Page.updateAfterIpmfSubmit = function () {
    //small reset after submit
    KeepAlive.start();
    Command.update();
    SESSION.submitInProgress = false;
    SESSION.session.cancelBlurEvent = false;
    releasePage();
    return;
};

AJAX.Page.newPage = function (pageDef, data) {
    var scriptObj = null,
        parent = null,
        headObj = '',
        formObj = null,
        flashFrame = null;
    setFrames(data.macroProperties.screenType);
    showFrame(data.macroProperties.screenType);

    parent = SESSION.activeFrame.document.getElementsByTagName('body')[0];
    formObj = SESSION.activeFrame.document.getElementsByTagName('form')[0];
    headObj = SESSION.activeFrame.document.getElementsByTagName('head')[0];
    flashFrame = XDOM.getObject('antiFlashFrame');


    if (data.macroProperties.screenType != '*SCH') {
        if (formObj) {
            flashFrame.contentDocument.body.innerHTML = parent.innerHTML;
        }
        flashFrame.style.display = 'block';
    }
    //omdat IE anders zijn referentie kwijt is
    XDOM.removeDOMObject(formObj);

    parent.innerHTML = pageDef;
    SESSION.activePage = new AJAX.Page();
    SESSION.activePage.domCaptions = new Captions(data);
    SESSION.activePage.updateData(data);
    SESSION.activeData = data;

    TopView.addNavigationToFrame(data.macroProperties.screenType);

    XDOM.removeDOMObject('captionDef');

    scriptObj = XDOM.createElement('script', 'captionDef', null);
    scriptObj.src = SESSION.activePage.viewDataUri;
    scriptObj.onload = AJAX.onload;
    headObj.appendChild(scriptObj);
    time('load text script (server)');
};

AJAX.Page.prototype.setValues = function () {
    var obj = null;
    for (var fieldName in this.headerData) {
        obj = XDOM.getObject(fieldName);
        if (obj) {
            XDOM.setObjectValue(obj, this.headerData[fieldName]);
            setOldValue(obj);
        }
    }
    var outputs = XDOM.queryAllScope('[data-value-from-id]');
    for (var i = 0, l = outputs.length; i < l; i++) {
        obj = outputs[i];
        XDOM.setObjectValue(obj, this.headerData[obj.getAttribute('data-value-from-id')]);
    }

    var clearInputs = XDOM.queryAllScope("[data-clear-after-submit='true']");
    for (var i = 0, l = clearInputs.length; i < l; i++) {
        obj = clearInputs[i];
        XDOM.setObjectValue(obj, '');
    }
};

/**
 * zet het subfile record op positie fiCursorPos
 * als fiCursorPos==null dan wordt de single line data als current record gezet
 * @param fiCursorPos
 */
AJAX.Page.prototype.setRecord = function (fiCursorPos) {
    if (SESSION.activeFrame.IdfJSON) {
        if (fiCursorPos === null) {
            this.header = SESSION.activeFrame.IsfJSON.SubfileAttributes[fiCursorPos];
        } else {
            this.header = SESSION.activeFrame.IdfJSON.HeaderAttributes;
        }
    }
    if (!this.header) {
        this.header = {};
    }
};

/**
 * verlaten van de pagina
 */
AJAX.Page.onblur = function () {
    Mask.CheckChanged();
};

AJAX.Page.prototype.createProgramParams = function () {
    for (var field in this.programParms) {
        XDOM.createInputField(field, '');
    }
};

function insertTestElement(){
    console.warn('insertTestElement remove this code');
    const placeHolder = XDOM.getObject('DTADIV');
    const testElement = document.createElement('div');
    if(placeHolder.querySelector('.camera-button')) return;
    testElement.className = "xpos026 line1 fa fa-camera dataSectionButton  theme-hover-color camera-button"
    testElement.addEventListener("click",()=>{
        new Camera(placeHolder);
    } )

    placeHolder?.appendChild(testElement);

}
/* command */
/* Load Timestamp 13:59:55.644 */
/* global SESSION, Mask, XDOM, BrowserDetect, PFMCON, Search, GLOBAL, Subfile, Validate, GUI, MAIN, AJAX, KeepAlive, Upload, Messages, QuickSearch, keyCode */

/**
 * Command (WS Command)
 * data-wscmd-type bepaald welk command er wordt uitgevoerd
 *
 */

Command = function () {
};

Command.handleKeyDown = function () {
    if (GLOBAL.charCode !== keyCode.enter || XDOM.GLOBAL.getBooleanAttribute('data-block-autosubmit')) {
        return;
    }
    var formId = XDOM.GLOBAL.getBooleanAttribute('data-form-id');

    if (formId && formId !== 'main') {
        return;
    }

    Command.execute();
    return true;
};

// geregistreerde knop verwijderen
Command.deleteCommand = function (fsCommand) {
    var foObj = XDOM.getObject(fsCommand);
    XDOM.setAttribute(foObj, 'data-button-enabled', 'false');
};

// controleerd of een commando conop beschikbaar is
Command.check = function (fsCommand) {
    var foCommandButton = XDOM.getObject(fsCommand);
    switch (fsCommand) {
        case 'PROMPT':
        case 'RSTFLT':
        case 'ACCEPT':
        case 'RESET':
            return true;
            break;
        default:
            return XDOM.getBooleanAttribute(foCommandButton, 'data-button-enabled');
            break;
    }

    return false;
};

Command.enter = function () {
    Command.execute('ENTER');
};

/**
 * Submit de form (de gegevens in de invoervelden) van het actieve pro
 * Er kan maar 1 submit tegelijk uitgevoerd worden.
 * De applicatie wordt geblokkeerd voor verdere acties.
 * Er wordt een aanvraag voor status controle van de job gedaan.
 * Indien mTP_MQI='*EXC' wordt het ontvangen van berichten geactiveerd
 * voorheen jsc_SUBMIT
 * @param submitFromSubfile
 */
// ***************************************************************************
// Submit de form (de gegevens in de invoervelden) van het actieve programma.
// parms: --
// return: --
// Er kan maar 1 submit tegelijk uitgevoerd worden.
// De applicatie wordt geblokkeerd voor verdere acties.
// Er wordt een aanvraag voor status controle van de job gedaan.
// Indien mTP_MQI='*EXC' wordt het ontvangen van berichten geactiveerd
// ***************************************************************************
Command.submit = function (submitFromSubfile) {
    if (SESSION.submitInProgress) {
        return;
    }
    SESSION.submitInProgress = true;
    const command = SESSION.activePage.controlerFields['WS_CMD'];
    QuickSearch.cancelDelayedOpen();
    closeAllModalObjects();
    closeHighSlide();
    protectPage();
    setPromptField();
    setResubmitFields();
    setIpmfSubmitField('false');
    showLoading(true);
    Messages.newThread(command);
    Mask.completeAllMasks();
    Upload.setFormEncType(command);
    KeepAlive.cancel(); //stopt de keep alive job om dubbele requests te voorkomen
    SESSION.stack.setFormatFields(SESSION.activePage, submitFromSubfile);
    unformatAll();
    SESSION.submitFromScope = 'MAIN';
    AJAX.postForm();
    MAIN.NAV.Session.checkStatus(SESSION.stack.currentSession.id, true, false);
    XDOM.cancelEvent();
    return false;
};

Command.ipmfSubmitOnly = function () {
    if (SESSION.submitInProgress) {
        return;
    }
    SESSION.submitInProgress = true;
    //ieSubmitHack1();
    protectPage();
    setResubmitFields();
    setIpmfSubmitField('true');
    showLoading(true);
    KeepAlive.cancel(); //stopt de keep alive job om dubbele requests te voorkomen
    unformatAll();
    AJAX.postForm();
    //ieSubmitHack2();
    MAIN.NAV.Session.checkStatus(SESSION.stack.currentSession.id, true, false);
    XDOM.cancelEvent();
    return false;
};

Command.focusCommand = function (command) {
    if (!command) {
        command = 'ENTER';
    }
    var obj = XDOM.query("[data-command-focused='true']", SESSION.activeForm);
    if (obj) {
        obj.setAttribute('data-command-focused', 'false');
    }
    obj = XDOM.getObject(command);

    if (!obj) {
        command = 'ACCEPT';
        obj = XDOM.getObject(command);
    }

    if (!obj) {
        command = 'RETURN';
        obj = XDOM.getObject(command);
    }

    if (obj) {
        obj.setAttribute('data-command-focused', 'true');
        SESSION.activePage.focusedCommand = command;
    }
};

// ***************************************************************************
// Registreer commando (WSCMD) toetsen
// parms:  fsWSCMD   = commando
//         fsDEREG   = || *DLT
//         fsWSCMDTYP= type commando
//         fsFOCUS   =  || *FCS (geef focus aan de knop)
// return: --
// ***************************************************************************

Command.prepareDom = function () {
    let pageObjects = XDOM.queryAll('[data-wscmd-type]', SESSION.activeForm);
    let obj = null;
    const buttonsForCaption = ['ENTER', 'CLOSE', 'RETURN', 'ACCEPT', 'END', 'REPEAT', 'STPBCK', 'ENDWZD'];
    for (let i = 0, l = pageObjects.length; i < l; i++) {
        obj = pageObjects[i];
        if (buttonsForCaption.indexOf(obj.id) > -1) {
            obj.value = getCapt(obj.value);
        }
        if(obj.id == 'RETURN' && SESSION.activePage.screenType == '*SCH'){
            obj.dataset.returnFromSearch = true;
        }

    }
    obj = XDOM.getObject('CLOSE');
    if (obj) {
        obj.value = getCapt(obj.value);
        obj.dataset.clickAction = 'TopView.close';
    }
};

Command.update = function () {
    var foPageObjects = XDOM.queryAll('[data-wscmd-type]', SESSION.activeForm);
    var foObj = null;
    SESSION.activePage.setRecord(null); //set
    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        foObj = foPageObjects[i];
        Command.updateButton(foObj);
    }
    //	Command.focusCommand(SESSION.activePage.header['WS_FCS']); Aanpassing MVB
    Command.focusCommand(SESSION.activePage.focusedCommand);
    Command.checkReturnButton();
    showLoading(false);
};

/**
 * controleerd of de terug knop zichtbaar is
 * dit is het geval als:
 * 1) huidige scherm een zoekscherm is (SESSION.activePage.screenType == '*SCH') of
 * 2) het vorige nav object is ook een macro
 * in dat geval wordt de knop ook zichtbaar gemaakt
 */
Command.checkReturnButton = function () {
    var foObj = XDOM.getObject('RETURN');
    if (!foObj) {
        return;
    } //-->
    if (
        (SESSION.activePage.screenType === '*SCH' || SESSION.stack.getPreviousMacro()) &&
        SESSION.activePage.screenType != '*TOPVIEW'
    ) {
        foObj.style.visibility = 'visible';
        foObj.style.display = '';
    } else {
        foObj.style.visibility = 'hidden';
        foObj.style.display = 'none';
        Command.deleteCommand('RETURN');
    }
    return;
};

Command.updateButton = function (obj) {
    var fsWsCommandType = obj.getAttribute('data-wscmd-type');
    var fsTextField = obj.getAttribute('data-text-field-id');
    var fsTextCode = '';


    if (obj.id === 'ACCEPT') {
        // Bij onmousedown op Accept uitvoeren voordat dit door AUTOSBM wordt gedaan
        obj.setAttribute('data-mouseDown-action', 'Command.execute');
    }

    if (['PROMPT', 'ACCEPT', 'RESET', 'CLEAR', 'STPBCK', 'ENDWZD', 'CANCEL'].includes(obj.id)) {
        obj.setAttribute('data-button-enabled', 'true');
        obj.disabled = false;
    } else {
        if (!enableButton(obj)) {
            obj.disabled = true;
        } else {
            obj.disabled = false;
        }
    }

    switch (fsTextField) {
        case 'WS_ETX':
            fsTextCode = 'cENT' + SESSION.activePage.viewProperties.commandEnterTextCode + '_VAL';
            fsTextTitle = 'cENT' + SESSION.activePage.viewProperties.commandEnterTextCode + '_TTL';
            obj.setAttribute('data-title-origin', '*LBL');
            obj.setAttribute('data-title-variable', fsTextTitle);

            obj.value = getCaption(fsTextCode, fsTextCode + ': niet bekend');
            break;

        case 'WS_ATX':
            fsTextCode = 'cACC' + SESSION.activePage.viewProperties.commandAcceptTextCode + '_VAL';
            fsTextTitle = 'cACC' + SESSION.activePage.viewProperties.commandAcceptTextCode + '_TTL';
            obj.setAttribute('data-title-origin', '*LBL');
            obj.setAttribute('data-title-variable', fsTextTitle);
            obj.value = getCaption(fsTextCode, fsTextCode + ': niet bekend');
            break;
    }

    GUI.infoTitle.register(obj);

    switch (fsWsCommandType) {
        case '*TXT':
            //voor alle knoppen de focus weghalen
            obj.className = 'txtbtn';
            break;
        case '*CRT':
            XDOM.setAttribute(obj, 'data-wscommand-createtype', fsWsCommandType.replace('CRT', ''));
            break;
        default:
            break;
    }
    return;
};


/**
 * submits an autosum request
 */
Command.autoSum = () => {
    if (SESSION.submitInProgress) {
        return;
    }
    SESSION.submitInProgress = true;
    XDOM.createInputField('SubmitForSelect', 'true');
    XDOM.createInputField('WS_CMD', 'ENTER');
    protectPage();
    showLoading(true);
    KeepAlive.cancel(); //stopt de keep alive job om dubbele requests te voorkomen
    SESSION.submitFromScope = 'MAIN';
    setResubmitFields();
    AJAX.postPartialUpdate();
    MAIN.NAV.Session.checkStatus(SESSION.stack.currentSession.id, true, false);
    XDOM.cancelEvent();

}

// ***************************************************************************
// Zorgt ervoor dat het juiste commado uitgevoerd wordt in ILE
// voert evt. eerst controles uit op de invoervelden
// parms:  fWSCMD=commando
// return: false
// ***************************************************************************
Command.execute = function (commandIn, statefull) {
    var command = commandIn;
    if (!statefull && Stateless.Page.command(commandIn)) {
        return false;
    }
    if (!command) {
        command = SESSION.activePage.focusedCommand;
    }
    if (!Command.check(command)) {
        return false;
    }
    closeHighSlide();
    if (command === '') {
        command = 'ENTER';
    }
    XDOM.createInputField('WS_CMD', command);
    SCOPE.main.directLink.setOpenTokenFrom(window)
    if (SESSION.activePage.screenType !== '*SCH' && !SESSION.isSingleView) {
        SESSION.stack.setPreviousMacroFields();
    }

    if (!Validate.All()) {
        SESSION.activePage.autoSubmitInputObject = null;
        return false;
    }
    closeAllModalObjects();
    Stateless.deactivateAllSubViews();

    switch (command) {
        case 'ENDPAG':
        case 'PAGEDN':
        case 'PAGEUP':
        case 'BEGPAG':
        case 'RSTFLT':
            Subfile.getProgramSettings().subfilePos = 0;
            return Command.submit();
            break;
        default:
            break;
    }

    switch (SESSION.activePage.macroType) {
        case '*PMT_ML':
            Subfile.storeSubfilePos();
            break;
        case '*RGS':
        case '*UPD_ML':
            Subfile.setCursor();
            break;
        default:
            Subfile.getProgramSettings().subfilePos = 0;
            break;
    }
    return Command.submit();
};
//***************************************************************************
// Commando knop is geactiveerd
// parms:  this
// return: --
// ***************************************************************************
Command.handleOnClick = function (e) {
    // if (!GLOBAL.eventSourceElement.getAttribute('data-wscmd-type')) {
    //   return false;
    // }

    let screenType = SESSION.activePage.screenType;

    if (e.target.getAttribute('data-screen-type')) {
        screenType = e.target.getAttribute('data-screen-type');
    }

    switch (e.target.id) {
        case 'RETURN':
            switch (screenType) {
                case '*SCH':
                    Search.close();
                    break;
                case '*TOPVIEW':
                    TopView.close();
                    break;
                default:
                    PFMCON.gotoPreviousProgram();
                    break;
            }
            break;
        case 'CANCEL':
            switch (screenType) {
                case '*SCH':
                    Search.close();
                    break;
                case '*TOPVIEW':
                    TopView.close();
                    break;
                default:
                    PFMCON.closeWindow();
                    break;
            }
            break;
        default:
            Command.execute(e.target.id);
            break;
    }
    return true;
};

Command.resetEnter = function () {
    // ***************************************************************************
    // Reset enter: vanwege gewijzigde veldinhoud zo nodig terug van ACCEPT naar ENTER
    // parms:  --
    // return: --
    // ***************************************************************************

    if (SESSION.activePage.focusedCommand === 'ACCEPT' && !SESSION.activePage.retainFocusOnAccept) {
        Command.focusCommand('ENTER');
    }
};

Command.resetHeader = function (){
    Command.execute('RSTFLT')
}

function setIpmfSubmitField(setValue) {
    var ipmfInputObj = null;
    var inputValue = setValue || 'false';

    ipmfInputObj = XDOM.getObject('SubmitForIPMF');

    if (!ipmfInputObj) {
        XDOM.createInputField('SubmitForIPMF', inputValue);
    } else {
        XDOM.setObjectValue(ipmfInputObj, inputValue);
    }

    return;
}

function setResubmitFields() {
    XDOM.createInputField('SubmitFromView', 'true');
    if (SESSION.activePage.resubmitConstants) {
        for (var field in SESSION.activePage.resubmitConstants) {
            XDOM.createInputField(field, SESSION.activePage.resubmitConstants[field]);
        }
    }
    if (SESSION.activePage.resubmitVariables) {
        for (var field in SESSION.activePage.resubmitVariables) {
            XDOM.createInputField(field, SESSION.activePage.resubmitVariables[field]);
        }
    }

}

function showLoading(isLoading) {
    var commandDiv = XDOM.getObject('CMDDIV');
    if (commandDiv) {
        if (isLoading) {
            XDOM.setAttribute(commandDiv, 'data-message-status', 'loading');
        } else {
            XDOM.setAttribute(commandDiv, 'data-message-status', 'default');
        }
    }
}

function getlastSelectedInputId(obj) {
    let id = '';
    if (!obj || obj.constructor.name === "HTMLDocument") {
        return '';
    }

    if (Mask.isMask(obj)) {
        id = obj.getAttribute('data-mask-target');
    } else if (obj.hasAttribute('data-real-name')) {
        id = obj.getAttribute('data-real-name');
    } else {
        id = obj.id;
        if (isLogical(id) && id.indexOf('SFR_SLT_') > -1) {
            //dit zijn checkboxen uit een werken met scherm en die moeten niet mee gegeven worden
            id = '';
        }
    }
    return id;
    //return Logical.getFieldName(id);
}

function getCurrendFocused() {
    //determinging the next field to focus or the current one
    //because this is called from blur relatedTarget has preference (this is the field jumped to in the blur event

    const target = GLOBAL.eventObject._event.relatedTarget || GLOBAL.eventObject._event.target;
    //exclude non focusable elements and command buttons
    if (canHaveFocus(target) && target.parentNode.id !== 'CMDDIV') {
        return target;
    }
    return SESSION.activePage.lastSelectedInput;
}

function setPromptField() {
    let currentPrompt = getlastSelectedInputId(getCurrendFocused()),
        inputObj = XDOM.getObject(currentPrompt);

    if (!inputObj || isStatelessObject(inputObj)) {
        currentPrompt = '';
    }
    //console.log('last', SESSION.activePage.lastSelectedInput.id, 'current',currentPrompt)
    if (!currentPrompt) {
        SESSION.submitFromScope = 'MAIN';
    }
    XDOM.createInputField('WS_PMT', currentPrompt);
    return currentPrompt;
}

function isStatelessObject(obj) {
    if(!obj){
        return false;
    }
    if (
        obj.getAttribute('data-stateless-page-id') ||
        obj.getAttribute('data-quicksearch-selectfield') ||
        obj.getAttribute('data-prompt-field') ||
        obj.getAttribute('data-panel-id')
    ) {
        return true;
    }
    return false;
}

/* service */
/* Load Timestamp 13:59:55.645 */
/* global GLOBAL, keyCode */

// ***************************************************************************
// Registreer Service Function
// parms: fsTOID =toekennen aan object
// fOBJNM =object naam
// fSRVOBJ =Service object
// fSRVTYP =Service type (*RTV || *DSP || *CHC || *LST || *CAL)
// fSRCLOC =Service source locatie (*DBS || )
// fSRVPOS =Service Function positie
// fSRVACT =Service Action
// *USRACT default geen actie behalve door user
// *CSR de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van
// het TOID
// *CSRBLK de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van
// het TOID en het veld TOID is leeg
// *CSRERR de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van
// het TOID en mWS_MGL is 'F' (gaan er van uit dat de fout op het TOID is
// gevonden)
// *AUTOACT de choice/calender worden altijd worden geopend, maar slechts
// maximaal 1 per scherm (eerste)
// return: --
// ***************************************************************************


function Service(obj) {
    this.id = obj.getAttribute("data-service-id");
    this.targetId = obj.getAttribute("data-to-id");
    this.serviceObjectName = obj.getAttribute("data-service-source");
    this.optionExpiredMode = obj.getAttribute("data-service-option-expired");
    this.type = obj.getAttribute("data-service-type");
    this.recordNumber = obj.getAttribute("data-record-number");
    this.axis = obj.getAttribute("data-to-axis");
    this.displayId = obj.id;

    this.serviceId = this.targetId + this.type;

    this.serviceObject = null;
    this.serviceType = this.type;
    this.selectedValue = '';
    this.placeholder = null;
    this.resultTable = null;
    this.tableBody = null;
    this.resultDiv = null;
    this.titleDiv = null;
    this.index = [];
    this.rows = [];
    this.TargetIsHidden = null;
    this.openByClick = false;
    this.maxTextLength = 10;

    this.selectedIndex = null;                  //selected record
    this.hoveredIndex = 0;                      //hovered record
    this.lastHoveredIndex = 0;
    this.maxDisplayedRows = SETTINGS.maxServiceFunctionDisplayedRows;     //show this number of record at once
    this.rowHeight = 18;                        //height of a record in chc and dsp
    this.ancorStart = 0;                        //if a page has more than one page use this as START ancor
    this.ancorEnd = 0;                          //if a page has more than one page use this as END ancor
    this.onePageView = true;                    //are there less options than maxDisplayedRows
    this.autoSelectTimestamp = null;

    this.cellAxis = null;
    this.isSFLLineSelector = (this.targetId == 'WS_SFL');

    this.columnCodeWidth = 1;
    this.hasValidOptions = false;

    this.openTimer = null;
    this.isInitialized = false;
    switch (this.serviceType) {
        case ENUM.serviceType.choice:
            this.renderRecord = this.renderChoiceRecord;

            /* POI */
            this.placeHolderClass = "popCHCWDW";


            this.placeHolderID = this.serviceObjectName + "_" + this.placeHolderClass;
            break;
        case ENUM.serviceType.display:
            this.placeHolderClass = "popDSPWDW";
            this.placeHolderID = this.serviceObjectName + "_" + this.placeHolderClass;
            this.renderRecord = this.renderDisplayRecord;
            if (!this.targetId) {
                this.targetId = this.displayId;
            }
            break;
    }
}

Service.get = function (obj) {
    var fsSource = obj.getAttribute("data-service-source");//TOV_CDLEV"
    var foService = new Service(obj);
    var panel = XDOM.GLOBAL.getEditWindow();
    foService.init();
    if (panel) {
        foService.serviceObject = panel.services.getOldFormat(fsSource);
    }
    return foService;
};


// ***************************************************************************
// Registreer Service Function
// parms: fsTOID =toekennen aan object
// fOBJNM =object naam
// fSRVOBJ =Service object
// fSRVTYP =Service type (*RTV || *DSP || *CHC || *LST || *CAL)
// fSRCLOC =Service source locatie (*DBS || )
// fSRVPOS =Service Function positie
// fSRVACT =Service Action
// *USRACT default geen actie behalve door user
// *CSR de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van
// het TOID
// *CSRBLK de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van
// het TOID en het veld TOID is leeg
// *CSRERR de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van
// het TOID en mWS_MGL is 'F' (gaan er van uit dat de fout op het TOID is
// gevonden)
// *AUTOACT de choice/calender worden altijd worden geopend, maar slechts
// maximaal 1 per scherm (eerste)
// return: --
// ***************************************************************************

Service.currentService = null;

Service.isOpening = false;
Service.openDelay = 400;
Service.alreadyOpen = false;

Service.prototype.open = function () {
    var foTarget = XDOM.getObject(this.targetId);
    var jumpToRecord = null;

    if (SESSION.submitInProgress || Service.currentService === this) {
        return;
    }

    // Check whether the Cal modal is already open
    let alreadyOpen = window.SCOPE.main.Dialogue.getModalsByGroup([window.SCOPE.session.SESSION.jobId, 'service'])[0];

    // Remember already open and let the calendar know another service will open (focus control)
    if (alreadyOpen) {
        alreadyOpen.alreadyOpen = true;

        window.SCOPE.main.Dialogue.deleteModalGroup([window.SCOPE.session.SESSION.jobId, 'service']);
    }

    Service.currentService = this;

    this.render();

    if (this.type == ENUM.serviceType.choice || this.type == ENUM.serviceType.display) {
        jumpToRecord = this.initSettings();
    }

    this.defineScroll(jumpToRecord);
    SESSION.activePage.cursorFocus = "pageBody";
    setCursor();
};

Service.prototype.initSettings = function () {

    var optionLength = this.serviceObject.OPT.length;
    var jumpToRecord = false;
    var initChoice = true;
    if (optionLength <= this.maxDisplayedRows) {                            //als er minder/gelijk aantal opties zijn dan default per pagina
        this.maxDisplayedRows = optionLength;                               //max per pagina naar aantal opties
    } else {
        this.onePageView = false;                                      //er zijn meerdere pagina's
    }

    if (!hasValue(this.selectedIndex)) {
        this.hoveredIndex = 0;
    }

    //starten met zoeken vanaf de waarde is is opgegeven in de INPUT
    if (hasValue(this.selectedValue)) {
        var keyIndex = this.getIndexByString(this.selectedValue);
        if (keyIndex != null) {
            this.hoveredIndex = keyIndex;
            jumpToRecord = true;
        }
    }

    if (this.hoveredIndex == 0) {

        this.ancorStart = 0;                                          //default startpunt is 0
        this.ancorEnd = this.maxDisplayedRows;                      //default eindpunt is maximaal aantal op een pagina

    } else {

        if ((this.hoveredIndex > (optionLength - this.maxDisplayedRows)) && this.hoveredIndex <= optionLength) {
            this.ancorStart = (optionLength - this.maxDisplayedRows);     //default startpunt is 0
            this.ancorEnd = optionLength;                               //default eindpunt is maximaal aantal op een pagina
            jumpToRecord = true;
        } else if ((this.hoveredIndex - this.maxDisplayedRows) < 0) {
            this.ancorStart = 0;                                          //default startpunt is 0
            this.ancorEnd = this.maxDisplayedRows;
        } else {
            this.ancorEnd = this.ancorStart + this.maxDisplayedRows;
            jumpToRecord = true;
        }
    }

    this.selectRecord(initChoice);                                                  //selecteer het gekozen record en plaats focus
    return jumpToRecord;
};


Service.prototype.selectRecord = function (initChoice) {

    var fbInitChoice = null;
    fbInitChoice = initChoice;


    var lastSelectedRecord = this.lastHoveredIndex;

    this.deSelectRecord();

    var fbSelectedRecord = hasValue(this.selectedIndex);

    if ((this.serviceObject.unavailable ||
        (this.serviceType == ENUM.serviceType.display) && !fbSelectedRecord)) {
        return;
    }

    var foRecord = this.rows[this.hoveredIndex];
    if (!foRecord) {
        return;
    }

    var rowExpiredAttr = foRecord.getAttribute("data-row-disabled");

    if (rowExpiredAttr == ENUM.expiredOptions.display) {
        if (fbInitChoice) {
            GLOBAL.charCode = keyCode.arrowDown;
        }

        if (this.hasValidOptions) {
            switch (GLOBAL.charCode) {
                case keyCode.arrowUp:
                case keyCode.arrowDown:
                    this.changeSelection();
                    break;
                default:
                    this.selectNextOption();
                    break;
            }
        }

        return;
    }
    foRecord.setAttribute("data-popupRow-selected", "true");

    var foRadioBtn = XDOM.getObject("POPCHC_" + this.hoveredIndex);
    if (fbInitChoice && (this.selectedIndex == this.hoveredIndex)) {
        foRadioBtn.classList.remove('radioBtn_icon');
        foRadioBtn.classList.add('radioBtn_icon_checked');
    }

    if (foRadioBtn) {
        foRadioBtn.focus();
    }
};

Service.prototype.deSelectRecord = function () {
    var foRecord = this.rows[this.hoveredIndex];
    this.lastHoveredIndex = this.hoveredIndex;

    if (!foRecord) {
        return;
    }

    foRecord.setAttribute("data-popupRow-selected", "false");
    var foRadioBtn = XDOM.getObject("POPCHC_" + this.hoveredIndex);

    if (foRadioBtn) {
        foRadioBtn.focus();
        // XDOM.classNameReplaceOrAdd(foRadioBtn, 'radioBtn_icon_checked', 'radioBtn_icon');
    }
};

Service.openChoiceFromSubfile = function (e) {
    XDOM.cancelEvent(e);
    // openService(null, true);
};

Service.close = function (event = null) {
    let modal = null;

    // Check for modals
    if (event) {
        modal = event.target;
    } else {
        modal = window.SCOPE.main.Dialogue.getModalsByGroup([window.SCOPE.session.SESSION.jobId, 'service'])[0];
    }

    if (modal) {
        modal.delete();

        // Service.currentService.close();
        Service.currentService = null;

        return true;
    }

    return false;
};

Service.autoOpen = function () {
    var serviceIcon = XDOM.query('[data-service-open][data-to-id="' + SESSION.activePage.cursorFocus + '"]:not([data-when="unavailable"])');
    if (!serviceIcon) {
        return;
    }
    switch (serviceIcon.getAttribute("data-service-open")) {
        case ENUM.serviceOpen.cursorOnly:
            break;
        case ENUM.serviceOpen.cursorAndError:
            if (SESSION.activePage.viewProperties.messageLevel != ENUM.attentionLevel.error) {
                return
            }
            break;
        case ENUM.serviceOpen.cursorAndBlank:
            if (XDOM.getObjectValue(SESSION.activePage.cursorFocus) != "") {
                return;
            }
            break;
        default:
            return;
            break;
    }
    XDOM.invokeClick(serviceIcon);
};

Service.handleKeyDown = function () {
    if (!Service.currentService) {
        return false;
    }

    if (Service.isOpening) { // ter voorkoming dat F4 ook als toetsen aanslag
        // gezien wordt hij opent namelijk op keyDown
        Service.isOpening = false;
        if (GLOBAL.charCode === keyCode.F4) {
            return true;
        }
    }

    //set timestamp for scrolling, while key is pressed
    var activeTimestamp = new Date();
    if (((activeTimestamp - this.currentService.autoSelectTimestamp) / 1000) > 0.08) {
        Service.currentService.autoSelectTimestamp = activeTimestamp;
        Service.currentService.handleKeyDown();
        GLOBAL.eventObject.cancel();
        GLOBAL.eventObject.remapKeyCode();
    }
    return true;
};

Service.prototype.handleKeyDown = function () {
    switch (GLOBAL.charCode) {
        case keyCode.F12:
        case keyCode.escape:
            Service.close();
            return;
            break;
        case keyCode.enter:
        case keyCode.space:
            this.returnValue();
            return;
            break;
        default:
            this.changeSelection();
            break;
    }

    return;
};

Service.prototype.changeSelection = function () {
    var isDisplayWindow = (this.type == ENUM.serviceType.display);
    var jumpToRecord = false;
    this.deSelectRecord();                //deselect records before setting new value

    switch (GLOBAL.charCode) {
        case keyCode.arrowUp:
            if (isDisplayWindow) {              //if displaywindow do not select records but pages
                keyPressed = keyCode.pageUp;
                break;
            }
            this.hoveredIndex--;              //select record above
            break;

        case keyCode.arrowDown:
            if (isDisplayWindow) {              //if displaywindow do not select records but pages
                keyPressed = keyCode.pageDown;
                break;
            }
            this.hoveredIndex++;              //select record below
            break;

        case keyCode.pageUp:
            if (!isDisplayWindow) {
                this.hoveredIndex -= this.maxDisplayedRows; //this.ancorStart - this.maxDisplayedRows;       //goes exact one page up
            } else {
                this.selectedIndex -= this.maxDisplayedRows;
            }
            break;

        case keyCode.pageDown:
            if (!isDisplayWindow) {
                this.hoveredIndex += this.maxDisplayedRows;//this.ancorEnd;        //goes exact one page up
            } else {
                this.selectedIndex += this.maxDisplayedRows;
            }
            break;

        default:
            var keyIndex = this.getIndexByKey();
            if (keyIndex != null) {
                this.hoveredIndex = keyIndex;
                jumpToRecord = true;
            }

            break;

    }

    this.selectRecord();
    this.defineScroll(jumpToRecord);
};


Service.prototype.selectNextOption = function () {
    this.hoveredIndex++; //select record below
    this.selectRecord();
    this.defineScroll();
};


Service.prototype.defineScroll = function (jumpToRecord) {
    var recordSelected = this.hoveredIndex;
    var enterNewPage = false;

    if (recordSelected < this.ancorStart) {                                   //go page up
        enterNewPage = true;
    } else if (recordSelected >= this.ancorEnd) {                             //go page down
        enterNewPage = true;
    }
    if (enterNewPage || jumpToRecord) {
        this.scrollToNewPage(jumpToRecord);
    }

};

Service.prototype.scrollToNewPage = function (jumpToRecord) {

    var recordSelected = this.hoveredIndex;
    var viewedRowsAtOnce = this.maxDisplayedRows;
    var optionLength = this.serviceObject.OPT.length;

    if (hasValue(recordSelected)) {

        //opening first time or use keyboard jump to record
        if (!jumpToRecord) {

            if (recordSelected < this.ancorStart) {

                if (recordSelected < 0) {
                    //goto last page
                    this.ancorStart = (optionLength - viewedRowsAtOnce);
                    this.hoveredIndex = (optionLength - 1);
                    this.ancorEnd = optionLength;

                } else {
                    //go page up
                    if ((viewedRowsAtOnce - this.hoveredIndex) <= 0) {
                        this.ancorStart -= viewedRowsAtOnce;
                        this.ancorEnd -= viewedRowsAtOnce;
                    } else {
                        this.ancorStart = 0;
                        this.ancorEnd = viewedRowsAtOnce;
                    }
                }

                this.selectRecord();
                this.resultDiv.scrollTop = (this.ancorStart * this.returnRowHeight());

            } else {

                if (recordSelected > (optionLength - 1) || (recordSelected == 0)) {

                    //goto first page
                    this.ancorStart = 0;
                    this.hoveredIndex = 0;
                    this.ancorEnd = viewedRowsAtOnce;

                } else {

                    //go page down
                    if ((this.hoveredIndex + viewedRowsAtOnce) <= optionLength) {
                        this.ancorStart += this.maxDisplayedRows;
                        this.ancorEnd += this.maxDisplayedRows;
                    } else {
                        this.ancorStart = (optionLength - viewedRowsAtOnce);
                        this.ancorEnd = (this.hoveredIndex + 1);
                    }

                }

                this.selectRecord();

                this.resultDiv.scrollTop = (this.ancorStart * this.returnRowHeight());
            }
        } else {

            //goto selected item
            this.ancorStart = recordSelected;
            this.ancorEnd = recordSelected + viewedRowsAtOnce;

            if ((recordSelected + this.maxDisplayedRows) > optionLength) {
                this.ancorStart = (optionLength - viewedRowsAtOnce);
                this.ancorEnd = this.hoveredIndex + 1;
            }
            this.resultDiv.scrollTop = (this.ancorStart * this.returnRowHeight());
        }
    }
};


Service.handleRowClick = function (event) {
    // Target the event target
    let index = event.target.getAttribute("data-service-select-index");

    if (!index) {
        return false;
    }

    Service.currentService.selectedIndex = index;
    Service.currentService.hoveredIndex = index;
    Service.currentService.returnValue();

    return true;
};

Service.handleHeadingClick = function (e) {
    var thCell = null;
    var serviceId = null;
    var serviceObject = null;
    var serviceType = null;

    //exclude sort buttons and input fields
    if (XDOM.GLOBAL.getAttribute("data-click-action") == "SortButton.handleOnClick" || e.target.tagName == "INPUT") {
        return;
    }
    thCell = XDOM.getParentByTagName(GLOBAL.eventSourceElement, "TH");

    if (!thCell) {
        return false;
    }

    serviceId = thCell.getAttribute("data-service-click-id");
    if (!serviceId) {
        return false;
    }

    serviceObject = XDOM.getObject(serviceId);
    if (serviceObject.getAttribute("data-when") === "unavailable" || serviceObject.dataset.hidden == 'true') {
        return;
    }

    serviceType = serviceObject.getAttribute("data-service-type");

    if (serviceType == ENUM.serviceType.calendar) {
        serviceObject = new Calender(serviceObject.getAttribute("data-to-id"), null, true);
        serviceObject.open();
        return true;
    }


    if (!(serviceType == ENUM.serviceType.display || serviceType == ENUM.serviceType.choice)) {
        return false;
    }
    serviceObject = Service.get(serviceObject);
    serviceObject.openByClick = true;
    serviceObject.open();
    return true;
};

Service.prototype.returnRowHeight = function () {
    var newRowHeight = null;
    if (minVersion('*8A')) {
        return this.rowHeight;
    }
    const zoomFactor = SCOPE.main.Settings.get('ZOOM_FACTOR');
    if (BrowserDetect.isChrome) {
        // newRowHeight = (this.rowHeight - MAIN.OCULUS.zoomFactors[MAIN.OCULUS.zoomLevel].dspRowOffset);
        newRowHeight = (this.rowHeight - MAIN.OCULUS.zoomFactors[zoomFactor].dspRowOffset);
    } else {
        return this.rowHeight;
    }


    newRowHeight.toFixed(4);
    return newRowHeight;

};

Service.prototype.returnValue = function () {
    if (!this.serviceObject.OPT[this.hoveredIndex][0]) {
        return;
    }

    var fsValue = this.serviceObject.OPT[this.hoveredIndex][0];
    var fsOldValue = null;
    var foTarget = XDOM.getObject(this.targetId);
    if (!foTarget) {
        return;
    }

    Service.close();

    if (foTarget.tagName == 'INPUT') {
        setOldValue(foTarget);
        fsOldValue = foTarget.value;
        foTarget.value = fsValue;
    }

    Service.retriveRelated(foTarget);

    if (foTarget.id == "WS_SFL") {
        Command.enter();
        return;
    }
    // Subfile.setChanged(this.recordNumber);

    if (foTarget && !SESSION.submitInProgress) {
        fp.next(foTarget);
    }

    if (fsOldValue != fsValue) {
        handleOnChange(foTarget);
    }


    return false;
};

Service.prototype.close = function () {

    var foTarget = XDOM.getObject(this.targetId);

    if (this.placeHolderID) {
        XDOM.removeDOMObject(this.placeHolderID);
    }

    this.openByClick = false;
    this.placeholder = null;

    if (foTarget && foTarget.tagName == "INPUT" && foTarget.type != "hidden") {
        foTarget.focus();
    } else {
        setCursor();
    }

    Service.currentService = null;
};

Service.prototype.setDimensions = function () {
    var foRecord = this.rows[0];
    var fiTableHeight = 0;
    var fcCharWidth = 9;
    var fc4CharsWidth = fcCharWidth * 4;
    var fcCloseBtnCharWidth = 2;
    var fiWidth = 0;
    var fiTextLength = this.maxTextLength;
    var fiTitleWidth = this.serviceObject.TTL.length + fcCloseBtnCharWidth;

    if (fiTitleWidth > fiTextLength) {
        fiTextLength = fiTitleWidth;
    }

    fiWidth = ((Math.floor((fiTextLength * fcCharWidth) / fc4CharsWidth)) + 1) * fc4CharsWidth;

    if (fiWidth < SETTINGS.minServiceWidth) {
        fiWidth = SETTINGS.minServiceWidth;
    }

    if (foRecord) {
        this.rowHeight = foRecord.offsetHeight;
    }

    if (this.serviceObject.OPT.length > this.maxDisplayedRows) {
        fiWidth += 16; // scrollBar
        fiTableHeight = this.maxDisplayedRows * this.returnRowHeight();
    } else {
        fiTableHeight = this.serviceObject.OPT.length * this.returnRowHeight();
        fiTableHeight = Math.ceil(fiTableHeight + (this.serviceObject.OPT.length - 3));
    }
};


Service.prototype.renderPlaceHolder = function () {
    // Create a modal
    let dialogue = window.SCOPE.main.Dialogue.create(
        this.placeHolderID + window.SCOPE.session.SESSION.jobId,
        `<h3 slot="header">${this.serviceObject.TTL}</h3>
       <i slot="header" class="control-icon dialogue-close fas fa-times control-icon"></i>`,
        "none",
        'false',
        this.placeHolderClass
    );

    // Nothing too clever, just hook into the close function if a close event is fired
    dialogue.addEventListener('deleteDialogue', Service.close);

    // Add the session ID and the function type to the groups array
    dialogue.group.push(window.SCOPE.session.SESSION.jobId);
    dialogue.group.push('service');

    // If singleView then group it
    if (SESSION.isSingleView) {
        dialogue.group.push('singleView');
    }

    this.placeholder = dialogue; // XDOM.createElement("DIV", this.placeHolderID ,this.placeHolderClass);
};

Service.prototype.getSelectedValue = function () {
    this.selectedValue = XDOM.getObjectValue(this.targetId);
    if (this.selectedValue === null) {
        return;
    }	//in columnheading is er geen targetId
    this.selectedValue = this.selectedValue.toUpperCase();
    // escape is niet nodig voor zover we kunnen bepalen
    // deze is uitgeschakeld ten behoeven van POM-2244
    // this.selectedValue = escape(this.selectedValue);
};


Service.prototype.hide = function () {
    var obj = XDOM.getObject(this.displayId);
    if (obj) {
        obj.className = 'hidden';
    }
};


Service.prototype.init = function () {
    var foTarget = XDOM.getObject(this.targetId);

    if (this.isInitialized) {
        return;
    }
    this.isInitialized = true;

    this.getDefinition();

    //een displayPanel hoeft geen targetObj te hebben.
    if (this.type == ENUM.serviceType.display) {
        if (!foTarget) {
            this.targetId = this.id;
            foTarget = XDOM.getObject(this.targetId);
        }
    }

    if (!foTarget) {
        return;
    }

    if (this.serviceType == ENUM.serviceType.retrive) {
        this.setDescripion();
    } else {
        this.initSettings();
        //if (!this.recordNumber) {
        //   this.setHeaderEvents();
        // }
    }
};


Service.prototype.render = function () {
    this.getSelectedValue();
    this.renderPlaceHolder();
    this.renderTitleBar();
    this.renderTable();
    this.renderResults();
    this.setDimensions();

    // Should open dialogue here after the rest of the rubbish has been rendered
    let openPos;

    // Get the adjusted position to open based on event type (naturally oculus fires click events for everything, so we check if not by checking mouse client position)
    if (GLOBAL.eventObject._event.clientX > 0 && GLOBAL.eventObject._event.clientY > 0) {
        openPos = window.SCOPE.main.Dialogue.nestedMousePos(GLOBAL.eventObject._event, {x: 15, y: -50}); // window.SCOPE.page
    } else {
        openPos = window.SCOPE.main.Dialogue.nestedMousePos(GLOBAL.eventObject._event, {x: 0, y: 0}); // window.SCOPE.page
    }

    // Open
    window.SCOPE.main.Dialogue.open(this.placeholder, openPos);
};
Service.prototype.renderTable = function () {
    this.resultDiv = XDOM.createElement("DIV", "popContent");
    this.placeholder.appendChild(this.resultDiv);
};


Service.prototype.renderTitleBar = function () {
    /* Empty */
};

Service.prototype.getColumnWidth = function () {

    var codeLength = 0;

    for (var i = 0, l = this.serviceObject.OPT.length; i < l; i++) {

        if (this.serviceObject.OPT[i][0].length > codeLength) {
            codeLength = this.serviceObject.OPT[i][0].length;
        }
    }

    return codeLength;
};

Service.prototype.getOptionExpiredState = function (optionExpiredState) {

    var response = {};
    response.renderOption = true;
    response.renderOptionMode = null;


    if (!optionExpiredState) {
        return response;
    }

    if (!this.hasValidOptions) {
        if (!optionExpiredState || optionExpiredState !== "*EXPIRED") {
            this.hasValidOptions = true;
        } else {
            if (this.optionExpiredMode == ENUM.expiredOptions.allow) {
                this.hasValidOptions = true;
            }
        }
    }

    if (optionExpiredState) {
        switch (this.optionExpiredMode) {
            case ENUM.expiredOptions.allow:
            //optie is zichtbaar en mag ook gekozen worden
            case ENUM.expiredOptions.display:
                //optie is zichtbaar maar mag NIET gekozen worden
                break;
            default:
                response.renderOption = false;
                break;
        }
        response.renderOptionMode = this.optionExpiredMode;
    }

    return response;

}


Service.prototype.renderChoiceRecord = function (optionCount, optionState) {

    var optionCode = this.serviceObject.OPT[optionCount][0];
    var optionDescription = this.serviceObject.OPT[optionCount][1];
    var optionExpired = null;

    if (optionState) {
        optionExpired = optionState.renderOptionMode;
    }

    if (this.selectedValue === optionCode) {
        this.selectedIndex = optionCount;
    }
    optionCode = optionCode.replace(/ /g, '\u00a0');

    var optionRecord = XDOM.createElement("DIV", "POPTR_" + optionCount, "pointerCursor popupRow");
    var optionRecordOverlay = XDOM.createElement("DIV", null, "popupRowDisabled");
    var optionColumn_1 = XDOM.createElement("DIV", null, "txtAlignCenter popupCol");
    var optionColumn_2 = null;
    var optionColumn_3 = null;
    var optionButton = XDOM.createElement("DIV", "POPCHC_" + optionCount, "pth-icon radioBtn_icon");
    var optionColumnTxt = null;

    // Add a click event to the optionRecord
    optionRecord.addEventListener('click', Service.handleRowClick);

    optionColumn_1.appendChild(optionButton);
    optionRecord.appendChild(optionColumn_1);

    if (!this.TargetIsHidden) {
        optionColumn_2 = XDOM.createElement("DIV", null, "txtAlignLeft popupCol valueLength_" + this.columnCodeWidth);
        optionColumnTxt = XDOM.createElement("U");
        optionColumnTxt.setAttribute('data-service-select-index', optionCount);
        optionColumnTxt.appendChild(XDOM.createTextNode(optionCode.substr(0, 1)));
        optionColumn_2.appendChild(optionColumnTxt);

        optionColumn_2.appendChild(XDOM.createTextNode(optionCode.substring(1)));
        optionColumn_2.setAttribute('data-service-select-index', optionCount);

        optionRecord.appendChild(optionColumn_2);
    }

    optionColumn_3 = XDOM.createElement("DIV", null, "txtAlignLeft popupCol");
    optionColumn_3.appendChild(XDOM.createTextNode(optionDescription));

    switch (optionExpired) {
        case "*DISPLAY": //<== DISPLAY ONLY, NO SELECTION POSSIBLE
            optionRecord.appendChild(optionRecordOverlay);
            optionRecord.setAttribute('data-row-disabled', optionExpired);
            break;
        case "*ALLOW":	//<== DISPLAY WITH HIGHLIGHT, SELECTION POSSIBLE
            optionRecord.setAttribute('data-row-disabled', optionExpired);
            break;
    }

    optionRecord.appendChild(optionColumn_3);

    this.rows[optionCount] = optionRecord;

    optionRecord.setAttribute('data-service-select-index', optionCount);
    optionColumn_1.setAttribute('data-service-select-index', optionCount);
    optionColumn_3.setAttribute('data-service-select-index', optionCount);
    optionButton.setAttribute('data-service-select-index', optionCount);
    this.resultDiv.appendChild(optionRecord);
};

Service.prototype.renderDisplayRecord = function (optionCount, optionState) {
    var optionCode = this.serviceObject.OPT[optionCount][0];
    var optionDescription = this.serviceObject.OPT[optionCount][1];
    var optionRecordOverlay = XDOM.createElement("DIV", null, "popupRowDisabled");
    var optionExpired = null;

    if (optionState) {
        optionExpired = optionState.renderOptionMode;
    }

    if (this.selectedValue === optionCode) {
        this.selectedIndex = optionCount;
    }
    optionCode = optionCode.replace(/ /g, '\u00a0');

    var optionRecord = XDOM.createElement("DIV", "POPTR_" + optionCount, "popupRow");
    var optionColumn_1 = null;
    var optionColumn_2 = null;
    var optionColumn_3 = null;
    var optionColumnTxt = null;

    if (!this.TargetIsHidden) {
        optionColumn_1 = XDOM.createElement("DIV", null, "txtAlignLeft popupCol valueLenth_" + this.columnCodeWidth);
        optionColumn_2 = XDOM.createElement("DIV", null, "txtAlignCenter popupCol colSpacing");

        optionColumn_1.appendChild(XDOM.createTextNode(optionCode));
        optionColumn_2.appendChild(XDOM.createTextNode("-"));
        optionRecord.appendChild(optionColumn_1);
        optionRecord.appendChild(optionColumn_2);
    }
    optionColumn_3 = XDOM.createElement("DIV", null, "txtAlignLeft popupCol");
    optionColumn_3.appendChild(XDOM.createTextNode(optionDescription));

    switch (optionExpired) {
        case "*DISPLAY": //<== DISPLAY ONLY, NO SELECTION POSSIBLE
            optionRecord.appendChild(optionRecordOverlay);
            optionRecord.setAttribute('data-row-disabled', optionExpired);
            break;
        case "*ALLOW":	//<== DISPLAY WITH HIGHLIGHT, SELECTION POSSIBLE
            optionRecord.setAttribute('data-row-disabled', optionExpired);
            break;
    }

    optionRecord.appendChild(optionColumn_3);

    this.rows[optionCount] = optionRecord;
    this.resultDiv.appendChild(optionRecord);
};

Service.prototype.renderResults = function () {
    var fsTempText = "";
    var optionState = null;
    var totalOptionCount = this.serviceObject.OPT.length;

    this.TargetIsHidden = isHidden(this.targetId);
    this.columnCodeWidth = this.getColumnWidth();

    if ((totalOptionCount) > this.maxDisplayedRows) {
        this.resultDiv.style.overflowY = "auto";
    }

    for (var optionCounter = 0; optionCounter < totalOptionCount; optionCounter++) {
        optionState = null;
        if (this.serviceObject.OPT[optionCounter][0]) {

            if (this.serviceObject.OPT[optionCounter][2]) {  //==> Check if expired value isSet
                optionState = this.getOptionExpiredState(this.serviceObject.OPT[optionCounter][2]);

                if (optionState && !optionState.renderOption) {
                    this.serviceObject.OPT[optionCounter] = null; //==> Option is expired and hidden
                    this.serviceObject.OPT.splice(optionCounter, 1);
                    optionCounter--;
                    totalOptionCount--;
                    continue;
                }
            } else {
                this.hasValidOptions = true;
            }

            fsTempText = this.serviceObject.OPT[optionCounter][0] + this.serviceObject.OPT[optionCounter][1];
            if (fsTempText.length > this.maxTextLength) {
                this.maxTextLength = fsTempText.length;
            }
            if (this.TargetIsHidden) {
                this.index[optionCounter] = this.serviceObject.OPT[optionCounter][1].charAt(0); // array met 1e
            } else {
                this.index[optionCounter] = this.serviceObject.OPT[optionCounter][0].charAt(0); // array met 1e
            }

            this.renderRecord(optionCounter, optionState);
        }
    }
};

Service.prototype.getDescription = function (value) {
    var fsValue = value.toUpperCase();
    if (!this.serviceObject || !this.serviceObject.OPT) {
        return;
    }
    for (var i = 0, l = this.serviceObject.OPT.length; i < l; i++) {
        if (fsValue == this.serviceObject.OPT[i][0]) {
            return this.serviceObject.OPT[i][1];
        }
    }
    return '';
};

/**
 * zoekt de in de index de eerste positie op die gelijk is aan de ingedrukte
 * toets vanaf de positie van de huidige selectedIndex wordt deze niet gevonden
 * dan wordt er gezocht vanaf 0
 *
 */
Service.prototype.getIndexByKey = function () {
    for (var i = this.hoveredIndex + 1, l = this.index.length; i < l; i++) {
        if (GLOBAL.char.toUpperCase() == this.index[i].toUpperCase()) {
            return i;
        }
    }
    for (var i = 0; i < this.hoveredIndex; i++) {
        if (GLOBAL.char.toUpperCase() == this.index[i].toUpperCase()) {
            return i;
        }
    }
    return null;
};

Service.prototype.getIndexByString = function (searchString) {
    for (var i = 0; i < this.index.length; i++) {
        if (searchString.toUpperCase() == this.index[i].toUpperCase()) {
            return i;
        }
    }

    if (this.isSFLLineSelector && searchString) { // find index for subfile row indicator
        for (let i = 0, l = this.serviceObject.OPT.length; i < l; i++) {
            if (searchString == this.serviceObject.OPT[i][0]) {
                return i;
            }
        }
        //default value is "scherm vullend" when no index is fount this actualy means scherm vullend since this mode might return anything
        this.selectedIndex = 0;
        return 0;

    }

    return null;
};


/**
 * Registreer Service Function
 * @param fsToId =toekennen aan object
 * @param fsArrayId =Array ID
 * @param serverObjectName =Service object
 * @param serverType =Service type (*RTV || *DSP || *CHC || *LST || *CAL)
 * @param faVisible array met indexen (1 is eerste) van objecten die niet getoond moeten worden
 */


/**
 * Registreer Service Function
 * @param toId              toekennen aan object
 * @param iconId            id van icon die service functie aanroept
 * @param serverObjectName  Service object
 * @param serverType        Service type (*RTV || *DSP || *CHC || *LST || *CAL)
 * @param headingAxis       naam van axis als service functie in de heading van een subfile staat
 * @param serverAction      default geen actie behalve door user met de volgende mogelijkheden:
 *                              *CSR:    de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van het TOID
 *                              *CSRBLK  de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van het TOID en het veld TOID is leeg
 *                              *CSRERR  de choice/calender worden geopend wanneer mWS_CSR de waarde heeft van het TOID en mWS_MGL is 'F' (gaan er van uit dat de fout op het TOID is * gevonden)
 *                              *AUTOACT de choice/calender worden altijd worden geopend, maar slechts
 *                              maximaal 1 per scherm (eerste)
 * @param visible boolean  true als object getoond moeten worden
 */

Service.delayedOpenTimer = null;
Service.delayedOpenId = null;

/**
 * het updaten van retreve waarde
 */
Service.update = function () {
    var foPageObjects = XDOM.queryAllScope("[data-service-type='" + ENUM.serviceType.retrive + "']");
    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        Service.retrive(foPageObjects[i]);
    }

};


Service.retriveRelated = function (foObject) {
    var foRetriveObject = XDOM.query("[data-to-id='" + foObject.id + "'][data-service-type='" + ENUM.serviceType.retrive + "']");
    if (GUI.Retrieve.update(foRetriveObject)) {
        return;
    }


    if (foRetriveObject) {
        Service.retrive(foRetriveObject);
    }
};

Service.retrive = function (obj) {
    // ***************************************************************************
    // Verkrijg de omschrijving van de code uit bijbehorende SSD
    // parms: this
    // return: --
    // ***************************************************************************
    var fsDescription = '';
    var foDisplay = obj;
    if (!foDisplay) {
        return;
    }

    var fsSource = obj.getAttribute("data-service-source");
    var fsToId = obj.getAttribute("data-to-id");
    var fsDisplayId = obj.getAttribute("data-service-id");
    var foTarget = null;
    foTarget = XDOM.getObject(fsToId);

    var fsValue = XDOM.getObjectValue(foTarget);
    var foServiceObject = Service.getDefinition(fsSource);
    if (foServiceObject.unavailable) {
        SCOPE.main.Dialogue.alert(fsSource + " " + foServiceObject.TTL  , "");
        return;
    }
    if (!fsValue || !fsValue.trim()) {
        fsValue = SESSION.activePage.headerData[fsToId];
    }
    if (!fsValue || !fsValue.trim()) {
        XDOM.setObjectValue(foDisplay, '');
        return;
    }

    for (var i = 0, l = foServiceObject.OPT.length; i < l; i++) {
        if (fsValue.toUpperCase() == foServiceObject.OPT[i][0].toUpperCase()) {
            fsDescription = foServiceObject.OPT[i][1];
            break;
        }
    }
    if (fsToId == 'WS_SFL' && !fsDescription) { // uitzondering voor subfile
        fsDescription = foServiceObject.OPT[0][1];
    }

    if (isHidden(foTarget)) {
        foDisplay.style.marginLeft = '0px';
    }

    XDOM.setObjectValue(foDisplay, fsDescription);
    return;
};


Service.getDefinition = function (serviceObjectName) {
    var serviceOpbjectFull = SESSION.activeFrame.name + '.' + serviceObjectName;
    var foReturn = getEval(serviceOpbjectFull);
    if (!foReturn) {
        foReturn = {};
        foReturn.TTL = getCapt('gNOSERVICEOBJECT');
        foReturn.OPT = [];
        foReturn.unavailable = true;
    }
    return foReturn;
};

Service.prototype.getDefinition = function () {
    this.serviceObject = Service.getDefinition(this.serviceObjectName);
};


Service.handleOnClick = function () {

    var fsId = GLOBAL.eventSourceElement.id;

    var fsType = XDOM.GLOBAL.getAttribute("data-service-type");//*CHC"
    if (!(fsType == ENUM.serviceType.display || fsType == ENUM.serviceType.choice)) {
        return false;
    }

    if (Service.currentService && Service.currentService.displayId == fsId) {
        Service.currentService.openByClick = true;
        return true;
    }

    if (Service.delayedOpenTimer) {
        clearTimeout(Service.delayedOpenTimer);
        Service.delayedOpenTimer = null;
    }


    var foService = Service.get(GLOBAL.eventSourceElement);

    foService.openByClick = true;
    foService.open();
    return true;
};

Service.handleMouseOver = function (e) {
    XDOM.getEvent(e);
    //stel dat er twee tegelijkertijd in progress zijn (vrijwel onmogelijk)
    if (Service.delayedOpenTimer) {
        clearTimeout(Service.delayedOpenTimer);
    }
    Service.delayedOpenId = GLOBAL.eventSourceElement.id;
    Service.delayedOpenTimer = setTimeout("Service.openDelayed()", Service.openDelay);
};


Service.handleMouseOut = function (serviceId) {
    //service is nog niet zichtbaar
    if (Service.delayedOpenTimer) {
        clearTimeout(Service.delayedOpenTimer);
    } else if (Service.currentService) {
        //service is zichtbaar
        if (!Service.currentService.openByClick) {
            Service.currentService.close();
        }
    }

    Service.delayedOpenTimer = null;

};

Service.openDelayed = function () {
    if (Service.currentService && Service.currentService.id == Service.delayedOpenId) {
        return;
    }
    var foService = Service.get(XDOM.getObject(Service.delayedOpenId));
    Service.delayedOpenTimer = null;
    if (!foService || foService.hidden) {
        return;
    } // -->


    foService.open();
};


function addAttributes(foObj) {
    FieldAttribute.apply(foObj);
    DataAttribute.apply(foObj);
    AttentionLevel.apply(foObj);
    ConditionalAttribute.apply(foObj);
}

Service.translate = function (source, value) {
    var serviceObject = Service.getDefinition(source);
    var description = null;
    for (var i = 0, l = serviceObject.OPT.length; i < l; i++) {
        if (value.toUpperCase() == serviceObject.OPT[i][0].toUpperCase()) {
            description = serviceObject.OPT[i][1];
            break;
        }
    }
    if (!description) {
        description = getCapt('gNOSERVICEOBJECT');
    }
    return description;
};

Service.retriveSFL = function (obj, target, display, recordValue) {
    // ***************************************************************************
    // Verkrijg de omschrijving van de code uit bijbehorende SSD
    // parms: this
    // return: --
    // ***************************************************************************
    var description = '';
    var value = recordValue || XDOM.getObjectValue(target);
    var source = obj.getAttribute("data-service-source");

    if (value) {
        value = value.trim();
    }

    if (!value) {
        XDOM.setObjectValue(display, '');
        return;
    }

    if (!display) {
        display = target;
    }
    description = Service.translate(source, value)


    if (isHidden(target)) {
        display.style.marginLeft = '0px';
    }

    if (display.previousSibling) {
        if (display.previousSibling.tagName == "OUTPUT") {
            display.previousSibling.setAttribute("data-hidden", "true");
        }
    }

    XDOM.setObjectValue(display, description);
    return;
};
/* when */
/* Load Timestamp 13:59:55.646 */
/* global XDOM, SESSION */

function When() {
}

When.update = function (serviceDomObj, serviceResponse) {
    var foPageObjects = null;
    var foServiceResponse = serviceResponse;
    var obj = null,
        fsField = '',
        fsValue = '';
    if (serviceDomObj) {
        foPageObjects = XDOM.queryAllScope('[data-when-field]', serviceDomObj.domObject);
    } else {
        foPageObjects = XDOM.queryAllScope('[data-when-field]');
    }
    if (foPageObjects) {
        for (var i = 0, l = foPageObjects.length; i < l; i++) {
            obj = foPageObjects[i];
            fsField = obj.getAttribute('data-when-field');
            fsValue = obj.getAttribute('data-when-value');

            if (!SESSION.activeData.headerAttributes || !fsField) {
                return;
            }

            if (!serviceResponse) {
                if (fsField === 'MODEF' && fsValue === '*NOTADD') {
                    if (SESSION.activeData.headerData.MODEF === 'ADD') {
                        When.set(obj, 'unavailable');
                    } else {
                        When.set(obj, 'available');
                    }
                } else if (SESSION.activeData.headerAttributes[fsField] === fsValue) {
                    When.set(obj, 'available');
                } else {
                    When.set(obj, 'unavailable');
                }
            } else {
                if (foServiceResponse && foServiceResponse[fsField] != undefined) {
                    if (foServiceResponse[fsField] === fsValue) {
                        When.set(obj, 'available');
                    } else {
                        When.set(obj, 'unavailable');
                    }
                }
            }
        }
    }
};

When.set = function (obj, value) {
    if (!obj) {
        return;
    }
    if (obj.dataset.screenMode == '*SUBVIEW') {
        When.set(XDOM.getObject('p-' + obj.id), value);
        //obj.parentNode.parentNode.setAttribute('data-when', value);
    }

    obj.setAttribute('data-when', value);
    When.setHeader(obj, value);
    When.setLabel(obj, value);
};

When.setLabel = function (obj, value) {
    const label = XDOM.queryScope(`[for="${obj.id}"]`);
    if (!label) {
        return;
    }
    label.setAttribute('data-when', value)
}
When.setHeader = function (obj, value) {
    let thCell = null;



    if (!obj.getAttribute('data-to-axis')) {
        return;
    }
    const head = XDOM.getParentByTagName(obj, 'THEAD');
    if (!head) {
        return;
    }


    thCell = XDOM.getParentByTagName(obj, 'TH');
    let axis = thCell.getAttribute('data-axis');

    //determine how manu rows we have
    const totalRows = head.querySelectorAll('tr').length
    //can't do a while loop because collspan might make some ths cels disapear so just try it 10 times
    for(let row = 1; row <= totalRows ; row++){
        const nextAxis = axis.replace('R2', `R${row}`);
        const thCell = head.querySelector("[data-axis='" + nextAxis +"']");
        if(thCell){ //does this cel actualy exists (might not because of rowspan
            thCell.setAttribute('data-default-cursor', (value === 'unavailable'))
        }
    }



    //
    // axis = thCell1.getAttribute('data-axis').replace('R2', 'R1');
    // thCell2 = head.querySelector("[data-axis='" + axis + "']");
    // axis = thCell1.getAttribute('data-axis').replace('R2', 'R3');
    // thCell3 = head.querySelector("[data-axis='" + axis + "']");
    //
    //
    // if (value === 'unavailable') {
    //     if (thCell1) {
    //         thCell1.setAttribute('data-default-cursor', 'true');
    //     }
    //     if (thCell2) {
    //         thCell2.setAttribute('data-default-cursor', 'true');
    //     }
    //     if (thCell3) {
    //         thCell3.setAttribute('data-default-cursor', 'true');
    //     }
    // } else {
    //     if (thCell1) {
    //         thCell1.setAttribute('data-default-cursor', 'false');
    //     }
    //     if (thCell2) {
    //         thCell2.setAttribute('data-default-cursor', 'false');
    //     }
    //     if (thCell3) {
    //         thCell3.setAttribute('data-default-cursor', 'false');
    //     }
    // }
};

/* logical */
/* Load Timestamp 13:59:55.646 */
/* global state, NAV, XDOM, GLOBAL, SESSION, advAJAX, keyCode */

Logical = function(){};

Logical.state ={
    checked:'checked',
    unchecked:'unchecked',
    unknown:'unknown'
};

Logical.mode ={
    input:'In',
    output:'Out'
};

Logical.getDisplayObj = function(obj){
    let objId = "";

    if(!obj){ return null; }; //-->

    objId =  obj.id.replace('-checkbox','');
    return XDOM.getObject(objId) || obj;
};

Logical.hide = function(obj){
    var foDisplayObject = Logical.getDisplayObj(obj);
    if(foDisplayObject){
        foDisplayObject.setAttribute("data-hidden", "true");
    }else{
        obj.setAttribute("data-hidden", "true");
    }

};

Logical.unHide= function(obj){
    var foDisplayObject = Logical.getDisplayObj(obj);
    if(foDisplayObject){
        foDisplayObject.setAttribute("data-hidden", "");
    }else{
        obj.setAttribute("data-hidden", "");
    }
};


Logical.protect= function(obj){
    var foDisplayObject = Logical.getDisplayObj(obj);
    if(foDisplayObject){
        foDisplayObject.setAttribute("data-protected", "true");
    }
};
Logical.unProtect= function(obj){
    var foDisplayObject = Logical.getDisplayObj(obj);
    if(foDisplayObject){
        foDisplayObject.setAttribute("data-protected", "false");
    }
};

Logical.update = function() {

    var foPageObjects = XDOM.queryAllScope('[data-datatype="*LGL"]');
    var foObj = null;
    var foValue = null;

    for (var i = 0, l = foPageObjects.length; i < l; i++) {
        foObj = foPageObjects[i];
        foValue = Logical.getObjValue(foObj);
        Logical.setObjValue(foObj, foValue);
    }
};

function isLogical(objIn){
    var obj = XDOM.getObject(objIn);
    if(!obj){ return false; }
    return (obj.id.indexOf('-checkbox') > -1 || (obj.getAttribute("data-datatype")==="*LGL" || obj.getAttribute("data-logical-state")));
}

Logical.getFieldName = function(fieldName){
    return fieldName.replace("-checkbox","");
};


/**
 * handeld click event op td af waar een logical in zit
 * @returns {undefined}
 */
Logical.handleTdClick = function(){
    var foInput = GLOBAL.eventSourceElement.querySelector("[data-datatype='*LGL']");
    if(foInput){
        Logical.clickHandler(foInput);
    }
};

/**
 * Maak alle checkboxjes leeg in werkenmet scherm
 * @returns {undefined}
 */
Logical.clearSelection = function(){
    var macroURL = SESSION.stack.currentMacro.getCurrentUrl();
    var impfURL = "";
    if(!SESSION.submitInProgress){

        if(GLOBAL.eventSourceElement.getAttribute("data-datatype")==="*LGL"){

            SESSION.submitInProgress = true;

            impfURL =  macroURL + "?ClearSelection=true";

            advAJAX.get({
                url : impfURL,
                onError:    function(response) {SESSION.submitInProgress = false;},
                onSuccess : function(response) {
                    NAV.Rowselector.clearAllLogicals();

                    var foClearAllChc =  XDOM.getObject("SLTALL-checkbox");
                    if(foClearAllChc){
                        Logical.setObjValue(foClearAllChc, "");
                    }
                    Logical.setLogicalCounter("0");

                    SESSION.submitInProgress = false;
                },
                onRetry :   function(response) {SESSION.submitInProgress = false;}
            });
        }
    }
};


/**
 * handeld een rechtstreeks click event af
 * @returns {Boolean}
 * #POM-2495 - Toegevoegd controle of een object visible of hidden is. Bij een hidden checkbox geen clickevent.
 */
Logical.handleOnClick = function(){
    if(!isLogical(GLOBAL.eventSourceElement) || SESSION.submitInProgress || GLOBAL.eventSourceElement.type == ENUM.dataType.hidden){
        return false;
    }

    //var fsDisplayId = GLOBAL.eventSourceElement.id.replace('-checkbox','');
    var fsDisplayId = GLOBAL.eventSourceElement.id+'-checkbox';
    var foInput = XDOM.getObject(fsDisplayId);
    Logical.clickHandler(foInput);
    return true;
};

Logical.clickHandler = function(foInput){
    if(!foInput || foInput.tagName!=="INPUT"){
        return;
    }

    if(XDOM.getBooleanAttribute(foInput, "data-protected")){
        return;
    }

    Logical.toggle(foInput);

    //werken met schermen
    if(foInput.getAttribute("data-sfl-all-selector")){
        NAV.Rowselector.toggleAll(foInput);
        return true;
    }






    //select op 1 regel
    if(foInput.getAttribute("data-rowselector") || foInput.getAttribute("data-multiselect")){
        NAV.Rowselector.handleClick(foInput);
    }


    handleOnChange(foInput);

    return true;
};

/**
 * mouseup omdat enter bij focus op knop een onclick geeft
 */
Logical.handleKeyUp = function(){
    if( isLogical(GLOBAL.eventSourceElement) && GLOBAL.charCode === keyCode.space && !XDOM.GLOBAL.getBooleanAttribute("data-protected")){
        let inpObj = XDOM.getObject(GLOBAL.eventSourceElement.id + '-checkbox');
        Logical.toggle(inpObj);
        handleOnChange(inpObj);
        return true;
    }
    return false;
};

Logical.isChecked = function(obj){
    return (Logical.getState(obj)===Logical.state.checked);
};



Logical.check = function(obj){
    if(Logical.isChecked(obj)){
        return;
    }
    Logical.toggle(obj);
};
Logical.uncheck = function(obj){
    if(!Logical.isChecked(obj)){
        return;
    }
    Logical.toggle(obj);
};

Logical.toggle = function(obj){
    var eState = Logical.getState(obj);
    var sValue = '';
    if(eState === Logical.state.checked){
        sValue = obj.getAttribute("data-off-value");
        if(sValue === '*UNDEF'){
            sValue = '';
        }
    }else{
        sValue = obj.getAttribute("data-on-value");
    }
    Logical.setObjValue(obj, sValue);
};

Logical.getState = function(obj){
    var fsValue = obj.getAttribute("data-value");
    if(!hasValue(fsValue)){
        fsValue = XDOM.getObjectValue(obj);
    }
    var fsOnValue = obj.getAttribute("data-on-value");
    var fsOffValue = obj.getAttribute("data-off-value");

    if(fsValue===fsOnValue){
        return Logical.state.checked;
    }
    if(fsValue===fsOffValue || fsOffValue==='*UNDEF'){
        return Logical.state.unchecked;
    }
    return Logical.state.unknown;
};

Logical.getObjValue = function(obj){
    let state =  obj.dataset.logicalState;
    let inp = XDOM.getObject(obj.id +'-checkbox' ) || obj;
    let retVal = '';


    switch(state){
        case Logical.state.checked:
            retVal =  inp.getAttribute("data-on-value") || 1;
            break;
        case Logical.state.unchecked:
            retVal =  inp.getAttribute("data-off-value") === '*UNDEF'?'':inp.getAttribute("data-off-value")  || 0;
            break;
        case Logical.state.unknown:
        //nothing
    }
    return retVal;
};

Logical.setObjValue = function(obj, oValue){
    let formField = XDOM.getObject(obj.id +'-checkbox' ),
        displayObject = obj;


    if(!hasValue(oValue)){return false;} //-->}

    if(!formField){
        formField = obj;
    }

    if(formField.dataset.datatype != "*LGL" && formField.dataset.sflAllSelector!="true"){ //&& !obj.dataset.logicalState
        return false;
    }

    if(hasValue(formField.value)){
        formField.value = oValue;
    }else{
        formField.setAttribute("data-value", oValue);
    }
    Logical.updateState(formField);
    return true;
};



Logical.updateState = function(formField,displayObject){

//	var foDisplayObject = XDOM.getObject(formField.id + "-checkbox");
    var checkboxObjectId = formField.id.replace('-checkbox','');
    var foDisplayObject = XDOM.getObject(checkboxObjectId);


    var fsState = Logical.getState(formField);
    if(!foDisplayObject &&  formField.parentNode){//in een subfile regel
        foDisplayObject = formField.parentNode.querySelector('#'+checkboxObjectId);
    }

    if(!foDisplayObject && displayObject){foDisplayObject = displayObject;}
    if(!foDisplayObject){foDisplayObject = formField;}

    if(XDOM.getAttribute(foDisplayObject, "data-logical-state") !== fsState){
        if(XDOM.getAttribute(formField, "data-rowselector")){
            Logical.updateLogicalCounter(fsState);
            //do we have an auto sum field if so we have to auto submit
            if(SESSION.activePage.autoSumFields){
                //when the state changes is caused by select all don't autosum just jet first let it set all the values
                if(GLOBAL.eventSourceElement.id!='SLTALL'){
                    Command.autoSum();
                }

            }
        }
    }

    foDisplayObject.setAttribute("data-logical-state", fsState);
};


Logical.updateLogicalCounter = function(fsState){

    var foCounterObject = null;
    var fiCurrentCount  = null;
    foCounterObject = XDOM.getObject("logicalCounter");
    fiCurrentCount  = XDOM.getObjectValue(foCounterObject);

    if(foCounterObject){

        switch(fsState){

            case "checked":
                fiCurrentCount++;
                break;
            case "unchecked":
                if(fiCurrentCount > 0){
                    fiCurrentCount--;
                }
                break;
            default:
                console.log('Fout bij afhandelen update logical counter');
                break;
        }

        Logical.setLogicalCounter(fiCurrentCount);

    }
};


Logical.setLogicalCounter = function(fsCount){
    var foCounterWrapper = null;
    foCounterWrapper = XDOM.getObject("clearSelectWrapper");
    var fiCurrentCount = 0;
    var foCounterObject = null;
    foCounterObject = XDOM.getObject("logicalCounter");

    if(fsCount !== null){
        fiCurrentCount = fsCount;
    }

    if(foCounterObject){
        XDOM.setObjectValue(foCounterObject, String(fiCurrentCount));
    }

    if(foCounterWrapper){
        if(fiCurrentCount <= 0){

            XDOM.setAttribute(foCounterWrapper, "data-hidden", "true");
        }else{
            XDOM.setAttribute(foCounterWrapper, "data-hidden", "false");
        }
    }

    return;
};




/* events */
/* Load Timestamp 13:59:55.646 */
/* global MultiSelect, Subfile, Service, Trigger, Command, GUI, Validate, GLOBAL, Mask, SESSION, XDOM, INP, QuickSearch, Search, ActionCommand, Logical, Panel, NAV, Upload, Calender, Dragger, Stateless, Table, Help, oculusImage, Modef, Messages, Prompt, SortButton, Link, OCULUS, PFMBOX, keyCode, TextArea, fp, Barcode, TopView, GFX, QueryList */

function checkModal(e) {
    if (XDOM.objectUnderModal(e.target)) {
        XDOM.cancelEvent(e);
        return true;
    }
    return false;
}

function handleKeyDown(e) {
    // ***************************************************************************
    // Keyboard afhandeling bij toets naar beneden
    // parms: gEVT=event onkeydown
    // return: --
    // ***************************************************************************
    XDOM.getEvent(e);
    OCULUS.checkKeyCode(e);
    //keyhandling managed directly
    if (Calender.currentInstance) {
        return false;
    }

    if (checkModal(e)) {
        return false;
    } //als een element onder een modal scherm zit mogen er geen key events gehonoreerd worden
    if (Events.handleKeydown(e)) {
        return false;
    }
    if (Stateless.Page.isLoading()) {
        return false;
    } //alleen bij een object uit een stateless Page die laad
    INP.handleKeyDown();
    if (QuickSearch.HandleKeyDown()) {
        return false;
    }
    if (Service.handleKeyDown()) {
        return false;
    }
    // if (Calender.handleKeyDown()) {
    //   return false;
    // }
    if (GLOBAL.eventSourceElement.id === 'MEXIT') {
        return false;
    }
    if (Subfile.handleKeyDown()) {
        return false;
    }
    if (blocked()) {
        return false;
    }
    if (handleSpecialKeys()) {
        return false;
    }
    if (Mask.handleKeyDown()) {
        return false;
    }
    Barcode.handleKeyDown();
    TextArea.handleKeyDown();
    fp.handleKeyDown();
    if (Stateless.Page.handleKeyDown()) {
        return false;
    }
    if (Stateless.panel.handleKeyDown()) {
        return false;
    }
    if (GUI.events.keyDown()) {
        return false;
    }
    return Command.handleKeyDown();
}

function registerEvents() {
    var foRegTarget = SESSION.activeFrame.document;
    //Events.register(SESSION.activeFrame.document);
    XDOM.addEventListener(SESSION.activeForm, 'dblclick', handledblClick);
    XDOM.addEventListener(SESSION.activeForm, 'submit', handleSubmit);
    XDOM.addEventListener(foRegTarget, 'keydown', handleKeyDown);
    XDOM.addEventListener(foRegTarget, 'keyup', handleKeyUp);
    XDOM.addEventListener(foRegTarget, 'keypress', handleKeyPress);

    XDOM.addEventListener(foRegTarget, 'mouseup', handleMouseUp);
    XDOM.addEventListener(foRegTarget, 'click', handleOnclick);

    XDOM.addEventListenerToNode('[data-allow-drop]', 'dragover', drag.over);
    XDOM.addEventListenerToNode('[data-allow-drop]', 'drop', drag.drop);

    XDOM.addEventListener(foRegTarget, 'mousedown', handleMouseDown);
    XDOM.addEventListenerToNode('[data-focus-action]', 'focus', handleFocus);
    XDOM.addEventListenerToNode('[data-blur-action]', 'blur', handleBlur);
    XDOM.addEventListenerToNode('[data-mouseover-action]', 'mouseover', handleMouseOver);
    XDOM.addEventListenerToNode('[data-mouseout-action]', 'mouseout', handleMouseOut);

    //new direct events
    XDOM.addEventListenerToNode('[data-service-type="*CAL"]', 'click', Calender.handleOnClick);
    XDOM.addEventListenerToNode('TH[data-service-click-id]', 'click', Service.handleHeadingClick);
    XDOM.addEventListenerToNode('[data-wscmd-type]', 'click', Command.handleOnClick);
    XDOM.addEventListenerToNode('#openlink', 'click', (e)=>SCOPE.main.directLink.handleOnClick(e));
    XDOM.addEventListenerToNode('DIV[data-search-type="quickSearch"]', 'click', QuickSearch.handleOnClick);

    Label.registerEvents();

}

/**
 * ter voorkoming van een submit bij het gebruik van enter
 * @param {type} e
 * @returns {Boolean}
 */
function handleSubmit(e) {
    XDOM.cancelEvent(e);
    return false;
}

function handleKeyUp(e) {
    // ***************************************************************************
    // Keyboard afhandeling bij toets omhoog
    // parms: gEVT=event onkeyup
    // return: --
    // ***************************************************************************
    if (Events.handleAllEvents(e)) {
        return false;
    }
    XDOM.getEvent(e);
    if (Stateless.Page.isLoading()) {
        return false;
    }
    OCULUS.removeKeyCode(e);
    // if(XDOM.GLOBAL.getAttribute('data-panel-id')){return;}
    if (blocked()) {
        return false;
    }

    if (QuickSearch.HandleKeyUp()) {
        return false;
    }
    if (Calender.handleKeyUp(e)) { //Calender.currentInstance
        return false;
    }
    if (Service.currentService) {
        return false;
    }
    if (TextArea.handleKeyUp()) {
        return true;
    }
    if (fp.handleKeyUp()) {
        return true;
    }

    if (Barcode.handleKeyUp()) {
        return true;
    }
    if (Logical.handleKeyUp()) {
        return false;
    }
    if (GUI.LogicalIn.handleKeyUp()) {
        return false;
    }
    if (HandleKeyUpAction()) {
        return false;
    }

    INP.handleKeyUp();
    return true;
}

/**
 * dit is geen event handler obj is een dom object
 * @param objIn
 */
function handleOnChange(objIn) {
    if (SESSION.submitInProgress) {
        return;
    }

    if (!Mask.isMask(objIn) && objIn.tagName.toUpperCase() !== 'SCRIPT' && objIn.value) {
        objIn.setAttribute('value', objIn.value.trim()); //anders werken css selectors op de value attribute niet pff.
    }

    var obj = objIn || GLOBAL.eventSourceElement;
    if (!Validate.test(obj)) {
        obj.setAttribute('data-validation-error', 'true');
        return false;
    }

    if (obj.hasAttribute('data-validation-error')) {
        obj.removeAttribute('data-validation-error');
    }

    if (GUI.events.change(objIn)) {
        return;
    }
    Stateless.Page.set(objIn);
    Service.retriveRelated(obj);
    addAttributes(obj);
    setOldValue(obj);

    if (!obj.dataset.statelessPageId) {
        //because of scoping problems don't allow this in stateless
        Subfile.setChanged(obj.getAttribute('data-record-number'));
    }

    Stateless.Page.set();
    if (Stateless.Page.inputOnChange(objIn)) {
        return;
    }
    Command.resetEnter();
    resetMessage();

    if (autoSubmit(obj) || Trigger.fire([obj.id])) {
        Stateless.setSubviewActive(obj);
        return;
    }

    return;
}

function autoRenew() {
    SESSION.stack.currentSession.autoRenewInterval = null;
    Command.enter();
    return;
}

function autoSubmit(objIn) {
    var obj = XDOM.getObject(objIn);
    //prevent blur action
    if (
        !isAutoSubmitField(obj) ||
        XDOM.getBooleanAttribute(obj, 'data-block-autosubmit') ||
        SESSION.session.cancelBlurEvent
    ) {
        SESSION.session.cancelBlurEvent = false;
        return false;
    }
    var panelId = XDOM.getAttribute(obj, 'data-panel-id');
    var editPanel = GUI.BasePanel.instances[panelId];
    var stagelessPageId = XDOM.getAttribute(obj, 'data-stateless-page-id');
    if (Stateless.Page.reload(stagelessPageId)) {
        return;
    }
    if (editPanel && !stagelessPageId) {
        editPanel.send('ENTER', obj.id.replace(panelId + '-', ''));
        return true;
    }

    SESSION.activePage.blockSearch = true;
    SESSION.activePage.autoSubmitInputObject = obj;
    Command.enter();
    return true;
}

function handledblClick(e) {
    XDOM.getEvent(e);
    for (var i = 0; i < GLOBAL.eventSourceElement.attributes.length; i++) {
        attr = GLOBAL.eventSourceElement.attributes[i];

        if (/^data-/.test(attr.nodeName)) {
            console.log(attr.nodeName, "'" + attr.nodeValue + "'");
        }
    }
}

//
// /**
//  * omdat de for tag niet werkt met een a
//  * (waar de checkbox nu van is) moet het
//  * for gedrag helaas worden na gebouwd
//  */
// function checkBoxForClick() {
//   let forId = GLOBAL.eventSourceElement.getAttribute('for'),
//       forObj = XDOM.getObject(forId);
//   if (!forObj ) {return false;}
//   let forType = 'unHandled';
//
//   if(forObj.classList.contains('checkbox'))  {forType = 'checkbox'}
//   if(forObj.classList.contains('topView'))   {forType = 'topView'}
//
//   switch(forType) {
//     case 'topView':
//       XDOM.invokeClick(forObj);
//       return true;
//     case 'checkbox':
//
//       XDOM.invokeClick(forObj);
//       XDOM.cancelAndRemap();
//       forObj.focus();
//       INP.handleOnFocus(forObj);
//       return true;
//     default:
//       return false;
//   }
// }

function handleOnclick(e) {
    SCOPE.main.ContextMenu.clickOutside(e);
    SCOPE.main.directLink.handleOnClick(e);
    if (Events.handleAllEvents(e)) {
        return false;
    }
    XDOM.getEvent(e);
    // if (checkBoxForClick()) {
    //   return false;
    // }
    Stateless.setSubviewActiveOnClick();
    if (INP.returnToErrorField()) {
        return false;
    }
    if (handleClickAction(e)) {
        return false;
    }
    // if (Command.handleOnClick()) {
    //   return false;
    // }
    // if (QuickSearch.sortButtonClick()) {
    //   return false;
    // }
    // if (QuickSearch.handleOnClick()) {
    //   return false;
    // }
    if (Search.handleHeadingClick()) {
        return false;
    }
    if (ActionCommand.handleClick()) {
        return false;
    }
    if (Logical.handleOnClick()) {
        return false;
    }
    if (Service.handleOnClick()) {
        return false;
    }
    if (Panel.closePanelClick()) {
        return false;
    }
    if (NAV.sessionLauncher.handleClick(e)) {
        return false;
    }
    if (Upload.handleClick()) {
        return false;
    }
    //Calender.handleOnClick();
    Subfile.handleOnClick();
}

function handleMouseDown(e) {
    if (Events.handleAllEvents(e)) {
        return false;
    }
    XDOM.getEvent(e);
    var mouseDownAction = XDOM.GLOBAL.getAttribute('data-mouseDown-action');

    switch (mouseDownAction) {
        case 'Command.execute':
            if (Mask.isMask(SESSION.activePage.lastSelectedInput)) {
                Mask.returnValues(SESSION.activePage.lastSelectedInput);
            }

            Command.execute(GLOBAL.eventSourceElement.id);
            break;
        case 'Dragger.start':
            updatePanelSort(GLOBAL.eventSourceElement);
            Dragger.start(GLOBAL.eventSourceElement);

            break;
    }
}

function HandleKeyUpAction() {
    var action = XDOM.GLOBAL.getAttribute('data-keyup-action');
    if (!action) {
        return false;
    }
    switch (action) {
        case 'GUI.LogicalIn.handleKeyUp':
            GUI.LogicalIn.handleKeyUp();
            break;
    }
    return true;
}

function handleClickAction(e) {
    var clickAction = XDOM.GLOBAL.getAttribute('data-click-action');
    if (!clickAction) {
        return false;
    }
    switch (clickAction) {
        case 'logout':
            logout();
            break;
        // case 'QuickSearch.selectFieldClick':
        //     QuickSearch.selectFieldClick();
        //     break;
        case 'popupPanel.close':
            popupPanel.close(XDOM.GLOBAL.getAttribute('data-popup-panel-id'));
            break;
        case 'closeMessageBox':
            closeMessageBox();
            break;
        case 'EditInfo.open':
            EditInfo.open();
            break;
        case 'QueryList.open':
            QueryList.open();
            break;
        case 'TopView.close':
            TopView.close();
            break;
        case 'GFX.Chart.onclick':
            GFX.Chart.onclick(e);
            break;
        case 'Stateless.panel.closeClick':
            Stateless.panel.closeClick();
            break;
        case 'MultiSelect.open':
            MultiSelect.open();
            break;
        case 'Stateless.Page.enter':
            Stateless.Page.enter();
            break;
        case 'Stateless.Page.accept':
            Stateless.Page.accept();
            break;
        case 'Stateless.Page.reset':
            Stateless.Page.reset();
            break;
        // case 'Table.rowClickHandler':
        //   Table.rowClickHandler();
        //   break;
        case 'oculusImage.expand':
            oculusImage.expand();
            break;
        case 'Modef.handleOnClick':
            Modef.handleOnClick();
            break;
        case 'Service.close':
            Service.close();
            break;
        case 'Messages.close':
            Messages.close();
            break;
        case 'closePopUp':
            closePopUp();
            break;
        case 'Calender.setToday':
            Calender.setToday();
            break;
        case 'Calender.previousYear':
            Calender.previousYear(null, 'usr');
            break;
        case 'Calender.previousMonth':
            Calender.previousMonth(null, 'usr');
            break;
        case 'Calender.nextMonth':
            Calender.nextMonth(null, 'usr');
            break;
        case 'Calender.nextYear':
            Calender.nextYear(null, 'usr');
            break;
        case 'Calender.returnDate':
            Calender.returnDate();
            break;
        case 'closeHighSlide':
            closeHighSlide();
            break;
        case 'GUI.infoTitle.hide':
            //GUI.infoTitle.hide(GLOBAL.eventObject);
            break;
        case 'GUI.BasePanel.close':
            GUI.BasePanel.close();
            break;
        case 'GUI.BasePanel.startDragging':
            GUI.BasePanel.startDragging();
            break;
        case 'GUI.InfoWindow.handlePanelClick':
            GUI.InfoWindow.handlePanelClick();
            break;
        case 'GUI.InfoWindow.handleClick':
            GUI.InfoWindow.handleClick();
            break;
        case 'GUI.EditWindow.handleClick':
            GUI.EditWindow.handleClick();
            break;
        case 'GUI.Signature.clearCanvas':
            GUI.Signature.clearCanvas();
            break;
        case 'GUI.Signature.sendCanvas':
            GUI.Signature.sendCanvas();
            break;
        case 'GUI.EditWindow.handleReset':
            GUI.EditWindow.handleReset();
            break;
        case 'GUI.EditWindow.handleSubmit':
            GUI.EditWindow.handleSubmit();
            break;
        case 'GUI.LogicalIn.handleOnClick':
            GUI.LogicalIn.handleOnClick();
            break;
        case 'GUI.DisplayService.open':
            GUI.DisplayService.open();
        case 'Search.handleOnClick':
            Search.handleOnClick();
            break;
        case 'TopView.handleOnClick':
            TopView.handleOnClick();
            break;
        case 'Service.handleOnClick':
            Service.handleOnClick();
            break;
        case 'SortButton.handleOnClick':
            SortButton.handleOnClick();
            break;
        case 'Logical.handleTdClick':
            Logical.handleTdClick();
            break;
        case 'Logical.clearSelection':
            Logical.clearSelection();
            break;
        case 'Link.handleOnClick':
            Link.handleOnClick();
            break;
        case 'popupPanel.handleHeaderClick':
            popupPanel.handleHeaderClick();
            break;
    }
    return true;
}

function handleMouseOut(e) {
    XDOM.getEvent(e);
    var action = XDOM.GLOBAL.getAttribute('data-mouseout-action');
    if (!action) {
        return false;
    }
    switch (action) {
        case 'GUI.InfoWindow.handleMouseOut':
            GUI.InfoWindow.handleMouseOut();
            break;
        case 'Service.handleMouseOut':
            Service.handleMouseOut();
            break;
    }
}

/**
 * checks if the relatedTarget is a command button and sif so will it cause a submit
 *
 * @param obj
 * @returns {boolean}
 */
function relatedTargetCausedSubmit(obj) {
    //is the object a command button
    if (!obj?.dataset?.wscmdType) return false;

    //is the button enabled
    return (obj?.dataset?.buttonEnabled == "true");
}
function handleBlur(e) {
    //test if related button is an action button
    if(relatedTargetCausedSubmit(e.relatedTarget)) {
        return;
    } //nothng to do a command button was clicked

    XDOM.getEvent(e);
    if (QuickSearch.gotFocus) {
        // MVB: Deze 'gotFocus' moet ook af en toe weer uitgezet worden ik weet nog niet waar overal
        return; // snelzoek is automatisch geopend er hoeft geen blur actie te worden uitgevoerd of een daaraan verbonde onchange
    }
    var action = XDOM.GLOBAL.getAttribute('data-blur-action');
    if (!action) {
        return false;
    }
    switch (action) {
        case 'INP.handleOnBlur':
            INP.handleOnBlur(e);
            break;
        case 'Subfile.handleRowBlur':
            Subfile.handleRowBlur();
            break;
    }
}

function handleFocus(e) {
    XDOM.getEvent(e);
    Stateless.Page.onFocus();
    var action = XDOM.GLOBAL.getAttribute('data-focus-action');
    if (!action) {
        return false;
    }
    switch (action) {
        case 'INP.handleOnFocus':
            INP.handleOnFocus();
            break;
        case 'Subfile.handleRowFocus':
            Subfile.handleRowFocus();
            break;
    }
}

function handleMouseOver(e) {
    XDOM.getEvent(e);
    var action = XDOM.GLOBAL.getAttribute('data-mouseover-action');
    if (!action) {
        return false;
    }
    switch (action) {
        case 'GUI.InfoWindow.handleMouseOver':
            GUI.InfoWindow.handleMouseOver();
            break;
        // i.o.m. roel we don't open service function on hover anymore
        // case 'Service.handleMouseOver':
        //     Service.handleMouseOver();
        //     break;
    }
}

function handleMouseUp(e) {
    XDOM.getEvent(e);
    if (
        SESSION.activePage.lastFocusedField === GLOBAL.eventSourceElement.id &&
        GLOBAL.eventSourceElement.dataset.selectAllNow !== 'true'
    ) {
        return false;
    }
    GLOBAL.eventSourceElement.dataset.selectAllNow = false;
    INP.select();
}

function handleSpecialKeys() {
    if (handleAltF1()) {
        XDOM.cancelAndRemap();
        return true;
    }
    if (handleCrtlKey()) {
        XDOM.cancelAndRemap();
        return true;
    }
    if (handleShiftKey()) {
        XDOM.cancelAndRemap();
        return true;
    }
    if (handleFunctionKey()) {
        XDOM.cancelAndRemap();
        return true;
    }
    return false;
}

function handleKeyPress(e) {
    XDOM.setSelection();
}

//function handleKeyPress(e) {
//// ***************************************************************************
//// Keyboard afhandeling bij toets ingedrukt
//// parms: gEVT=event onkeypress
//// return: --
//// ***************************************************************************
//XDOM.getEvent(e);
//
//if(XDOM.GLOBAL.getAttribute('data-panel-id')){
//  return;
//}
//if(SESSION.protected || blokedKeys()) {
//  GLOBAL.eventObject.remapKeyCode();
//  GLOBAL.eventObject.cancel();
//  return false;
//}
//if ( (GLOBAL.charCode == keyCode.enter) && (GLOBAL.eventObjectTAG == 'INPUT') ) {
//  return false;
//}
//
//return true;
//}

/**
 * handles hotkey for opening help (ALT + F1)
 * @returns {boolean} indicationg the event is handled
 */
function handleAltF1() {
    //is (ALT + F1) pressed
    if (!(GLOBAL.eventObject.altKey && GLOBAL.charCode == keyCode.F1)) {
        return false;
    }

    //get the help button
    const helpButton = SCOPE.pageDoc.querySelector('[data-event-class="SessionUserAction"][data-button-icon="help"]');

    //if found invoke the klick event
    if (helpButton) {
        helpButton.click();
    }
    return true;
}

function handleCrtlKey() {
    // ***************************************************************************
    // Keyboard afhandeling icm CTRL key
    // parms:  GLOBAL.eventObject=event
    // return: --
    // ***************************************************************************
    var fRESET = true;

    if (GLOBAL.eventObject.ctrlKey && !GLOBAL.eventObject.altKey) {
        // ***
        switch (GLOBAL.charCode) {
            case 46: // CTRL + DEL
                break;
            case 49: // CTRL + 1
            case 50: // CTRL + 2
            case 51: // CTRL + 3
            case 52: // CTRL + 4
            case 53: // CTRL + 5
            case 54: // CTRL + 6
            case 55: // CTRL + 7
            case 56: // CTRL + 8
            case 57: // CTRL + 9
                var fiNr = GLOBAL.charCode - 48;
                var foBtn = XDOM.getObject('btnPos' + fiNr);
                if (foBtn) {
                    XDOM.invokeClick(foBtn);
                }
                break;
            case 78: // CTRL + n
                break;
                // case 79: // ctrl + 0
                // case 82: // ctrl + r
                // case 115: // ctrl F4
                //   OCULUS.cancelEndApplication = true;
                //   jsc_CONFIRMEXIT();
                break;
            case 116: // ctrl F5
                GLOBAL.eventObject.remapKeyCode();
                break;
            case 118: // ctrl F7
                Command.execute('PRVPAG');
                break;
            case 119: // ctrl F8
                Command.execute('NXTPAG');
                break;
            default:
                fRESET = false;
                break;
        }
        if (fRESET) {
            GLOBAL.eventObject.remapKeyCode();
            return true;
        }
    }
    return false;
}

function handleShiftKey() {
    // ***************************************************************************
    // Keyboard afhandeling icm SHIFT key
    // parms:  GLOBAL.eventObject=event
    // return: --
    // ***************************************************************************
    var fRESET = true;

    if (GLOBAL.eventObject.shiftKey) {
        switch (GLOBAL.charCode) {
            case 118: // shift F7
                Command.execute('PAGEUP');
                break;
            case 119: // shift F8
                Command.execute('PAGEDN');
                break;
            case 120: // shift F9
                Command.execute('BEGPAG');
                break;
            case 121: // shift F10
                Command.execute('ENDPAG');
                break;
            default:
                fRESET = false;
                break;
        }
        if (fRESET) {
            GLOBAL.eventObject.remapKeyCode();
            return true;
        }
    }
    return false;
}

/**
 * f4 opent zoek, snelzoek, service functies en calenders
 *
 */
function handleF4F2(item) {
    XDOM.cancelEvent();
    let id = GLOBAL.eventSourceElement.id;


    if (Mask.isMask(GLOBAL.eventSourceElement)) {
        id = GLOBAL.eventSourceElement.getAttribute('data-mask-target');
    }
    let toIdObjects = Array.from(
        XDOM.queryAll('[data-to-id="' + id + '"]:not([data-service-type="*RTV"]):not([data-when="unavailable"]):not([data-disable="true"])')
    );
    //loop de objecten af en kijk wat je er mee kan doen



    let searchObj = toIdObjects.filter(function (obj) {
        return typeof obj.dataset.searchId !== 'undefined';
    });
    let quickSearchObj = toIdObjects.filter(function (obj) {
        return typeof obj.dataset.quicksearchId !== 'undefined';
    });
    let queryListSearch = toIdObjects.filter(function (obj) {
        return obj.dataset.clickAction == 'QueryList.open' ;
    });

    // prioritijd
    // eerst een gewone zoek
    // vervolgens een querylist die als zoek is ingericht
    // dan een snelzoek
    // vervolgens het item (0 of 1) openen afhankelijk van f2 of f4 object in de dom met de juiste to-id bij 2 en er is maar 1 object dan 0 gebruiken
    //this array contains toIds sorted by priority
    toIdObjects = [...searchObj, ...queryListSearch, ...quickSearchObj, ...toIdObjects];
    let ObjectToOpen = toIdObjects[item] || toIdObjects[0]
    if (ObjectToOpen) {
        if (ObjectToOpen.getAttribute('data-quicksearch-id')) {
            //object is een snelzoek
            QuickSearch.handleFunctionKEY();
        } else {
            XDOM.invokeClick(ObjectToOpen);
        }
    }
}

function handleFunctionKey() {
    // ***************************************************************************
    // Keyboard afhandeling FUNCTION key Fxx en andere speciale toetsen
    // parms: gEVT=event
    // return: --
    // ***************************************************************************
    switch (GLOBAL.charCode) {
        case 8: // backspace
            return false;
            if (GLOBAL.eventSourceElement.tagName.toUpperCase() !== 'INPUT') {
                return false;
            }
            break;
        case keyCode.tab: // tab
            return false;
            break;
        case keyCode.F2:
            //1 indicating second element with a toid to the object
            handleF4F2(1);
            break;
        case keyCode.F4:
            //0 indicating first element with a toid to the object
            handleF4F2(0);
            break;
        case keyCode.F6:
            Command.execute('RESET');
            break;
        case keyCode.F7:
            Command.execute('PRVRCD');
            break;
        case keyCode.F8: // F8
            Command.execute('NXTRCD');
            break;
        case keyCode.F9: // F9
            Command.execute('FSTRCD');
            break;
        case keyCode.F10: // F10
            Command.execute('LSTRCD');
            break;
        case keyCode.F11: // F11
            Command.execute('RESET');
            break;
        case keyCode.escape:
        case keyCode.F12:
            if (closeAllModalObjects()) {
                return true;
            }

            if (SESSION.activePage.screenType === '*PGM' && XDOM.getBooleanAttribute('RETURN', 'data-button-enabled')) {
                gotoPreviousProgram();
            }
            if (SESSION.activePage.screenType === '*SCH') {
                Search.close();
                break;
            }

            if (SESSION.isSingleView) {
                TopView.close();
            }

            break;

        default:
            return false;
            break;
    }

    return true;
}

function handleNumericPoint() {
    if (
        GLOBAL.eventSourceElement.getAttribute('data-datatype') !== '*DEC' ||
        GLOBAL.eventSourceElement.value.length >= GLOBAL.eventSourceElement.maxLength
    ) {
        return;
    }

    //GLOBAL.charCode==keyCode.point  bij een punt op het toetsenbord geen komma invoegen
    if (GLOBAL.charCode === keyCode.numpadPoint) {
        GLOBAL.eventObject.cancel();
        XDOM.insertAtCursor(GLOBAL.eventSourceElement, ',');
    }
}

function setEventsMessage(level, text) {
    let panel = XDOM.GLOBAL.getEditWindow(),
        page = Stateless.Page.get();

    if (page) {
        page.setMessage(level, text);
    }
    if (panel) {
        panel.footer.setMessage(level, text);
        return;
    }
    setMessage(level, text);
}

function onFocusPage(e) {
    MAIN.removeFocus();
    MAIN.deActivateMenuHover();
}

function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

/* stateless-panel */
/* Load Timestamp 13:59:55.647 */
/* global XDOM, BrowserDetect, Panel, Dragger, GLOBAL, SETTINGS, SESSION, ENUM, keyCode */
Stateless = {};

/**
 * paneel ten behoeve van verschillende stateless popups
 * @type type
 */
Stateless.panel = {};

/**
 *
 * @param {string} id
 * @returns {domObject} Stateless.panel;
 */
Stateless.panel.get = function(id){
    return XDOM.getObject('stateless-panel-' + id);
};

Stateless.panel.focus = function(id){
    var panel = Stateless.panel.get(id),
        query = "input:not([type='hidden']):not([data-hidden='true']):not([type='button']),textarea:not([data-hidden='true'])",
        obj = panel.querySelector(query);
    XDOM.focus(obj);
};




/**
 * toont paneel of renderd deze als deze er niet meer is
 * @param {static.response} res
 * @param {static class} partLogic
 * @returns {void}
 */
Stateless.panel.open = function(response,partLogic ){
    var panel  = Stateless.panel.get(response.calerId),
        calerObj = XDOM.getObject(response.calerId),
        parentObj = XDOM.getObject('stateless-panel-' + response.calerId + '-body');
    panelId = 'stateless-panel-' + response.calerId,
        panelObj = XDOM.getObject(panelId);


    if(panel){
        panel.setAttribute("data-hidden", "false");
    }else{//paneel nog niet eerder gerenderd
        parentObj = Stateless.panel.render(response);
    }

    if(response.type === ENUM.requestType.data){
        Stateless.Page.update(response);
    }else{
        Stateless.Page.new(parentObj,response,partLogic);
    }
    if(calerObj.dataset.screenMode=="*SUBVIEW"){
        return;
    }

    Stateless.panel.alignTo(panelObj,response.calerId);
    //update zIndex
    updatePanelSort(panelObj);

};

Stateless.panel.render = function(res){
    var calerObj = XDOM.getObject(res.calerId);
    if(calerObj.dataset.screenMode=="*SUBVIEW"){
        return Stateless.panel.renderSubview(res, calerObj);
    }

    return Stateless.panel.renderPopup(res);

};



Stateless.panel.renderSubview = function(res,parentObj){
    var panelId = 'stateless-panel-' + res.calerId,
        panelObj = XDOM.createElement('DIV',panelId,'stateless-subview-panel includeBackground'),
        header = XDOM.createElement('DIV', null,"panelHeader theme-background-color"),
        headerTitleIcon = null,
        headerTextDiv = XDOM.createElement('DIV',null,'panelTitle'),
        bodyDiv 	= XDOM.createElement('DIV', 'panel-body-' + res.calerId, "stateless-panel-wrapper" ),
        fieldsetObj = XDOM.getParentByTagName(parentObj, "fieldset"),
        panelIconGroup = fieldsetObj.getAttribute("data-fieldset-icon-group") || "fontAwesome",
        panelIconClass = fieldsetObj.getAttribute("data-fieldset-icon-class") || "";


    parentObj.style.width = "100%";
    parentObj.style.height = "100%";

    panelObj.setAttribute("data-stateless-panel-id",res.calerId);
    bodyDiv.id = panelId + "-body";
    headerTextDiv.setAttribute("data-stateless-panel-title", res.calerId);
    setSubviewNoMargin(fieldsetObj,"*SUBVIEW");

    if(panelIconClass && panelIconClass != ""){
        headerTitleIcon = XDOM.createElement('i',null,'panelHeaderIcon '+ getFontPrefix(panelIconGroup)+panelIconClass);
        header.appendChild(headerTitleIcon);
    }

    parentObj.appendChild(panelObj);
    panelObj.appendChild(header);
    header.appendChild(headerTextDiv);
    headerTextDiv.appendChild(Stateless.panel.getTitle(res));
    panelObj.appendChild(bodyDiv);
    return bodyDiv;
};
/**
 * renderd een popup panel t.b.v stateles onderdelen
 * data is een  json verzamelobject met de volgende properties:
 * id:     id van panel moet unique binnen een macro zijn
 * parent: id van parent object (als niet ingevuld is dit DTADIV)
 * width:  breedte in colommen
 * height: hoogte in regels
 * title: caption voor de titel in de header
 * alignTo: id van object tenopzichte waarvan p[aneel moet worden uitgeleind
 * @param {object} res
 * @returns {panel body dom object}
 */
Stateless.panel.renderPopup = function(res){
    var panelId = 'stateless-panel-' + res.calerId,
        calerObj = XDOM.getObject(res.calerId);
    panelObj = XDOM.createElement('DIV',panelId,'stateless-panel includeBackground'),
        header = XDOM.createElement('DIV', null,"panelHeader theme-background-color"),
        parentObj = XDOM.getObject('DTADIV'),
        headerTextDiv = XDOM.createElement('DIV',null,'panelTitle'),
        closeIcon = XDOM.createElement('DIV',null,'popup-close pth-icon'),
        bodyDiv 	= XDOM.createElement('DIV', 'panel-body-' + res.calerId, "stateless-panel-wrapper" ),// cssclass
        title = '',
        headerTextNode = null,
        width = parseInt(res.data.panelDef.xSize) * SETTINGS.charWidth + 6 + 'px', //6px voor binnekant border
        height = parseInt(res.data.panelDef.ySize) * SETTINGS.lineHeight + 18  + 'px'; //3px voor de bovekant border

    closeIcon.setAttribute("data-click-action","Stateless.panel.closeClick");
    closeIcon.setAttribute("data-stateless-panel-id",res.calerId);
    panelObj.style.width = width;
    panelObj.style.height = height;
    panelObj.setAttribute("data-stateless-panel-id",res.calerId);
    panelObj.setAttribute("data-stateless-panel-modi",XDOM.getAttribute(calerObj, "data-open-options"));
    panelObj.setAttribute("data-update-dom-depth","true");
    panelObj.setAttribute("data-hidden","false");
    updatePanelSort(panelObj);

    bodyDiv.id = panelId + "-body";
    header.setAttribute("data-mouseDown-action", "Dragger.start");
    header.setAttribute("data-dragger-objId", panelId);
    headerTextDiv.setAttribute("data-mouseDown-action", "Dragger.start");
    headerTextDiv.setAttribute("data-dragger-objId", panelId);
    headerTextDiv.setAttribute("data-stateless-panel-title", res.calerId);

    parentObj.appendChild(panelObj);
    panelObj.appendChild(header);
    header.appendChild(headerTextDiv);
    headerTextDiv.appendChild(Stateless.panel.getTitle(res));
    headerTextDiv.appendChild(closeIcon);
    panelObj.appendChild(bodyDiv);
    Stateless.panel.alignTo(panelId,res.calerId);
    return bodyDiv;
};


Stateless.panel.getTitle  = function(res){
    if(res.data.panelDef.titleOrigin==="*VAR"){
        title = res.data.headerData[res.data.panelDef.titleVariable] || '';
    }else{
        title = res.data.captionsDftLang[res.data.panelDef.titleVariable] || '';
    }
    return XDOM.createTextNode(title);
}

/**
 * positioneed paneel
 * @param {type} panelId id van het paneel
 * @param {type} alignToId id ten opzichte waarvan het paneel moet worden uitgelijd
 */
Stateless.panel.alignTo = function(panelId,alignToId){
    if(!panelId || !alignToId){return;}
    var panel = XDOM.getObject(panelId),
        alignToObj = XDOM.getObject(alignToId),
        position = alignTo(panel,alignToObj);
    panel.style.top = position.top + 'px';
    panel.style.left = position.left + 'px';
};

/**
 * past de oorspronkelijke titel van het paneel aan naar de nieuwe
 * @param {type} id
 * @param {type} title text voor in de title balk
 */
Stateless.panel.updateTitle = function(id, title){
    var headerText  = XDOM.query('[data-stateless-panel-title="' + id + '"');
    if(headerText){
        headerText.title = title;
    }
};

Stateless.panel.closeClick = function(){
    var id = XDOM.GLOBAL.getAttribute("data-stateless-panel-id");
    Stateless.panel.close(id);
};

/**
 * sluit paneel
 * @param {type} idIn
 * @returns {boolean} success
 */
Stateless.panel.close = function(idIn){
    Stateless.Page.setScope(); // het panel zit buiten de scope van de page

    var id               = idIn || XDOM.GLOBAL.getAttribute("data-stateless-page-id"),
        page             = Stateless.Page.get(id),
        panelId          = null,
        panelObj         = null,
        panelObjects     = XDOM.queryAll("[data-update-dom-depth='true']:not([data-hidden='true'])"),
        parentObject     = false;
    zIndexValue      = null,

        firstZIndexValue = 0,
        firstZIndexObj   = null,

        secondTopZIndexValue = 0,
        secondTopZIndexObj   = null;

    if(panelObjects){
        if(panelObjects.length <= 0){
            //no panels found
            return false;
        }
    }else{
        //no panels found
        return false;
    }


    for(var i=0,l=panelObjects.length;i<l;i++){

        panelObj = panelObjects[i];
        if(panelObj){


            if(parentObject = XDOM.getParentByAttribute(panelObj, "data-screen-mode")){
                if(parentObject.getAttribute("data-screen-mode") == GUI.BasePanel.screenMode.subview){
                    //return false;
                    continue;
                }
            }

            zIndexValue = panelObj.style.zIndex;

            if(parseInt(zIndexValue) > parseInt(firstZIndexValue)){

                secondTopZIndexValue  = firstZIndexValue;
                secondTopZIndexObj    = firstZIndexObj;

                firstZIndexObj    = panelObj;
                firstZIndexValue  = zIndexValue;

            }else if(zIndexValue > secondTopZIndexValue){
                secondTopZIndexValue  = zIndexValue;
                secondTopZIndexObj    = panelObj;
            }
        }
    }

    if(firstZIndexObj){
        //page.closeHandler();
        firstZIndexObj.setAttribute("data-forced", "true");
        firstZIndexObj.setAttribute("data-hidden", "true");

        if(secondTopZIndexObj){
            updatePanelSort(secondTopZIndexObj);
        }

        return true;
    }

    return false;
};


Stateless.panel.handleKeyDown = function(){
    var page = Stateless.Page.get();
    if(!page){return false;}
    if(GLOBAL.charCode === keyCode.escape || GLOBAL.charCode === keyCode.F12) {
        return Stateless.panel.close(page.id);
    }
    return false;

};



/**
 * event ten behoeve van het verslepen van een panel
 * @param {type} e
 * @param {type} id
 * @returns {undefined}
 */
Stateless.panel.startDragging = function(e, id){
    if(BrowserDetect.isIE || BrowserDetect.isSafari){return;}
    var foEvent = XDOM.getEvent(e);

    if(foEvent.srcElement.id==="MEXIT"){return;}
    var foInstance = Panel.instances[id];
    Dragger.guiObject = foInstance;
    Dragger.domObject = foInstance.domObject;
    GLOBAL.mouseKeyDown = true;
    Dragger.start(e);
};

Stateless.panel.closeAll = function(){
    let closeObjects = XDOM.queryAll('[data-click-action="Stateless.panel.closeClick"]');
    for(let i = 0, l = closeObjects.length;i<l;i++ ){
        XDOM.invokeClick(closeObjects[i]);
    }
    return(closeObjects.length > 0);
};

/* stateless-page */
/* Load Timestamp 13:59:55.647 */
Stateless.Page = function (contentParentId, response, partLogic) {
    this.lastFocusedField = null;
    this.data = response.data;
    this.captionsDftLang = this.data.captionsDftLang;
    this.macroProperties = response.data.macroProperties;
    this.id = response.calerId;
    this.sourceLocation = response.sourceLocation;
    this.resubmitConstants = this.data.resubmitConstants;
    this.macroName = response.macroName;
    this.parentId = contentParentId;
    this.parentPage = SESSION.activePage;
    this.prefix = this.id + '-';
    this.partLogic = partLogic;
    this.acceptHandler = this.partLogic.accept || this.partLogic.submit; //bij geen ok handler submit gebruiken
    this.submitHandler = this.partLogic.submit;
    this.resetHandler = this.partLogic.reset;
    this.enterHandler = this.partLogic.enter;
    this.closeHandler = this.partLogic.close;
    this.type = this.partLogic.pageType;
    this.fixHTML = this.partLogic.fixHTML;
    this.onReturnOkHandler = this.partLogic.onReturnOk;
    this.screenMode = ENUM.screenMode.modal;
    this.createdExcelUrl = '';
    this.additionalValues = {};
    this.inputIsChanged = false;
    this.footerHeight = 0;
    this.toId = '';
    this.loading = false;
    this.subfile = null;
    this.init(response);
};

Stateless.Page.store = {};

/**
 * voegt data aan met het WS_PMT veld
 * als dit van toepassing is.
 * @param {type} data
 * @returns {undefined}
 */

Stateless.Page.prototype.setPromptField = function (data) {
    let obj = SESSION.activePage.lastSelectedInput || GLOBAL.eventSourceElement,
        promptField = '',
        current = getCurrendFocused();

    if (current && current.dataset.statelessPageId == this.id) {
        obj = current;
    }
    promptField = getlastSelectedInputId(obj).replace(this.prefix, '');
    this.lastFocusedField = obj;
    if (obj && obj.dataset.statelessPageId != this.id) {
        promptField = '';
    }
    data.append('WS_PMT', promptField);
};

/**
 * toont of verbergt de protectdiv
 * @param {boolean} show als true dan wordt de protectdiv getoond
 * @returns {void}
 */
Stateless.Page.prototype.toggelProtected = function (show) {
    var protectDiv = XDOM.query(
            ".stateless-protect[data-stateless-page-id='" + this.id + "']"
        ),
        footer = XDOM.query(
            ".stateless-panel-footer[data-stateless-page-id='" + this.id + "']"
        );

    if (!protectDiv || !footer) {
        return;
    }

    setSubviewLoading(protectDiv, show);
    if (show) {
        this.loading = true;
        protectDiv.style.display = 'block';
        footer.setAttribute('data-message-status', 'loading');
    } else {
        protectDiv.style.display = 'none';
        footer.setAttribute('data-message-status', 'default');
        this.loading = false;
    }
};

/**
 * valideerd en submit form data naar de macro van de page
 * @returns {undefined}
 * @param command
 */
Stateless.Page.prototype.submit = function (command) {

    if (this.loading) {
        return;
    }

    const request = new Stateless.request({page: this});

    this.setFormData(request)

    request.data.append('WS_CMD', command);
    this.toggelProtected(true);
    Stateless.setSubviewActive(GLOBAL.eventSourceElement);
    request.post();
    XDOM.cancelEvent();
};


Stateless.Page.prototype.setFormData = function (request) {
    const formObjects = XDOM.queryAll(
        "input[data-stateless-page-id='" +
        this.id +
        "'], textarea[data-stateless-page-id='" +
        this.id +
        "']"
    );
    let formInput = null;
    let name = '';
    let value = '';

    this.setPromptField(request.data);

    for (let name in this.additionalValues) {
        request.data.append(name, this.additionalValues[name]);
    }
    for (let i = 0, l = formObjects.length; i < l; i++) {
        formInput = formObjects[i];
        if (!Validate.test(formInput)) {
            return;
        }
        name = formInput.name.replace(this.prefix, '');
        value = formInput.value
        if (formInput.getAttribute("data-unicode") == "true") {
            value = XDOM.hexEncode(value);
        }
        request.data.append(name, value);
    }
    if (this.subfile) {
        let lastRenderdRecord = this.subfile.sflObject.index;
        let nonRenderdRecords = this.data.subfileData.slice(lastRenderdRecord);
        if (this.data.removedSubfileData) {
            nonRenderdRecords = nonRenderdRecords.concat(
                this.data.removedSubfileData
            );
        }
        this.subfile.sflObject.addAdditionalRecords(
            nonRenderdRecords,
            request.data
        );
    }
}

Stateless.Page.prototype.setStatelesPageId = function () {
    var id = this.id;
    XDOM.forEach('*', function (obj) {
        obj.setAttribute('data-stateless-page-id', id);
    });
};

Stateless.Page.prototype.setAdditionValue = function (name, value) {
    this.additionalValues[name] = value;
};

Stateless.Page.prototype.setHtml = function (htmlIn) {
    const body = XDOM.getObject(this.parentId);
    let html = htmlIn.replaceAll('#PanelPfx-', this.prefix);
    html = html.replaceAll('#PanelPfx', this.prefix);
    body.innerHTML = html;
};

/**
 * Args kan de volgende members hebben
 id: unique id van de pagina definitie, (verplicht)
 html: html content,
 data: alle data die nodig is (verplicht)
 }

 als de pagina eerder aangeroepen is wordt deze uit de Stateless.Page.store worden gehaald,
 en wordt er een update gedaan op basis van de nieuwe data
 in andere gevallen wordt de html content in de pagina gezet en wordt deze eerst behandeld
 door prepare html en prepare dom
 * @param {type} id  default id heeft de waarde van het global event object attribute data-stateless-page-id
 * @returns {pageObject}
 */

Stateless.Page.get = function (id) {
    var pageId =
        id ||
        XDOM.GLOBAL.getAttribute('data-stateless-page-id') ||
        XDOM.getParentAttribute(
            GLOBAL.eventSourceElement,
            'data-stateless-page-id'
        );
    return Stateless.Page.store[pageId];
};

/**
 * zet de scope naar die van de stateless page en weer terug
 */
Stateless.Page.onFocus = function () {
    var page = Stateless.Page.get();
    Stateless.Page.setScope(page);
};

Stateless.Page.command = function (command) {
    return Stateless.Page.submit(command);
};

/**
 * set subscope en activeData id kan leeg, een string of een domobject zijn
 * als leeg dan wordt de subScope en activedata hersteld naar algemene niet static waarden
 * @param {type} id
 * @returns {undefined}
 */
Stateless.Page.set = function (id) {
    Stateless.Page.setScope();
    var pageId = id,
        page = null;
    if (!id) {
        return;
    }
    if (id.getAttribute) {
        pageId = id.getAttribute('data-stateless-page-id');
    }
    if (!pageId) {
        return;
    }
    page = Stateless.Page.get(pageId);
    if (!page) {
        return;
    }
    Stateless.Page.setScope(page);
};

/**
 * maken nieuwe pagina
 * @param {type} id
 * @param {type} res
 * @param {type} partLogic overkoepelend static clas met logica waarvan page onderdeel uit maakt
 * @returns {Stateless.Page|Stateless.Page.new.page}
 */
Stateless.Page.new = function (id, response, partLogic) {
    var page = new Stateless.Page(id, response, partLogic);
    page.update(response);
    return page;
};

Stateless.Page.update = function (response) {
    var id = response.calerId,
        page = Stateless.Page.store[id];
    if (page) {
        page.update(response);
    }
};

Stateless.Page.prototype.prepareQuickSearch = function () {
    QuickSearch.prepareDom();
};

Stateless.Page.prototype.prepareParamObjects = function () {
    var objects = SESSION.subScope.querySelectorAll('[data-parm-object]'),
        obj = null,
        requestObj = null;
    for (var i = 0, l = objects.length; i < l; i++) {
        obj = objects[i];
        requestObj = JSON.stringify(obj.dataset.paramObject);

        //this.prefix
    }
};

Stateless.Page.prototype.prepareLoader = function () {
    var body = XDOM.getObject(this.parentId),
        loader = XDOM.createElement('DIV', null, 'stateless-loader'),
        blocker = XDOM.createElement('DIV', null, 'stateless-protect');

    blocker.setAttribute('data-stateless-page-id', this.id);
    body.appendChild(blocker);
    blocker.appendChild(loader);
};

Stateless.Page.prototype.setLabels = function () {
    var captions = this.data.captionsDftLang,
        lables = SESSION.subScope.getElementsByTagName('label');
    for (var i = 0, l = lables.length; i < l; i++) {
        lables[i].innerHTML =
            captions[lables[i].id.replace(this.prefix, '')] || ' ';
    }
    return;
};

/**
 * zorgt dat alle onderdelen met een field progrorgession op de juiste manier worden gezet
 * @returns {undefined}
 */
Stateless.Page.prototype.setFieldProgression = function () {
    if (!SESSION.subScope.dataset.fieldprogressionIndex) {
        fp.setIndex(SESSION.subScope);
    }
    Subfile.setHeaderBodyRef(this.prefix);
};

/**
 * na een response van de pagina wordt de onReturnOkHandler aangeroepen als de
 * returncode WS_RTN de waarde "OK" heeft
 * @returns {Stateless.Page.partLogic.onReturnOk}
 */
Stateless.Page.prototype.handleReturnCode = function () {
    //na submit altijd een multiselect sluiten. Wanneer een Multiselect ook een returncode teruggeeft kan weer worden verwijderd.
    //if(this.type == "MultiSelect"){
    // Stateless.panel.close(this.id);
    //}
    if (this.data.headerData.WS_RTN === 'OK') {
        if (this.onReturnOkHandler) {
            return this.onReturnOkHandler();
        }
    }
};

/**
 *
 * als deze pagina behoord tot het type
 */
Stateless.Page.prototype.appendset = function (response) {
    if (this.subfile) {
        Stateless.Page.setScope(this);

        if (this.subfile.append(response.data)) {
            this.toggelProtected(false);
            Stateless.Page.setScope();
            return true;
        }
        Stateless.Page.setScope();
    }

    return false;
};

/**
 * let op deze functie wordt toegewezen aan het request object waardo0r this naar de instantie
 * van het request object zelf verwijst
 * deze functie is niet static gemaakt maar als instantie alleen maar om het door te kunnen geven naar het request object
 * @param {type} response
 * @returns {undefined}
 */
Stateless.Page.prototype.onResponse = function (response) {
    if (this.page.appendset(response)) {
        return;
    }
    this.page.data = response.data;
    this.page.inputIsChanged = false;
    if (this.page.handleReturnCode()) {
        return;
    }
    if (response.html) {
        this.page.setHtml(response.html);
        this.page.subfile = new Stateless.subfile(this.page);
        this.page.prepareDom();
    }
    this.page.update(response);
};

/**
 * beperkt de globale scoop naar een Stateless.page of
 * als page = null weer naar de onderliggende statefull pagina
 * @param {Stateless.Page} page
 * @returns {void}
 */
Stateless.Page.setScope = function (page) {
    if (page) {
        SESSION.subScope = XDOM.getObject(page.parentId);
        SESSION.activeData = page.data;
    } else if (SESSION.activePage) {
        SESSION.subScope = null;
        SESSION.activeData = SESSION.activePage.data;
    }
};

Stateless.Page.prototype.init = function (response) {
    var callerObject = XDOM.getObject(this.id);
    this.screenMode = callerObject.dataset.screenMode;
    this.registerTrigger(callerObject);
    this.toId = callerObject.dataset.toId;
    this.setHtml(response.html);
    this.subfile = new Stateless.subfile(this);

    Stateless.Page.store[this.id] = this;
    this.prepareDom();
};

Stateless.Page.prototype.prepareDom = function () {
    Stateless.Page.setScope(this);
    this.prepareLoader();
    this.prepareParamObjects();
    this.setStatelesPageId();
    this.setLabels();
    Mask.prepareDom();
    oculusImage.prepareDom();
    Upload.prepareDom();
    Barcode.prepareDom();
    GUI.Signature.prepareDom();
    MultiSelect.prepareDom();
    this.subfile.prepare();
    SortButton.prepareDom();
    NAV.sessionLauncher.prepareDom();
    icons.prepareDom(SESSION.subScope);
    FieldAttribute.prepareDom();
    GUI.infoTitle.prepareDom();
    //Help.prepareDom();
    this.prepareQuickSearch();
    TopView.prepareDom();
    //Command.prepareDom();
    Batch.prepareDom();
    this.setFieldProgression();
    setHelpText();
    this.setExport();
    Stateless.Page.setScope();
};


/**
 * checks for hidden and disabled
 */
Stateless.Page.prototype.updateExport = function () {
    //search in the parent of the subscope for the icon
    const icon = SESSION.subScope.parentElement.querySelector('.fa-file-excel-o.header-button.right');
    //do we have export?
    if (!icon) return;

    //get the indicator fields out
    const {excelButtonHiddenIndicator = '', excelButtonAvailableIndicator = ''} = this.macroProperties;

    //set the indicators
    const hidden = (this.data.headerData[excelButtonHiddenIndicator] == '1')
    const disabled = (this.data.headerData[excelButtonAvailableIndicator] == '0') ;

    //update the state
    icon.setAttribute('data-button-state', disabled ? 'disabled' : '');
    icon.setAttribute('data-hidden', hidden);
}
/**
 * show excel button in header if this is defined
 */
Stateless.Page.prototype.setExport = function () {
    //check do we need an excel button?
    if (!this.macroProperties.excelButton) {
        return;
    }

    //check if this button allready exists:
    if(SESSION.subScope.parentElement.querySelector(".panelHeader > .fa-file-excel-o")){
        //see if button actualy allready exists, if so do nothing
        return;
    }

    //create Icon
    const icon = XDOM.createElement('I', null, "fa fa-file-excel-o header-button right");
    icon.title = getCapt('cCRTXLS_TTL');
    icon.setAttribute("data-stateless-page-id", this.id)
    // get the header
    const header = SESSION.subScope.parentElement.querySelector(".panelHeader");



    if (!header) { //no header so quit
        return;
    }

    // add the page-id so at on click we know what page this belongs to.
    // icon.setAttribute('data-stateless-page-id', this.id);

    header.appendChild(icon)

    //add handler
    icon.addEventListener('click', e => {
        //needs to be done to get to the right page
        XDOM.getEvent(e);
        if (XDOM.GLOBAL.getAttribute('data-button-state') === 'disabled') {
            return;
        }
        //submit for excel export
        Stateless.Page.command("CRTXLS");
    })

}
Stateless.Page.prototype.setValues = function () {
    var obj = null;
    var data = this.data.headerData;
    for (var fieldName in data) {
        obj = XDOM.getObject(this.prefix + fieldName);

        if (obj && obj.tagName !== 'LABEL') {
            XDOM.setObjectValue(obj, data[fieldName]);
            setOldValue(obj);
        }
    }

    var outputs = XDOM.queryAll('[data-value-from-id]:not([data-axis])');
    for (var i = 0, l = outputs.length; i < l; i++) {
        obj = outputs[i];
        XDOM.setObjectValue(obj, data[obj.getAttribute('data-value-from-id')]);
    }

    var clearInputs = XDOM.queryAll("[data-clear-after-submit='true']");
    for (var i = 0, l = clearInputs.length; i < l; i++) {
        obj = clearInputs[i];
        XDOM.setObjectValue(obj, '');
        obj.setAttribute('data-old-value', '');
    }
};

Stateless.Page.prototype.resetMessage = function () {
    var commandBar = XDOM.query('.stateless-panel-message'),
        msgP = XDOM.query('.stateless-panel-message p');
    if (!commandBar) {
        return;
    }
    commandBar.setAttribute('data-message-status', '');
    msgP.innerHTML = '';
};

Stateless.Page.prototype.setMessage = function (message, level) {
    var commandBar = XDOM.query('.stateless-panel-message');
    if (!commandBar) {
        return;
    }
    if (message == '' && level == '') {
        this.resetMessage();
        return;
    }
    var msgP = XDOM.query('.stateless-panel-message p'),
        messageLevel = level || this.data.viewProperties.messageLevel,
        messageText =
            message ||
            this.data.headerData.WS_ERR ||
            this.data.viewProperties.messageText ||
            '',
        messageObject = ERRORMESSAGES[messageText];

    if (messageText && messageObject) {
        messageText = messageObject.caption;
        messageLevel = messageObject.messageLevel;
    }
    messageLevel =
        ENUM.attentionLevelToMessageStatus[messageLevel] || messageLevel;
    commandBar.setAttribute('data-message-status', messageLevel);
    msgP.innerHTML = messageText;
};

Stateless.Page.prototype.setTitle = function () {
    if (!this.data.viewProperties) {
        return;
    }
    var titleText =
        getCapt('cTX_SSN') +
        ': ' +
        this.data.viewProperties.jobNbr +
        ' \x0A' +
        getCapt('cTX_PGM') +
        ': ' +
        this.macroName;
    Stateless.panel.updateTitle(this.id, titleText);
};
Stateless.Page.prototype.updateData = function (response) {
    //set the data
    this.data = response.data;

    //because sometimes captions are included in the data set but the might not be we save an old set off captions to reuse
    //check if we have new captions
    if(this.data.captionsDftLang){
        //we have new captions asign them
        this.captionsDftLang = this.data.captionsDftLang;
    }else{
        //we have no new captions so assign the old captions to the data set
        this.data.captionsDftLang = this.captionsDftLang
    }

    this.createdExcelUrl = this.data.viewProperties.createdExcelUrl;
}
Stateless.Page.prototype.update = function (response) {
    this.inputIsChanged = false;
    this.updateData(response);
    this.invoke = response.invoke;
    Stateless.Page.setScope(this);
    this.setMessage();
    this.setValues();
    When.update();
    GUI.InfoWindow.updateDom();
    GUI.EditWindow.updateDom();
    Service.update();
    Upload.update();
    Barcode.update();
    INP.updateDom();
    SortButton.update(this.prefix);

    MaxScale.update();
    FieldColors.update();
    this.subfile.update(this.data);
    formatThousandAll();
    DataAttribute.update();
    AttentionLevel.update();
    ConditionalAttribute.update();
    FieldAuthorization.update();
    GUI.infoTitle.update();
    GUI.Signature.update();
    updateDoubleSearchIcons(); //na when snelzoek en ConditionalAttribute

    icons.updateDom(this.headerData, SESSION.subScope)
    MultiSelect.update(this);
    registerEvents();
    this.updateExport();
    this.toggelProtected(false);
    this.setFocus();
    // Link.update needs to go last.
    // The invocation of the click event will set the sub-scope to null
    // (returning it to the outer main page)
    Link.update(this.createdExcelUrl);
    Stateless.Page.setScope();
    this.setTitle(); //title valt buiten de scope van de pagina in zijn container
};

Stateless.Page.prototype.focusFirstField = function () {
    //zoek het eerste de beste te focusen element
    focusField = SESSION.subScope.querySelector(
        "input:not([data-hidden='true']), textarea:not([data-hidden='true']), a:not([data-hidden='true'])"
    );
    if (focusField) {
        focusField.focus();
        return;
    }
    //er is nog steeds geen veld gevonden maak een veld aan om op te focusen
    focusField = XDOM.createElement('input');
    focusField.style.display = 'none';
    SESSION.subScope.appendChild(focusField);
    focusField.focus();
};

Stateless.Page.prototype.setFocus = function () {
    let field = this.data.headerData.WS_CSR || this.lastFocusedField;
    SESSION.activePage.cursorFocus = this.prefix + field;
    setCursor(this.id);
    return;
};

Stateless.Page.prototype.renderFooter = function () {
    var footer = XDOM.createElement(
            'DIV',
            this.prefix + 'footer',
            'stateless-panel-footer'
        ),
        messageDiv = XDOM.createElement('DIV', null, 'stateless-panel-message'),
        messagePlaceholder = XDOM.createElement('P'),
        saveButton = XDOM.createElement(
            'DIV',
            null,
            'stateless-accept-icon pth-icon'
        ),
        panelFooterButtonsPlaceHolder = XDOM.createElement(
            'DIV',
            null,
            'stateless-panel-buttons'
        ),
        refreshButton = XDOM.createElement(
            'DIV',
            null,
            'stateless-reset-icon pth-icon'
        );

    footer.appendChild(messageDiv);
    footer.appendChild(panelFooterButtonsPlaceHolder);
    messageDiv.appendChild(messagePlaceholder);
    panelFooterButtonsPlaceHolder.appendChild(saveButton);
    panelFooterButtonsPlaceHolder.appendChild(refreshButton);

    saveButton.setAttribute('data-stateless-page-id', this.id);
    saveButton.setAttribute('data-click-action', 'Stateless.Page.accept');
    refreshButton.setAttribute('data-stateless-page-id', this.id);
    refreshButton.setAttribute('data-click-action', 'Stateless.Page.reset');
    SESSION.subScope.appendChild(footer);
    this.footerHeight = footer.offsetHeight;
};
/**
 * opnieuw laden van pagina
 * als er een subfile in zit dan moeten alle regels van die subfile ook bij worden geladen
 * @pageId {string}
 */
Stateless.Page.reload = function (pageId) {
    let page = Stateless.Page.get(pageId);
    if (!page) {
        return false;
    }
    if (page.subfile) {
        page.subfile.setForReload();
    }
    page.submit('RELOAD');
    return true;
};

Stateless.Page.submit = function (command) {
    var page = Stateless.Page.get();
    if (!page) {
        return false;
    }
    page.submit(command);
    return true;
};

Stateless.Page.enter = function () {
    var page = Stateless.Page.get();
    if (page.enterHandler) {
        page.enterHandler();
        return;
    } //geen ok handler doe een submit
    if (page.submit) {
        page.submit('ENTER');
    }
};

Stateless.Page.accept = function () {
    var page = Stateless.Page.get();
    if (page.acceptHandler) {
        page.acceptHandler();
        return;
    } //geen ok handler doe een submit
    if (page.eventHandler.submit) {
        page.eventHandler.submit(page);
    }
};

Stateless.Page.reset = function () {
    var page = Stateless.Page.get();
    if (page.resetHandler) {
        page.resetHandler(page);
    }
};

/**
 *
 * @param {String} value
 * @returns {String}
 */
Stateless.Page.getCaption = function (value) {
    var result = null;
    if (SESSION.activeData.captionsUserLang) {
        result = SESSION.activeData.captionsUserLang[value];
    }
    if (!result && SESSION.activeData.captionsDftLang) {
        result = SESSION.activeData.captionsDftLang[value];
    }

    return result;
};

Stateless.Page.handleKeyDown = function () {
    var page = Stateless.Page.get();
    if (!page) {
        return false;
    }
    if (
        GLOBAL.charCode === keyCode.enter &&
        !XDOM.GLOBAL.getBooleanAttribute('data-block-autosubmit')
    ) {
        page.acceptHandler();
        return true;
    }
    return false;
};

/**
 * controleerd of de stateles pagina bij het
 * @returns {Boolean}
 */
Stateless.Page.isLoading = function () {
    var page = Stateless.Page.get();
    if (page && page.loading) {
        XDOM.cancelEvent();
        return true;
    }
    return false;
};

Stateless.Page.inputOnChange = function (obj) {
    var pageId = obj.getAttribute('data-stateless-page-id'),
        page = Stateless.Page.get(pageId);
    if (!page) {
        return false;
    }
    Stateless.Page.setScope(page);
    //verandering in de selectie van de multiselect tellen niet mee voor het
    //zetten van de onchange flag
    if (MultiSelect.onChange(page)) {
        return true;
    }
    page.resetMessage();
    Stateless.Page.setScope();
    page.inputIsChanged = true;
    if (
        isAutoSubmitField(obj) &&
        !XDOM.getBooleanAttribute(obj, 'data-block-autosubmit')
    ) {
        page.submit('ENTER');
    }
    return true;
};

Stateless.Page.updateByTrigger = function (id) {
    QueryList.open(XDOM.getObject(id));
};

Stateless.Page.prototype.registerTrigger = function (icon) {
    const triggerFields = icon.dataset.triggerFields
            ? icon.dataset.triggerFields.split(' ')
            : [],
        triggerMacros = icon.dataset.triggerMacros
            ? icon.dataset.triggerMacros.split(' ')
            : [],
        id = this.id;

    for (let i = 0, l = triggerFields.length; i < l; i++) {
        const desc = `Stateless page: ${this.macroName} is triggered by field change `;
        Trigger.register(
            triggerFields[i],
            id,
            'Stateless.Page.updateByTrigger' + id,
            function () {
                Stateless.Page.updateByTrigger(id);
            },
            desc
        );
    }
    for (let i = 0, l = triggerMacros.length; i < l; i++) {
        const desc = `Stateless page: ${this.macroName} is triggered by macro: `;
        Trigger.register(
            triggerMacros[i],
            id,
            'Stateless.Page.reload' + id,
            function () {
                Stateless.Page.reload(id);
            },
            desc
        );
    }
};

//registreerd welke subfiew er focus heeft
Stateless.setSubviewActive = function (id) {
    const obj = XDOM.getObject(id),
        fieldset = XDOM.getParentByTagName(obj, 'FIELDSET');
    //zet alle subview fieldsets met data-has-focus="true" op "false"
    Stateless.deactivateAllSubViews();
    if (fieldset) {
        fieldset.dataset.hasFocus = true;
    }
};


Stateless.deactivateAllSubViews = function () {
    XDOM.setAttributesToNodeList(
        '[data-has-focus="true"]',
        'data-has-focus',
        false
    );
}

/**
 * zet op basis van een click event de subview actief die ook de focus kan hebben
 * dit kan alleen als de subview een element heeft waar de focus op kan staan
 * komt de klick niet vanuit een subview of is de klick op een subview gegeven waar geen te focuses elementen in staan dan wordt de klick genegeerd
 * dit om te voorkomen dat een klick op een submit button of iets degelijks de focus van de input doet verliezen
 */
Stateless.setSubviewActiveOnClick = function () {
    const fieldset = XDOM.getParentByTagName(
            GLOBAL.eventSourceElement,
            'FIELDSET'
        ),
        query =
            "input:not([type='hidden']):not([data-hidden='true']):not([data-protected='true']), " +
            "textarea:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])";
    if (fieldset && fieldset.querySelector(query)) {
        //er is een fieldset en deze heeft een element dat de focus kan hebben
        XDOM.setAttributesToNodeList(
            '[data-has-focus="true"]',
            'data-has-focus',
            false
        );
        fieldset.dataset.hasFocus = true;
    }
};
/**
 * geeft aan of veld al dan niet behoord tot een stateles deel van het scherm
 * dit zijn:
 * edit window velden
 * snelzoek veld
 * @returns {boolean}
 */
Stateless.isStatelessField = function (obj) {
    if (!obj || !obj.dataset) {
        return false;
    }
    if (obj.dataset.panelId) {
        return true;
    } //edit window
    if (obj.dataset.quicksearchSelectfield) {
        return true;
    } //snelzoek window
    if (obj.dataset.statelessPageId) {
        return true;
    } //stateles window
    return false;
};

/**
 * geeft aan of er focus gezet mag worden op het veld
 * gebaseerd op active subview en of het veld
 * al dan niet stateless is
 * @param obj het te focusen veld
 * @returns {boolean}
 */
Stateless.canHaveFocus = function (id) {
    const obj = XDOM.getObject(id),
        fieldset = XDOM.getParentByTagName(obj, 'FIELDSET'),
        isStateless = Stateless.isStatelessField(obj),
        activeSubview = XDOM.query('fieldset[data-has-focus="true"]');

    if (fieldset && fieldset == activeSubview) {
        // dit veld behoort tot de actieve subview
        return true;
    }

    if (!activeSubview) {
        //er is geen subview actief altijd toestaan
        return true;
    }

    if (!fieldset && isStateless) {
        //dit veld is een stateles veld dat niet in een subview zit altijd de focus geven
        return true;
    }

    if (fieldset && obj) {
        // dit veld behoort tot een subview maar niet de actieve
        return true;
    }

    if (!obj) {
        return false;
    }

    // veld is statefull en er is een subview actief
    // dus geen focus zetten
    return false;
};

/**
 * geeft aan of er een subview active is
 * @returns {boolean}
 */
Stateless.setTryFirstSubview = function () {
    const activeSubview = XDOM.query('fieldset[data-has-focus="true"]'),
        allSubviews = XDOM.queryAll('fieldset');
    if (allSubviews.length > 0 && !activeSubview && !allSubviewsLoaded()) {
        GLOBAL.focusFirstSubView = true;
    } else {
        GLOBAL.focusFirstSubView = false;
    }
};

Stateless.translateField = function (field, prefix) {
    return prefix + field;
};

Stateless.translateParamObject = function (paramObj, prefix) {
    let parmObject = paramObj;
    if (typeof parmObject !== 'object') {
        parmObject = JSON.parse(paramObj);
    }

    for (let i = 0, l = parmObject.length; i < l; i++) {
        let item = parmObject[i];
        item.field = Stateless.translateField(item.field, prefix);
    }

    return JSON.stringify(parmObject);
};

/* stateless-request */
/* Load Timestamp 13:59:55.648 */
/**
 * request object t.b.v. stateles requests
 * bouwt een request op op basis van het caler object
 *
 * @param {type} args argumentenin json format met de volgende waarde:
 *   callerObject : domObject uit het aanroepende scherm met bijbehorende info over dir request
 *   type : waarde uit ENUM.requestType dit bepaald of er data, html of allebij terug wordt geschreven
 *   onResponse: pointer naar javascript on response handler
 *
 * @returns {Stateless.request}
 */
Stateless.request = function (args) {
    this.type = '';
    this.onResponse = null;
    this.requestFieldsArray = null;
    this.recordNumber = null;
    this.sourceLocation = null;
    this.macroName = null;
    this.environmentConditions = null;
    this.calerId = '';
    this.requestCount = Stateless.request.requestCount++;
    this.page =null;
    this.uri = '';
    this.init(args);
};
Stateless.request.count = 0;

/**
 * initalisatie vanuit een caler Object in combinatie met een al bestaande page Object
 * vaak is dit een icoon in de aanroepende pagina
 * @param {HTMLElement} obj  B.V. icoon
 * @param {StateLess.Page} page pagina Object
 * @returns {void}
 */
Stateless.request.prototype.initExternal = function (obj, page) {
    this.initFromObject(obj);
};

Stateless.request.prototype.setType = function (type) {
    //do we need a panel definition
    //check if the definitions is allready there.
    const needsDefinition = !this.page?.data?.panelDef;

    // If we need a panel definition.
    // Or, when in debug mode we always need to have the definition and data
    if(needsDefinition || SESSION.session.debugMode){
        this.type = ENUM.requestType.all;
    }else{
        //We only need data
        this.type = ENUM.requestType.data;
    }


    this.data['CONFIG'] = this.type;
};
/**
 * initalisatie vanuit een caler Object vaak is dit een icoon in de aanroepende pagina
 * dit wordt gebruikt bij het openen van een Stateles page vanuit het aanroepende scherm
 * @param {HTMLElement} obj B.V. icoon
 * @returns {void}
 */
Stateless.request.prototype.initFromObject = function (obj) {
    const guiPage = XDOM.getEditWindow(obj);
    if (guiPage) {
        this.guidData = guiPage.data;
    }
    this.environmentConditions = obj.dataset.environmentConditions;
    this.requestPrefix = obj.getAttribute('data-parm-prefix') || '';
    this.recordNumber = obj.getAttribute('data-record-number');
    this.sourceLocation = obj.getAttribute('data-macro-location');
    this.macroName = obj.getAttribute('data-macro-name');
    this.calerId = obj.id;
    this.invoke = this?.page?.parentPage?.resubmit ? "*RELOAD": "*EXTERNAL";
    this.setType();

};

/**
 * static teler deze wordt gebruikt om response te matchen met de juiste call te matchen
 */
Stateless.request.requestCount = 0;

/**
 * initalisatie vanuit een al bestaande page Object
 * dit wordt gebruikt bij het submitten van een Stateless.Page object
 * @param {StateLess.Page} page pagina Object
 * @returns {void}
 */
Stateless.request.prototype.initFromPage = function (page) {
    this.invoke = '*INTERNAL';
    this.setType()
    this.environmentConditions = page.environmentConditions;
    this.sourceLocation = page.sourceLocation;
    this.macroName = page.macroName;
    this.calerId = page.id;
    this.onResponse = page.onResponse;
    SESSION.submitFromScope = page.id;
};

/**
 * basis initialisatie
 * @param {type} args javascript object in json format mogelijke members zijn:
 * callerObject en of page hierbij is
 * callerObject een domObject B.V.  een icoon uit de aanroepende pagina
 * page is een al eerder geinstatieerd StateLess.Page Object
 * @returns {undefined}
 */
Stateless.request.prototype.init = function (args) {
    this.data = new Stateless.FormData();
    this.page = args.page;
    if (args.callerObject && args.page) {
        this.initExternal(args.callerObject, args.page);
        this.onResponse = args.onResponse;
        this.prepare();
        return;
    }

    if (args.callerObject) {
        this.initFromObject(args.callerObject);
        this.type = args.type;
        this.onResponse = args.onResponse;
    }
    if (args.page) {
        this.initFromPage(args.page);
    }
    this.prepare();
};

/**
 * factory functie die Stateless.request initialiseerd
 * en vervolgens een get request uitvoert
 * @param {type} args
 * @returns {Promise<void>}
 */
Stateless.request.get = function (args) {
    const request = new Stateless.request(args);
    return request.get();
};


Stateless.request.prototype.setRequestFieldsArray = function (obj) {
    this.requestFieldsArray = [];
    const requestObject = obj?obj:XDOM.getObject(this.calerId);//this.page.id
    if(!requestObject) return this.requestFieldsArray;
    const json =  requestObject.getAttribute('data-parm-object').replace(/'/g, '"')
    if(!json) return this.requestFieldsArray;
    this.requestFieldsArray =  JSON.parse(json);
    return this.requestFieldsArray;
}

/**
 * hulpfunctie die op basis van het caler argument een aanroep doet
 * via het caler object worden aanroepende velden etc doorgegeven
 * @returns {String}
 */
Stateless.request.prototype.getParamFromCaler = function () {
    let fieldObj = null,
        value = '',
        location = null,
        constValue = null,
        recordNr = 0,
        fieldObjName = '',
        headerData = this.guidData || this.page?.parentPage?.data?.headerData || SESSION.activeData.headerData,
        subfileData = SESSION.activeData.subfileData;

    const requestFieldsArray = this.setRequestFieldsArray();

    this.data.append('PRMLEN', requestFieldsArray?.length ||'0');



    if (this.recordNumber) {
        recordNr = parseInt(this.recordNumber) - 1;
    }
    for (var i = 0; i < requestFieldsArray.length; i++) {
        fieldObjName = this.requestPrefix + requestFieldsArray[i].field;
        location = requestFieldsArray[i].location;
        fieldObj = XDOM.getObject(fieldObjName,SCOPE.pageDoc);
        value = '';
        if (!fieldObj || (fieldObj && fieldObj.tagName !== 'INPUT')) {
            switch (location) {
                case 'headerData':
                    value = headerData[requestFieldsArray[i].field];
                    break;
                case 'subfileData':
                    if (recordNr >= 0) {
                        fieldObj = XDOM.getObject(fieldObjName + '_' + this.recordNumber,SCOPE.pageDoc);
                        if (!fieldObj || (fieldObj && fieldObj.tagName !== 'INPUT')) {
                            value = subfileData[recordNr][requestFieldsArray[i].field];
                        }
                    }
                    break;
                default:
                    if (!fieldObj) {
                        break;
                    }
                    constValue = fieldObj.getAttribute('data-const-value');
                    if (constValue) {
                        value = constValue;
                    }
                    break;
            }
        }

        if (!fieldObj) {
            fieldObj = XDOM.getObject('trigger_' + fieldObjName, SCOPE.pageDoc);
        }

        if (fieldObj) {
            if (Validate.test(fieldObj)) {
                value = XDOM.getObjectValue(fieldObj);
            } else {
                return 'invalid';
            }
        }
        if(!value){
            value= "";
        }
        this.data.append('PRM' + (i + 1), value);
    }
};

/**
 * parameters die altijd bij elke request nodig zijn
 * worden toegevoegd aan het custom Stateless.formData object
 * deze waarden worden gebruikt bij het submitten van een stateless pagina (al dan niet via een get of post)
 * @returns {undefined}
 */
Stateless.request.prototype.setDefaultDataValues = function () {
    var resubmitConstants = {};
    var resubmitVariables = {};
    if (this.page) {
        resubmitConstants = this.page.resubmitConstants || {};
        resubmitVariables = this.page.data.resubmitVariables || {};
    }
    this.appendOnce('PFMSOMTD', PFMBOX.PFMSOMTD);
    this.appendOnce('PFMFILID', PFMBOX.sPFMFILID);
    this.appendOnce('USRID', PFMBOX.PFMRMTUS);
    this.appendOnce('AUTHTOKEN', SESSION.AUTHTOKEN);
    this.appendOnce('CONFIG', this.type);
    this.appendOnce('INVOKE', this.invoke);
    this.appendOnce('requestCount', Stateless.request.count++);

    if (this.environmentConditions) {
        this.data.append('EnvConditions', this.environmentConditions);
    }

    if (this.invoke === '*EXTERNAL') {
        this.getParamFromCaler();
    }
    for (var field in resubmitConstants) {
        this.data.append(field, resubmitConstants[field]);
    }
    for (var field in resubmitVariables) {
        this.data.append(field, resubmitVariables[field]);
    }
};

/**
 * appends field if it is  not already  defined  in the url
 * @param name
 * @param value
 */
Stateless.request.prototype.appendOnce = function (name, value) {
    //does uri includes the field?
    if (this.uri.includes(`?${name}=`) || this.uri.includes(`&${name}=`)) {
        return;
    }
    this.data.append(name, value);
}


/**
 * voorberijden dit object voor het maken van een van een XMLHttpRequest
 * de basis url en basis waarden worden ingesteld en de eventlistners geregistreerd
 * @returns {void}
 */
Stateless.request.prototype.prepare = function () {
    this.XMLHttpRequest = new XMLHttpRequest();
    this.uri = '/ndscgi/' + this.sourceLocation + '/ndmctl/' + this.macroName + '.ndm/MAIN';
    this.uri += `?PFMSOMTD=${PFMBOX.PFMSOMTD}`;
    this.uri += `&PFMFILID=${PFMBOX.sPFMFILID}`;
    this.uri += `&USRID=${PFMBOX.PFMRMTUS}`;
    this.uri += `&AUTHTOKEN=${SESSION.AUTHTOKEN}`;

    this.XMLHttpRequest.addEventListener('load', Stateless.request.responseHandler);
    this.XMLHttpRequest.requestObject = this;

    this.setDefaultDataValues();
};

/**
 * maakt een post en wordt gebruikt vanuit Stateless.Page
 * op dit moment wordt post op de server nog niet ondersteund
 * inplaats daarvan wordt get aangeroepen
 * @returns {void}
 */
Stateless.request.prototype.post = function () {
    this.getParamFromCaler();
    if (!minVersion('*8A')) {
        this.get();
        return;
    }
    this.XMLHttpRequest.open("post", this.uri, true);
    this.XMLHttpRequest.send(this.data.formData);
};

/**
 * maakt een get request
 * @returns {void}
 */

Stateless.request.prototype.get = async function () {
    if(this.page && this.invoke == "*RELOAD"){
        this.getParamFromCaler();
        this.page.setFormData(this)
    }
    this.uri += '&' + this.data.queryString();

    if (this.page && this.uri.length > 7000) {
        this.page.toggelProtected(false);
        this.page.setMessage('veel te lang ', 'error');
        return;
    }


    const text =  await fetch(this.uri).then(response => response.text());
    return this.fetchResponseHandler(text);

};

/**
 * Afhandeling van de response en roept de functiepointer
 * onResponse aan
 * @param {native response} response
 * @returns {Promise<void>}
 */
Stateless.request.prototype.fetchResponseHandler = function (response) {
    //resolve the response
    const result = AJAX.resolveResponse(response);
    //get macro properties
    const macroProperties = result.data.macroProperties;

    //create callback function bind to this so when it is called this wil still be an instance of Stateless.request
    const callBack = function () {
        this.onResponse(this);
    }.bind(this);


    //set the data
    this.data = result.data;
    if (result.pageDef) {
        this.html = result.pageDef;

        if (macroProperties.viewDataUri) {
            //this wil return a promise when the scriptag onload and the callback was fired
            return AJAX.Page.loadScriptTagPromised(macroProperties.viewDataUri, callBack);
        }
    }
    //no page def just call the callBack
    callBack()

    //resolve the promise
    return Promise.resolve();
};

/**
 * Afhandeling van de response en roept de functiepointer
 * onResponse aan
 * @param {native response} response
 * @returns {void}
 */
Stateless.request.responseHandler = function (response) {
    var result = AJAX.resolveResponse(response),
        macroProperties = result.data.macroProperties,
        statelessCaller = this,
        callBack = function () {
            statelessCaller.requestObject.onResponse(statelessCaller.requestObject);
        };
    this.requestObject.data = result.data;
    if (result.pageDef) {
        this.html = result.pageDef;

        if (macroProperties.viewDataUri) {
            AJAX.Page.loadScriptTag(macroProperties.viewDataUri, callBack);
            return;
        }
    }
    callBack();
    //this.requestObject.onResponse(this.requestObject);
};

/* stateless-formData */
/* Load Timestamp 13:59:55.648 */

/* global Stateless */
/**
 * wrapper om formdate te verzamelen maar om ook nog als get te kunnen versturen
 * het native formdata is helaas niet uit te vragen vandaar de dubbele boekhouding
 * @returns {Stateless.FormData}
 */
Stateless.FormData = function(){
    this.data = {};
    this.formData= new FormData();
    this.recordCount = 0;
};
/**
 * resets state
 * @returns {void}
 */
Stateless.FormData.prototype.clear = function(){
    this.data = {};
    this.formData= new FormData();
    this.recordCount = 0;
};

/**
 * sets value of field
 * @param {string} name
 * @param {obj} value
 * @returns {void}
 */
Stateless.FormData.prototype.append = function(name,value){
    if(!name){return;}
    this.data[name] = value;
    this.formData.append(name,value);
    this.recordCount++;
};

/**
 * @returns {String} querystring of name value collection url encoded
 */
Stateless.FormData.prototype.queryString = function(){
    var queryString = '';
    for(var name  in this.data){
        queryString += "&" + name +'=' + encodeURIComponent(this.data[name]);
    }

    queryString =  queryString.replace('&',''); //remove first &
    return queryString;
};
/* stateless-sfl */
/* Load Timestamp 13:59:55.649 */
/* global Stateless, XDOM, SETTINGS, SESSION, Subfile, Logical, GLOBAL */

Stateless.subfile = function(pageObject) {
    this.page = pageObject;
    this.sflObject = null;
    this.inputIds = [];
    this.fieldProgressionIndex = 5;
    this.reload = false;
};

Stateless.subfile.pageSize = 30;

Stateless.subfile.prototype.filterData = function() {
    if (!this.page.data.subfileAttributes) {
        return;
    }
    var raw = this.page.data.subfileData.slice(0), //copy of subfile data
        rawAttributes = this.page.data.subfileAttributes.slice(0),
        record = null,
        recordAttributes = null;

    this.page.data.subfileData = [];
    this.page.data.removedSubfileData = [];
    this.page.data.subfileAttributes = [];
    for (var i = 0, l = raw.length; i < l; i++) {
        record = raw[i];
        recordAttributes = rawAttributes[i];
        if (recordAttributes["SF_DSP"] === "0") {
            //komt niet meer voor in selectie
            this.page.data.removedSubfileData.push(record);
        } else {
            this.page.data.subfileData.push(record);
            this.page.data.subfileAttributes.push(recordAttributes);
        }
    }
};

Stateless.subfile.prototype.setscrollPoss = function() {
    let bodyDiv = XDOM.getObject(this.page.prefix + "SFL");
    body = XDOM.query('[data-record-selected="true"]', bodyDiv);

    bodyDiv.dataset.scrollPosition = bodyDiv.scrollTop;
    if (body) {
        bodyDiv.dataset.selectedRecord = body.dataset.recordNumber;
    }
};

Stateless.subfile.prototype.scrollsUp = function(obj) {
    var bodyDiv = GLOBAL.eventSourceElement,
        lastPos = parseInt(bodyDiv.dataset.scrollPosition),
        newPos = bodyDiv.scrollTop;
    bodyDiv.dataset.scrollPosition = bodyDiv.scrollTop;

    return lastPos > newPos;
};

Stateless.subfile.prototype.update = function() {
    if (this.sflObject) {
        this.filterData();
        this.sflObject.updateColumnHeading(
            XDOM.getObject(this.page.prefix + "COLHDGTBL")
        );
        this.sflObject.update(this.reload);
        Subfile.fixHeaderLogical(this.page.prefix);
        this.adjustHeight();
        this.scrollTop();
        this.reload = false;
    }
};

Stateless.subfile.prototype.getReturnValues = function(tBody) {
    let returnToCaller = tBody.getAttribute("data-subfile-return-to-caller");
    if (!returnToCaller) {
        return;
    }
    let dataFields = returnToCaller.split(" "),
        recordNumber = getClientRecordNr(tBody),
        record = this.page.data.subfileData[recordNumber],
        returnValues = [];

    for (var i = 0, l = dataFields.length; i < l; i++) {
        returnValues.push(record[dataFields[i]]);
    }
    return returnValues;
};
Stateless.subfile.prototype.append = function(data) {
    if (!this.appendset) {
        return false;
    }

    this.appendset = false;
    //this.page.data.headerData.WS_SSR = data.headerData.WS_SSR;
    this.page.data.headerData.WS_SER = data.headerData.WS_SER;
    if (this.page.data.subfileData.length === 0) {
        return; //er is geen data meer om toe te voegen
    }

    this.page.data.subfileData = this.page.data.subfileData.concat(
        data.subfileData
    );
    if (this.page.data.subfileAttributes) {
        this.page.data.subfileAttributes = this.page.data.subfileAttributes.concat(
            data.subfileAttributes
        );
        this.sflObject.attributes = this.page.data.subfileAttributes;
    }

    this.page.setValues();
    if (data.subfileData.length == 0) {
        this.page.setMessage(getCapt('msgNoMoreData'), "signal");
    } else {
        this.page.setMessage();
    }

    this.sflObject.data = this.page.data.subfileData;
    this.sflObject.renderNextRecords();
    this.setscrollPoss();
    return true;
};

Stateless.subfile.prototype.getNextSet = function() {
    this.appendset = true;
    this.page.setMessage(getCapt('msgLoadingData'), "loading");
    this.page.submit("NXTSET");
};

Stateless.subfile.prototype.renderNextRecords = function(fromScroll) {
    if (this.sflObject.renderNextRecords()) {
        return;
    }
    if (fromScroll && this.page.type != "MultiSelect") {
        this.getNextSet();
    }
};

Stateless.subfile.prototype.scrollTop = function(e) {
    var bodyDiv = XDOM.getObject(this.page.prefix + "SFL"),
        selected = bodyDiv.dataset.selectedRecord;

    if (!this.reload) {
        bodyDiv.scrollTop = 0;
        this.setscrollPoss();
    }
    bodyDiv.scrollTop = bodyDiv.dataset.scrollPosition;
    if (selected) {
        let tbody = XDOM.query('tbody[data-record-number="' + selected + '"]');
        if (tbody) {
            tbody.setAttribute("data-record-selected", true);
        }
    }
    return;
};



Stateless.subfile.onScroll = function(e) {
    XDOM.getEvent(e);
    var obj = GLOBAL.eventSourceElement,
        minPxFromBottom = 100,
        pxFromBottom = obj.scrollHeight - obj.clientHeight - obj.scrollTop,
        page = Stateless.Page.get();

    Stateless.Page.setScope(page);
    if (Subfile.checkForChange(page)) {
        return;
    }

    if (pxFromBottom > minPxFromBottom) {
        return;
    }

    if (page && page.subfile) {
        if (page.subfile.scrollsUp()) {
            return;
        }
        page.subfile.renderNextRecords(true);
    }
    Stateless.Page.setScope();
};

Stateless.subfile.prototype.setTabelWidth = function(header, body) {
    var width = header.parentNode.offsetWidth - 16;
    header.getElementsByTagName("TABLE")[0].style.width = width + "px";
    body.getElementsByTagName("TABLE")[0].style.width = width + "px";
};

Stateless.subfile.prototype.setForReload = function() {
    //zet de eerste regel op 0
    this.setscrollPoss();
    this.reload = true;
};

Stateless.subfile.prototype.prepareSortButtons = function(headerDiv) {
    const prefix = this.page.prefix;
    [...headerDiv.querySelectorAll("[data-sort-field-name]")].forEach(div =>
        div.setAttribute(
            "data-sort-field-name",
            prefix + div.getAttribute("data-sort-field-name")
        )
    );
};

Stateless.subfile.prototype.prepare = function() {
    var headerDiv = XDOM.getObject(this.page.prefix + "COLHDG"),
        bodyDiv = XDOM.getObject(this.page.prefix + "SFL");

    if (!bodyDiv) {
        return;
    }

    headerDiv.setAttribute(
        "data-fieldprogression-index",
        this.fieldProgressionIndex++
    );
    bodyDiv.setAttribute(
        "data-fieldprogression-index",
        this.fieldProgressionIndex
    );
    Subfile.setHeaderBodyRef(this.page.prefix);
    XDOM.addEventListener(bodyDiv, "scroll", Stateless.subfile.onScroll);

    this.setTabelWidth(headerDiv, bodyDiv);
    this.prepareSortButtons(headerDiv);
    this.sflObject = new Subfile(this.page.prefix + "SFLTBL");
    this.sflObject.pageSize = Stateless.subfile.pageSize;
    this.sflObject.prefix = this.page.prefix;
    this.sflObject.prepareDom();
    this.sflObject.recordTemplate.setAttribute("data-stateless-id", this.page.id);
    Subfile.setHeaderBodyRef(this.page.prefix);
    Subfile.fixHeaderLogical(this.page.prefix);
};

Stateless.subfile.prototype.adjustHeight = function() {
    if (this.page.screenMode !== ENUM.screenMode.subview) {
        return;
    }

    let sflDiv = XDOM.getObject(this.sflObject.id).parentNode,
        sflTop = getObjPosTo(sflDiv, this.page.parentId).top,
        containerheight = this.page.parentId.offsetHeight,
        sflHeight = containerheight - sflTop - 30;
    sflDiv.style.height = sflHeight + "px";
};

/* factory */
/* Load Timestamp 13:59:55.649 */
var GUI = {};
/**
 * factory voor pageObjects
 * @param obj definitie in json van object
 * @returns pageObject
 */
GUI.factory = {};
GUI.factory.get = function(obj,parentObject ){
    var foObj = null;
    GUI.translateDefinition(obj);
    if(!(obj && obj.type)){
        return;
    }

    switch(obj.type){
        case 'output':
            if(obj.dataType == ENUM.dataType.logical){
                foObj =  new GUI.LogicalOut(obj);
                break;
            }
            if(obj.dataType == ENUM.dataType.link){
                foObj =   new GUI.Link(obj);
                break;
            }
            if(obj.dataType == ENUM.dataType.memo){
                foObj =   new GUI.MemoOut(obj);
                break;
            }
            if(nullWhenEmpty(obj.editMask)!=null){
                foObj =   new GUI.MaskedOutput(obj);
                break;
            }
            foObj =   new GUI.Output(obj);
            break;
        case 'input':

            if(nullWhenEmpty(obj.editMask)!=null){
                foObj =   new GUI.MaskedInput(obj);
                break;
            }

            if(obj.dataType == ENUM.dataType.memo){
                foObj =   new GUI.MemoIn(obj);
                break;
            }


            if(obj.dataType == ENUM.dataType.logical){
                foObj =   new GUI.LogicalIn(obj);
                break;
            }

            if(obj.fieldAttribute=="*HIDDEN"){
                foObj =   new GUI.Hidden(obj);
                break;
            }

            foObj =   new GUI.Input(obj);
            break;
        case 'hiddenInput':
            foObj =   new GUI.Hidden(obj);
            break;
        case 'chart':
            foObj =   new GUI.Chart(obj);
            break;
        case 'label':
            foObj =   new GUI.Label(obj);
            break;
        case 'image':
            foObj =   new GUI.Image(obj);
            break;
        case 'constant':
            foObj =   new GUI.Constant(obj);
            break;
        case 'dataset':
            foObj =   new GUI.DataSet(obj);
            break;
        case 'serviceChoice':
            foObj =   new GUI.ChoiceService(obj);
            break;
        case 'serviceDisplay':
            foObj =   new GUI.DisplayService(obj);
            break;
        case 'serviceRetrieve':
            foObj =   new GUI.Retrieve(obj);
            break;
        case 'CalendarChoice':
            foObj =   new GUI.Calendar(obj);
            break;
        case 'sessionLauncher':
            foObj =   new GUI.SessionLauncher(obj);
            break;
        case 'quickSearch':
            foObj =   new GUI.QuickSearch(obj);
            break;
        case 'queryList':
            foObj =   new GUI.QueryList(obj);
            break;
        case 'infoProgram':
            foObj =   new GUI.InfoWindowIcon(obj);
            break;
        case 'editProgram':
            foObj =   new GUI.EditWindowIcon(obj);
            break;
        case 'unauthorized':
        case 'notAuthorized':
        case 'CommandButton':
            return null;
            break;
        default:
            console.log('onbekend gui object:');
            console.log(obj);
            return null;
    }

    foObj.parentObject = parentObject;
    return foObj;
};

/* baseObject */
/* Load Timestamp 13:59:55.649 */
/* global GUI, ENUM */

/**
 * parent object voor Label,output objecten
 * @param obj data object die de eigenschappen van dit guiObject bevatten
 * @returns {GUI.BaseObject}
 */
GUI.BaseObject = function (obj) {

    /**
     * type object
     */
    this.type = nullWhenEmpty(obj.type);

    /**
     * id van object
     */
    this.id = nullWhenEmpty(obj.id);

    /**
     * x positie
     */
    this.x = nullOrInt(obj.xPosition);

    /**
     * y positie
     */
    this.y = nullOrInt(obj.yPosition);

    /**
     * breedte
     */
    this.width = nullOrInt(obj.xSize);

    /**
     * hoogte
     */
    if (obj.ySize) {
        this.height = nullOrInt(obj.ySize);
    }

    /**
     * hoogte
     */
    if (obj.lines) {
        this.height = nullOrInt(obj.lines);
    }

    /**
     * uitleining text
     */
    this.textAlign = nullWhenEmpty(obj.textAlign);

    /**
     * achtergrond kleur
     */
    this.backgroundColor = nullWhenEmpty(obj.backgroundColor);

    /**
     * text kleur
     */
    this.textColor = nullWhenEmpty(obj.textColor);

    this.textColorField = nullWhenEmpty(obj.textColorField);

    this.backgroundColorField = nullWhenEmpty(obj.backgroundColorField);


    /**
     * Tooltips
     */

    this.hintOrigin = nullWhenEmpty(obj.hintOrigin);
    this.hintVariable = nullWhenEmpty(obj.hintVariable);


    /**
     * indicatie veld voor het bepalen van attentionlevel
     */
    this.attentionLevel = new GUI.AttentionLevel(obj, this);


    /**
     * conditionalAttribute
     */
    this.conditionalAttributes = new GUI.ConditionalAttribute(obj, this);

    /**
     * geeft aan of element of element verborgen is
     */
    this.isHidden = nullWhenEmpty(obj.hidden);

    /**
     * geeft aan of element protected is
     */
    this.isProtected = nullWhenEmpty(obj.protected);

    /**
     * geeft aan of element getoond moet worden als label
     */
    this.showAsLabel = nullWhenEmpty(obj.showAsLabel);

    /**
     * indicatie veld voor het bepalen van fieldattribute attention
     */
    //this.attentionLevelField = nullWhenEmpty(obj.attentionLevelField);

    this.fieldAttrAttention = nullWhenEmpty(obj.fieldAttrAttention);


    /**
     * geeft aan of element onderstreept is
     */
    this.underline = nullWhenEmpty(obj.underline);

    /**
     * waarde van dit object;
     */
    this.value = nullWhenEmpty(obj.value);

    /**
     * textlevel ten behoeven van opmaak van labels
     */
    this.textLevel = nullWhenEmpty(obj.textLevel);

    /**
     * referentie naar de data voor deze pagina of dit panel;
     */
    this.currentData = null;


    /**
     * geeft aan of een negatieve numerieke waarde rood moet worden weergegeven
     */
    this.signed = obj.signed


    /**
     * geeft aan object USC2 gecodeerd wordt
     */
    this.ucs2 = obj.ucs2;

    /**
     * geeft aan object upper case wordt
     */
    this.upperCase = obj.upperCase

    /**
     * geeft aan object links aangevuld wordt met spaties
     */
    this.leftBlank = obj.leftBlank;

    /**
     * geeft aan object links aangevuld wordt met '0' characters
     */
    this.LeftZero = obj.LeftZero;

    /**
     * geeft aan object alleen getallen mag zijn
     */
    this.digitsOnly = obj.digitsOnly;

    /**
     * geeft aan object alleen alpha mag zijn
     */
    this.Alpha = obj.Alpha;

    /**
     * veld waar data vandaan komt
     */
    this.datafield = nullWhenEmpty(obj.dataField);

    /**
     * font size rangin from *S to *9XL
     */
    this.fontSize = nullWhenEmpty(obj.fontSize);

    /**
     * string die aan geeft of dit object onderdeel is van bepaald speciaal deel
     * van een scherm zoals benoemd in de enum GUI.DataSet.Part
     *
     */
    this.partOff = null;

    /**
     * regelnummer bij een multiline element
     */
    this.rowNumber = null;


    /**
     * helper voor het bepalen van css Classes
     */
    this.cssClass = new GUI.CssClass(this);

    /**
     * parentObject b.v. infowindow
     */
    this.parentObject = null;

    /**
     * verzameling dom objecten
     */
    this.dom = {};

    /**
     * buitenste dom object
     */
    this.dom.domObject = null;

    this.panelId = null;

    this.variable = nullWhenEmpty(obj.variable);

    this.fieldAttribute = nullWhenEmpty(obj.fieldAttribute);

    /**
     * alias fields
     *
     */
    this.aliasType = nullWhenEmpty(obj.aliasType);
    this.aliasField = nullWhenEmpty(obj.aliasField);
};


GUI.BaseObject.prototype.init = function () {

    if (!this.datafield) {
        this.datafield = this.id;
    }
    this.panelId = this.parentObject.panelId;
    this.id = this.panelId + '-' + this.id;
    this.setFieldAttributes();
};


GUI.BaseObject.prototype.setFieldAttributes = function () {

    if (!this.fieldAttribute) {
        return;
    }

    var attribute = null;
    for (var i = 0, l = this.fieldAttribute.length; i < l; i++) {
        attribute = this.fieldAttribute[i].trim();
        switch (attribute) {
            case "*AUTOSBM":
                this.autoSubmit = true;
                break;
            case "*UNDERLINE":
                this.underline = true;
                break;
            case "*HIDDEN":
                this.isHidden = true;
                break;
            case "*PROTECT":
                this.isProtected = true;
                break;
            case '*LBL':
                this.showAsLabel = true;
                break;
            case "*MSG":
            case "*INF":
            case "*ATN":
            case "*ALR":
            case "*ERR":
                this.fieldAttrAttention = ENUM.attentionLevelToCode[attribute];
                break;
        }
    }
};


/**
 * geeft waarde terug van dit guiObject
 * @returns waarde van dit guiObject
 */
GUI.BaseObject.prototype.getValue = function () {
    return this.value;
};

/**
 * wijst nieuwe waarde toe aan dit guiObject en voerd daarna een update uit.
 * als er geen value als argument wordt meegegeven wordt de data uit de  this.currentData gehaald
 * @param value
 */
GUI.BaseObject.prototype.setValue = function (value) {
    if (value) {
        this.value = value;
    } else {
        this.value = this.getDataValue(this.datafield);
    }

    if (this.ucs2) {
        this.value = XDOM.hexDecode(this.value);
    }

    if (!this.value) {
        this.value = '';
    }
};

/**
 * geeft waarde terug van de line of multi line data afhankelijk van of het element multiline is
 * @param field
 * @returns {string} data
 */
GUI.BaseObject.prototype.getDataValue = function (field) {
    if (!this.currentData) {
        return '';
    }
    return this.currentData[field];
};

/**
 * inititaliseerd default waarden als deze niet zijn ge definieerd
 */
GUI.BaseObject.prototype.setDefaults = function () {
    if (!this.datafield) {
        this.datafield = this.id;
    }
};

/**
 * steld de x,y en breedte in van het dom.domObject
 */
GUI.BaseObject.prototype.setPosAndDimentions = function () {
    this.parentObject.setPosAndDimentions(this);

};

/**
 * verkrijgt de CSS style CLass op basis van type en zaken geregeld in het in cssClass Objectt
 * @see GUI.CssClass (GUI/helper/CssClass.js)
 * @returns {String}
 */
GUI.BaseObject.prototype.getCssClass = function () {
    return this.type + ' ' + this.cssClass.getClass();
};


/**
 * past dit guiObject aan wat beterft uiterlijk  op basis van de op dat moment voorhande zijnde data
 */
GUI.BaseObject.prototype.updateState = function () {
    this.attentionLevel.update();
    this.conditionalAttributes.update();
    this.updateDataAttribute();
    //this.setInlineColors();
};


GUI.BaseObject.prototype.updateDataAttribute = function () {
    //when fontsize is set add it as an attribute
    if(this.fontSize){
        this.dom.domObject.setAttribute("data-font-size", this.fontSize)
    }

    if(!this.value){
        return;
    }

    if(this.leftBlank && this.maxLength){
        this.value=this.value.lftzro(this.maxLength);
    }

    if(this.LeftZero && this.maxLength){
        this.value=this.value.lftzro(this.maxLength);
    }


}

GUI.BaseObject.prototype.setAlias = function(icon){
    if(!this.aliasType) return null;
    switch(this.aliasType){
        case "*VAR":
            icon.innerHTML = this.getDataValue(this.aliasField);
            icon.classList.add("label-icon");
            break;
        case "*LBL":
            icon.innerHTML = this.parentObject.captions.get(this.aliasField);
            icon.classList.add("label-icon");
            break;
        case "*ICON":
            //get the store because this is a costly operation
            //the store wil only be created once in the main part of oculus
            const store = SCOPE.main.icons.getIconStore();
            const cssClass = store[this.aliasField.toUpperCase()] || "";
            icon.classList.add("fa","icon", cssClass);

            break;
    }
    icon.classList.remove("pth-icon","pth-infoProgram","pth-editProgram","editProgram","infoProgram");
    icon.setAttribute("data-button-icon","")

}


/**
 * past object aan op basis van de data
 * @param data
 */
GUI.BaseObject.prototype.update = function (data) {
    this.currentData = data;
    this.setValue();
    this.updateState();


    this.setInfoTitles();
};

GUI.BaseObject.prototype.afterAppend = function () {

};

GUI.BaseObject.prototype.getColor = function (field) {
    let color = this.getDataValue(field);
    return GUI.translateDefinition.color[color] || color;
}

GUI.BaseObject.prototype.setInfoTitles = function () {
    var titleString = "";
    var shortLink = null;
    if (this.dom.domObject && this.hintOrigin && this.hintVariable) {
        switch (this.hintOrigin) {
            case "*VAR":
                titleString = this.parentObject.data[this.hintVariable];
                break;
            case "*LBL":

                shortLink = this.parentObject.captions;
                if (shortLink.userCaptions && hasValue(shortLink.userCaptions[this.hintVariable])) {
                    titleString = shortLink.userCaptions[this.hintVariable];
                }

                if (shortLink.defaultCaptions && hasValue(shortLink.defaultCaptions[this.hintVariable])) {
                    titleString = shortLink.defaultCaptions[this.hintVariable];
                }
                break;
        }
        GUI.infoTitle.register(this.dom.domObject, titleString);
    }
};
/* baseInputObject */
/* Load Timestamp 13:59:55.650 */
/**
 * parent object voor input objecten
 * @param obj data object die de eigenschappen van dit guiObject bevatten
 * @returns {GUI.BaseObject}
 */
GUI.BaseInputObject = function(obj){
    GUI.BaseInputObject.baseConstructor.call(this,obj);
    this.dataType = nullWhenEmpty(obj.dataType);
    this.name = null;
    this.realName = obj.id;
    this.parentId = null;
    this.autoSubmit = false;
    this.forFieldProgression = false;
};

XDOM.extendObject(GUI.BaseInputObject, GUI.BaseObject);

GUI.BaseInputObject.prototype.init = function(){
    this.base(GUI.BaseInputObject, 'init');
    this.name = this.id;
    this.macroName = this.parentObject.macroName;
};
GUI.BaseInputObject.setOldValue = function(){
    XDOM.GLOBAL.setAttribute("data-old-value", GLOBAL.eventSourceElement.value);
};








/* basePanel */
/* Load Timestamp 13:59:55.650 */
GUI.BasePanel = function () {
    this.id = null;
    this.dom = {};
    this.dom.domObject = null;
    this.definition = null;
    this.guiObjects = [];
    this.currentData = null;
    this.captions = null;
    this.services = {};
    this.data = null;
    this.subfileData = null;
    this.header = null;
    this.cssClass = 'popup-panel';
    this.cssPosition = '';
    this.setSize = true;
    this.dataSet = null;
    this.sizes = {};
    this.macroName = null;
    this.panelId = null;
    /**
     * y locatie van paneel
     */
    this.sizes.yPos = 0;
    /**
     * x locatie van panel
     */
    this.sizes.xPos = 0;

    /**
     * hoogte van parent element per regel
     */
    this.sizes.parentRowHeight = 100 / 24;
    /**
     * hoogte van header in regels
     */
    this.sizes.HeaderRowHeight = 1.1;
    /**
     * hoogte van header + footer RKR
     */
    this.sizes.fixedHeaderHeight = 0;
    this.sizes.fixedFooterHeight = 30;

    /**
     * hoogte van panel in procenten
     */
    this.sizes.panelHeight = 0;
    /**
     * breedte van panel in procenten
     */
    this.sizes.panelWidth = 0;
    /**
     * hoogte van body in procenten van de panel div
     */
    this.sizes.bodyHeight = 0;

    /**
     * hoogte van 1 regel in pixels binnen de panel body in procenten
     */
    this.sizes.lineHeightPx = 20;

    /**
     * breedte van 1 colomn binnen de panel body in pixels
     */
    this.sizes.colWidthPx = 9;

    /**
     * breedte van 1 colomn binnen de panel body in procenten
     */
    this.sizes.colWidth = 0;

    /**
     * aantal regels in de body
     */
    this.sizes.panelRows = 0;
    /**
     * aantal colommen in de body
     */
    this.sizes.panelCols = 0;

    /**
     * top padding in de body in pixels
     */
    this.sizes.panelBodyTopPadding = 10;

    /**
     * bottom padding in de body in pixels
     */
    this.sizes.panelBodyBottomPadding = 10;

    this.sizes.footerHeight = 30;


    this.rowHeight = 0;

    this.isInitialised = false;

    this.isVisible = false;


    /**
     * kind of panel modal|subview
     */
    this.screenMode = null;

    /**
     * info of update
     */

    this.windowType = "info";

    this.placeHolder = null;
    this.footer = null;

    this.useCache = SESSION.session.debugMode;

};

GUI.BasePanel.prototype.calculateDimentions = function () {
    var panelWidth = "";
    panelWidth = this.sizes.panelCols.toString();
    this.sizes.panelWidth = panelWidth.lftzro(3);
    this.sizes.colWidth = 100 / this.sizes.panelCols;
    this.sizes.perc = {};
    this.sizes.panelBodyRows = this.sizes.panelRows - .5;

    if (this.header) {
        this.sizes.headerHeight = this.sizes.lineHeightPx * this.sizes.HeaderRowHeight;
        this.sizes.panelHeight = this.sizes.headerHeight;
    }
    this.sizes.bodyHeight = this.sizes.panelBodyRows * this.sizes.lineHeightPx;
    this.sizes.bodyHeight += this.sizes.panelBodyBottomPadding;
    this.sizes.bodyHeight += this.sizes.panelBodyTopPadding;
    this.sizes.panelHeight += this.sizes.bodyHeight;
    if (this.windowType == "edit") {
        this.sizes.panelHeight += this.sizes.footerHeight;
    }
    this.sizes.bodyHeight += 'px';
    this.sizes.panelHeight += 'px';
    this.sizes.headerHeight += 'px';
    this.sizes.perc.BodylineHeight = 100 / this.sizes.panelBodyRows;
};

/**
 * voor subview schermen met een data set geld de volgende regel: - alle regels onder de dataset worden tegen de
 * onderkant gepositioneerd - de subfile krijgt alle ruimte tussen de boven kant van de subFile en de laatste regel
 */
GUI.BasePanel.prototype.repositionElements = function () {
    var fiMaxLineNumber = this.dataSet.y + this.dataSet.height;
    var fiStopRow = null;
    var foObject = null;
    var fiOffSet = null;
    var fiPlaceHolderRows = floor(this.placeHolder.offsetHeight / this.sizes.lineHeightPx, 0);
    fiPlaceHolderRows -= 2;

    // bepaal de maximale regel op basis van .y en .height
    for (var id in this.guiObjects) {
        foObject = this.guiObjects[id];
        if (foObject == this.dataSet) {
            continue;
        } // sluit de dataset zelf uit
        fiStopRow = foObject.y;
        if (foObject.height) {
            fiStopRow += foObject.height;
        }
        if (fiMaxLineNumber < fiStopRow) {
            fiMaxLineNumber = fiStopRow;
        }
    }
    fiOffSet = fiPlaceHolderRows - fiMaxLineNumber;
    this.dataSet.resetHeight(fiOffSet);

    if (fiMaxLineNumber <= this.dataSet.y) {
        // geen elementen onder de data set
        return;
    }

    // fiOffSet berkenen op basis van het maximaal aantal regels - fiMaxLineNumber in de fieldset
    // alle element die een y hoger dan dataset hebben worden geherpositioneerd op basis van de offset
    for (var id in this.guiObjects) {
        foObject = this.guiObjects[id];
        if (foObject.y > this.dataSet.y) {
            foObject.y += fiOffSet;
        }
    }

};

GUI.BasePanel.prototype.authHidden = function(obj) {
    const authorization = this.authorizationFields?this.authorizationFields[obj.toId]:null;

    if(!authorization) {
        return false;
    }

    if(authorization.authorizationLevel == ENUM.authorizationLevel.hidden){
        return true;
    }
    //always hide when an authorisation is set for these types
    return ["CalendarChoice", "serviceChoice", "serviceDisplay", "serviceRetrieve"].includes(obj.type)
}

GUI.BasePanel.prototype.init = function (response) {
    if (this.isInitialised) {
        return;

    } // initialisatie heeft al plaats gevonden
    this.sizes.panelRows = parseInt(this.definition.ySize);
    this.sizes.panelCols = parseInt(this.definition.xSize);
    if (this.definition.title) {
        this.header = new GUI.PanelHeader(this.definition, this);
    }
    var faElements = this.definition.elements;
    var faUnauthorizedObject = this.authorizationFields;

    var foObjDev = null;
    var foGuiObject = null;
    var fsObjToId = null;
    var authorizationObj = null;
    this.calculateDimentions();

    for (var i = 0, l = faElements.length; i < l; i++) {
        foObjDev = faElements[i];

        if(this.authHidden(foObjDev)){
            continue;
        }


        foGuiObject = GUI.factory.get(foObjDev, this);
        if (!foGuiObject) {
            continue;
        }
        if (foGuiObject.type == "dataset") {
            foGuiObject.subfileData = this.subfileData;
            foGuiObject.currentData = this.data;
            this.dataSet = foGuiObject;
        } else {
            foGuiObject.currentData = this.data;
        }
        foGuiObject.init();
        this.guiObjects[foGuiObject.id] = foGuiObject;
    }

    if (this.windowType == "edit") {
        this.footer = new GUI.EditWindowFooter(this);
        this.footer.init();
        // this.guiObjects["footer"]=this.footer;
    }

    this.isInitialised = true;
};

/**
 * huidige active instantie
 */
GUI.BasePanel.currentInstance = null;

/**
 * response data
 */
GUI.BasePanel.response = null;

/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {String}
 */
GUI.BasePanel.prototype.getXPosPerc = function (nr) {
    return this.getXPos(nr) + "%";
};
/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {String}
 */
GUI.BasePanel.prototype.getYPosPerc = function (nr) {
    // return this.getYPos(nr-1) + "%";
    return floor((nr - 0.75) * this.sizes.perc.BodylineHeight, 2) + "%";
};

GUI.BasePanel.prototype.getYPosPX = function (nr) {
    return this.getYPos(nr - 1) + "PX";
};

/**
 *
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {String}
 */
GUI.BasePanel.prototype.getWidthPerc = function (nr) {
    return this.getWidth(nr) + "%";
};

/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {String}
 */
GUI.BasePanel.prototype.getHeightPerc = function (nr) {
    return floor(nr * this.sizes.perc.BodylineHeight, 2) + "%";
};

/**
 * vertaald positie nummer naar percentage
 *
 * @param nr
 * @returns {Number}
 */
GUI.BasePanel.prototype.getHeight = function (nr) {
    return floor(nr * this.sizes.lineHeight, 2);
};
/**
 * vertaald positie nummer percentage
 *
 * @param nr
 * @returns {Number}
 */
GUI.BasePanel.prototype.getWidth = function (nr) {
    return floor(nr * this.sizes.colWidth, 2);
};
/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {Number}
 */
GUI.BasePanel.prototype.getXPos = function (nr) {
    return floor(nr * this.sizes.colWidth, 2);
};
/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {Number}
 */
GUI.BasePanel.prototype.getYPos = function (nr) {
    return floor((nr * this.sizes.lineHeight) + this.sizes.panelBodyTopPadding, 2);
};
/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {Number}
 */
GUI.BasePanel.prototype.getWidthPx = function (nr) {
    //var fiTotalWidth = this.dom.body.offsetWidth;
    //var fiColWidth = fiTotalWidth / this.sizes.panelCols;
    return (nr * this.sizes.colWidthPx) + 'px';
};

/**
 * vertaald positie nummer naar pixels
 *
 * @param nr
 * @returns {String}
 */
GUI.BasePanel.prototype.getHeightPx = function (nr) {
    return (nr * this.sizes.lineHeightPx) + this.sizes.panelBodyTopPadding + 'px';
};

/**
 * steld de x,y en breedte in van het dom.domObject
 *
 * @param obj
 */
GUI.BasePanel.prototype.setPosAndDimentionsPerc = function (obj) {
    obj.dom.domObject.style.left = this.getXPosPerc(obj.x);
    obj.dom.domObject.style.top = this.getYPosPerc(parseInt(obj.y));
    if (this.setSize) {
        if (obj.width) {
            obj.dom.domObject.style.width = this.getWidthPerc(obj.width);
        }
        //if (obj.height) {
        //obj.dom.domObject.style.height = this.getHeightPerc(obj.height);
        //}
    }
};

/**
 * steld de x,y en breedte in van het dom.domObject
 *
 * @param obj
 */
GUI.BasePanel.prototype.setPosAndDimentions = function (obj) {

    //obj.dom.domObject.style.left = this.sizes.colWidthPx * obj.x + 'px';
    //obj.dom.domObject.style.top = this.sizes.lineHeightPx * (obj.y - 0.5) + 'px';
    obj.dom.domObject.setAttribute("data-stateless-page-id", this.id);
    if (this.setSize) {
        if (obj.sizesInPixels) {
            if (obj.width) {
                obj.dom.domObject.style.width = this.sizes.colWidthPx * obj.width + 'px';
            }
            //if (obj.height) {
            //  obj.dom.domObject.style.height = this.sizes.lineHeightPx * obj.height + 'px';
            //}
        }
    }

    if (obj == this.dataSet && this.screenMode == GUI.BasePanel.screenMode.subview) {
        if (obj.widthPx) {
            obj.dom.domObject.style.width = obj.widthPx;
        }
        // obj.dom.domObject.style.width = this.dom.body.offsetWidth - (3 * this.sizes.colWidthPx) + "px";

    }
};

GUI.BasePanel.prototype.render = function () {
    if (this.isVisible && this.useCache) {
        return;
    }

    this.isVisible = true;
    this.dom.domObject = XDOM.createElement('DIV', this.panelId, this.cssClass + ' ' + this.cssPosition);
    fp.setIndex(this.dom.domObject);

    var callerObj = null;
    if (this.dom.icon) {
        callerObj = this.dom.icon;
        this.dom.domObject.setAttribute("data-stateless-panel-modi", XDOM.getAttribute(callerObj, "data-open-options"));
    }

    if (this.setSize) {
        if (this.screenMode != GUI.BasePanel.screenMode.subview) {
            //this.dom.domObject.style.height = this.sizes.panelHeight;
            this.dom.domObject.className += "xSizePanel" + this.sizes.panelWidth;
        } else {
            // aanpassen breedte van window:
            if (this.placeHolder.offsetWidth < this.sizes.panelCols * this.sizes.colWidthPx) {
                // de maat zoals die gedefinieerd is in de window is niet groot er wordt een scrollbar worden getoond de grote
                // wordt nu bepaald op basis van de definitie
                this.dom.domObject.style.width = (this.sizes.panelCols * this.sizes.colWidthPx) + 'px';
                this.placeHolder.style.overflowX = 'auto';
                if (this.dataSet) {
                    this.dataSet.width = this.sizes.panelCols - 3;
                }
            } else {
                if (this.dataSet) {
                    // de fieldset is groter of gelijk de dataset wordt uitgerekt over de hele beschikbare breedte
                    this.dataSet.widthPx = (this.placeHolder.offsetWidth - (3 * this.sizes.colWidthPx)) + "px";
                }
            }
            if (this.placeHolder.offsetHeight < this.sizes.panelRows * this.sizes.lineHeightPx) {
                //this.dom.domObject.style.height = (this.sizes.panelRows * this.sizes.lineHeightPx) + 'px';
                this.placeHolder.style.overflowy = 'auto';
            } else {
                //this.dom.domObject.style.height = '100%';
            }
        }
    }

    this.renderHeader();
    this.renderBody();
    this.renderFooter();

    return;
};

GUI.BasePanel.prototype.renderHeader = function () {
    if (this.header) {
        this.header.render();
    }
};
/*
 * TOEGEVOEGD DOOR RKR
 */
GUI.BasePanel.prototype.renderFooter = function () {
    if (this.footer) {
        this.dom.domObject.appendChild(this.footer.render());
        this.updateMessage();
    }
};
/*
 * ------------------------------------------------------------
 */
GUI.BasePanel.prototype.renderBody = function () {
    this.dom.body = XDOM.createElement('DIV', "panel-body-" + this.id, "panelBody");
    this.dom.bodyMargin = XDOM.createElement('DIV', null, 'panelMargin');

    // Loop to create and run after-append
    for (let id in this.guiObjects) {
        this.dom.bodyMargin.appendChild(this.guiObjects[id].render());
        this.guiObjects[id].afterAppend();
    }

    if (this.setSize && this.screenMode != GUI.BasePanel.screenMode.subview) {
        this.dom.body.style.height = this.sizes.bodyHeight;
    }

    this.dom.body.appendChild(this.dom.bodyMargin);
    this.dom.domObject.appendChild(this.dom.body);

    if (this.screenMode == GUI.BasePanel.screenMode.subview) {
        //var minusHeight = null;
        this.dom.body.setAttribute("data-panel-footer", "false");
        if (this.footer) {
            //minusHeight = this.sizes.fixedHeaderHeight + this.sizes.fixedFooterHeight;
            this.dom.body.setAttribute("data-panel-footer", "true");
        } //else {
        // minusHeight = this.sizes.fixedHeaderHeight;
        //}


        //this.dom.body.style.height = (this.placeHolder.offsetHeight - minusHeight) + "px";
    }
};

GUI.BasePanel.prototype.update = function () {
    for (var id in this.guiObjects) {
        if (this.guiObjects[id].type == 'dataset') {
            this.guiObjects[id].update(this.subfileData);
        } else {
            this.guiObjects[id].update(this.data);
        }
    }
    this.header.update();
};

GUI.BasePanel.instances = [];


GUI.BasePanel.focus = function (id) {
    if (Panel.instances[id].onFocus) {
        Panel.instances[id].onFocus();
    }
};

GUI.BasePanel.prototype.show = function () {
    if (this.isVisible) {
        return;
    }
    this.dom.domObject.setAttribute('data-forced', 'false');
    this.dom.domObject.setAttribute('data-hidden', 'false');
    this.alignPanel();
    this.isVisible = true;
};

GUI.BasePanel.prototype.alignPanel = function (response) {

    if (this.screenMode !== GUI.BasePanel.screenMode.subview) {
        let icon = XDOM.getObject(this.dom.icon.id);
        position = alignTo(this.dom.domObject, icon);
        this.dom.domObject.style.top = position.top + 'px';
        this.dom.domObject.style.left = position.left + 'px';
    }
}
GUI.BasePanel.prototype.close = function (delayed) {

    if (this.screenMode == GUI.BasePanel.screenMode.subview) {
        return;
    }
    let icon = XDOM.getObject(this.iconId);
    if (icon) {
        delete icon.dataset.openByClick;
    }

    if (this.dom.domObject) {
        this.dom.domObject.setAttribute('data-forced', delayed || "true");
    }


    if (!this.isVisible) {
        return;
    }
    if (this.dom.domObject) {
        this.dom.domObject.setAttribute('data-hidden', 'true');
    }
    this.isVisible = false;
};

GUI.BasePanel.close = function () {
    var id = XDOM.GLOBAL.getAttribute("data-eventarg-id");
    GUI.BasePanel.instances[id].close();
};

GUI.BasePanel.startDragging = function (e, id) {
    if (BrowserDetect.isIE || BrowserDetect.isSafari) {
        return;
    }

    var foEvent = XDOM.getEvent(e);
    var id = XDOM.GLOBAL.getAttribute("data-eventarg-id");
    if (foEvent.srcElement.id == "MEXIT") {
        return;
    }
    var foInstance = GUI.BasePanel.instances[id];
    Dragger.guiObject = foInstance;
    Dragger.domObject = foInstance.dom.domObject;
    GLOBAL.mouseKeyDown = true;
    Dragger.start(e);
};

GUI.BasePanel.prototype.getGuiObject = function (idIn) {
    var id = idIn.id || idIn;
    return this.guiObjects[id];
};
GUI.BasePanel.screenMode = {'modal': '*MODAL', 'subview': '*SUBVIEW'};


/* PanelHeader */
/* Load Timestamp 13:59:55.650 */
/**
 * GUI.Header ten behoeven van GUI.Panel
 */
GUI.PanelHeader = function(definition,panel){
    this.panel = panel;
    this.titleVariable = null;

    if(definition.titleOrigin=="*VAR"){
        //set titleVariable to indicate this is a variable title and where to find the text
        this.titleVariable = definition.titleVariable;
        this.title = panel.data[definition.titleVariable]
    } else{
        this.title = this.panel.captions.get(definition.title)
    }
};
/**
 * update caption for the panel header
 */
GUI.PanelHeader.prototype.update = function(){
    if(this.titleVariable){ //only when titleVariable is set other cases the header is inmutable
        //this.panel.dom.headerTitle.innerHTML = this.panel.data[this.titleVariable];
        this.panel.dom.headerTitle.childNodes[0].nodeValue = this.panel.data[this.titleVariable];
    }
}

/**
 * opbouwen vean header voor GUI.Panel
 */
GUI.PanelHeader.prototype.render = function(){
    var dom = this.panel.dom;
    var fsId = this.panel.panelId;

//opbouw elementen
    var fsDraggClass = ' dragable';
    var fsIconClass = '';
    if(BrowserDetect.isIE || BrowserDetect.isSafari || this.panel.screenMode == GUI.BasePanel.screenMode.subview){
        fsDraggClass = ''; // wordt niet ondersteund door ie
    }
    dom.header  = XDOM.createElement('DIV', fsId + "-header", "panelHeader theme-background-color" + fsDraggClass);
    dom.headerTitle = XDOM.createElement('DIV',null,"panelTitle");
    dom.headerTitleText = XDOM.createTextNode(this.title);

//opbouw dom boom
    dom.headerTitle.appendChild(dom.headerTitleText);

    if(this.panel.screenMode == GUI.BasePanel.screenMode.subview){
        if(this.panel.panelIconClass && this.panel.panelIconClass != ""){
            dom.headerTitleIcon = XDOM.createElement('i',null,'panelHeaderIcon '+ getFontPrefix(this.panel.panelIconGroup)+this.panel.panelIconClass);
            dom.header.appendChild(dom.headerTitleIcon);
        }
    }

    dom.header.appendChild(dom.headerTitle);

    if(this.panel.screenMode != GUI.BasePanel.screenMode.subview){
        //dom.exitIcon = XDOM.createElement('DIV','MEXIT','popup-close');
        dom.exitIcon = XDOM.createElement('i','MEXIT','popup-close pth-icon');

        dom.headerTitle.appendChild(dom.exitIcon);
        dom.exitIcon.setAttribute("data-click-action","GUI.BasePanel.close");
        dom.exitIcon.setAttribute("aria-hidden","true");
        dom.exitIcon.setAttribute("data-eventarg-id",this.panel.panelId);

        //adding drag event handlers
        dom.header.setAttribute("data-eventarg-id",this.panel.panelId);
        dom.header.setAttribute("data-mouseDown-action", "Dragger.start");
        dom.header.setAttribute("data-dragger-objId", this.panel.dom.domObject.id);
        dom.headerTitle.setAttribute("data-eventarg-id",this.panel.panelId);
        dom.headerTitle.setAttribute("data-mouseDown-action", "Dragger.start");
        dom.headerTitle.setAttribute("data-dragger-objId", this.panel.dom.domObject.id);


    }

    dom.domObject.appendChild(this.panel.dom.header);

//registreren van events

};

GUI.PanelHeader.prototype.setInfoTitle = function(){


};
/* InfoWindow */
/* Load Timestamp 13:59:55.651 */
GUI.InfoWindow = function(obj) {
    GUI.InfoWindow.baseConstructor.call(this);
    this.id = obj.getAttribute('data-info-id');
    this.iconId = obj.id;
    this.recordNumber = obj.getAttribute('data-record-number');
    this.screenMode = obj.getAttribute('data-screen-mode');
    this.triggerFields = obj.getAttribute('data-trigger-fields') + ' ' + obj.getAttribute('data-trigger-macros');
    this.environmentConditions  = obj.dataset.environmentConditions;
    this.requestFieldsArray = eval(obj.getAttribute('data-parm-object'));
    this.requestPrefix = obj.getAttribute('data-parm-prefix') || '';
    this.sourceLocation = obj.getAttribute('data-macro-location');
    this.macroName = obj.getAttribute('data-macro-name');
    this.fieldProgressionPartId = null;
    this.cssClass = 'info-panel popup-panel';
    this.openDelay = 300; // miliseconde waarna een infowindow opent door een hover op een input;
    this.closeDelay = 500; // miliseconde waarna een infowindow opent door een hover op een input;
    this.applyToRow = '*ALL';
    this.baseRequest = '';
    this.objectCount = '';
    this.dataOnly = false;
    this.eventsRegistered = false;
    this.timer = null;
    this.closeTimer = null;
    this.hovering = false;
    //this.openByHover = false;
    //this.requiredReturnFields = null;
    this.requiredOutputFields = '';
    this.requiredOutputBooleans = '';
    this.inSubfile = false;
    this.cellAxis = null;
    this.indicatorAxis = null;
    this.authorizationFields = null;
    this.condHiddenLines = [];

    this.panelBackgroundColor = '';
    this.panelIconGroup = 'fontAwesome';
    this.panelIconClass = '';

    this.panelId = 'p-' + this.iconId;

    //dubbele aanpassing waardoor infowindows niet meer worden gesloten.
    //if(this.recordNumber){
    //this.panelId += '-' + this.recordNumber;
    //}

    // if(GUI.BasePanel.instances[this.panelId]){
    // 	this.panelId = this.panelId+'_'+Object.keys(GUI.BasePanel.instances).length.toString();
    // }

    // obj.setAttribute('data-panel-id', this.panelId);
    //obj.setAttribute('data-panel-id-in-use', this.panelId);

    this.cacheKey = this.macroName + '-' + this.sourceLocation; // alle info windows met de zelfde macroName en sourceLocation
    // hebben de zelfde layout en hoeven daarom maar 1 keer gerenderd
    // worden
    if (this.triggerFields) {
        this.triggerFields = this.triggerFields.split(' ');
    } else {
        this.triggerFields = [];
    }
    GUI.BasePanel.instances[this.panelId] = this;
};

XDOM.extendObject(GUI.InfoWindow, GUI.BasePanel);
GUI.InfoWindow.renderCache = {};
GUI.InfoWindow.configCache = {};

GUI.InfoWindow.getWindow = function(obj) {
    var infoWindow = XDOM.getEditWindow('p-' + obj.id);
    if (infoWindow) {
        return infoWindow;
    }
    return new GUI.InfoWindow(obj);
};

GUI.InfoWindow.prototype.init = function() {
    let promise
    this.renderIcon();
    this.registerTrigger();
    if (this.screenMode === GUI.BasePanel.screenMode.subview) {
        promise = this.iniEmbed();
    } else {
        if (this.inSubfile) {
            this.registerSFLEvents();
        } else {
            this.registerEvents();
        }
    }
    GUI.BasePanel.instances[this.panelId] = this;
    return promise;
};

GUI.InfoWindow.prototype.registerTrigger = function() {
    var foThis = this;
    for (var i = 0, l = this.triggerFields.length; i < l; i++) {
        var invoker = this.triggerFields[i]; //var binnen scope in verband met doorgeven by value niet byref(pointer)
        const desc =   `edit or info window: ${this.macroName} is triggered by field change`;
        Trigger.register(invoker, 'panel' + this.id, 'GUI.InfoWindow.openByTrigger' + this.id, function() {
            GUI.InfoWindow.openByTrigger(foThis);
        }, desc);
    }
};

/**
 * sluit eventueel open quicksearch scherm en opent quickSearch
 * @param {type} FoInfoWindow
 * @returns {undefined}
 */
GUI.InfoWindow.openByTrigger = function(FoInfoWindow) {
    FoInfoWindow.request();
};
GUI.InfoWindow.prototype.checkRendered = function(){
    const body  = XDOM.getObject(this.iconId).parentNode.querySelector('.panelBody');
    if(body) { //excluding the meta div
        return;
    }
    if(this.dom.domObject){
        this.dom.domObject.remove();
        this.dom.domObject = null;
    }
    this.isInitialised = false;

}

GUI.InfoWindow.prototype.iniEmbed = function() {
    this.checkRendered();
    if (this.isInitialised) {
        this.dataOnly = true;
        return this.request();

    }

    this.clearCache();
    this.isVisible = false;
    if (!this.dom.icon) {
        this.cssClass = 'info-panel';
    }

    return this.request();
};

GUI.InfoWindow.prototype.clearCache = function() {
    GUI.InfoWindow.configCache[this.cacheKey] = null;
    GUI.InfoWindow.renderCache[this.cacheKey] = null;
    this.isInitialised = false;
    this.dataOnly = false;
};

GUI.InfoWindow.prototype.renderIcon = function(recordNumber) {
    var foObj = null,
        foIcon = null;
    var foTd = XDOM.getAxis(this.cellAxis, recordNumber);
    if (
        !foTd ||
        !(this.applyToRow === '*ALL' || isIn(recordNumber, this.applyToRow)) ||
        this.screenMode === GUI.BasePanel.screenMode.subview
    ) {
        return;
    }

    foIcon = XDOM.createElement('DIV', null, 'infoProgram');
    foTd.appendChild(foIcon);

    foIcon.setAttribute('data-panel-id', this.panelId);
    foIcon.setAttribute('data-record-number', recordNumber);
    foIcon.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
    foIcon.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
    foIcon.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');

    for (var a in foTd.childNodes) {
        foObj = foTd.childNodes[a];
        if (foObj.id) {
            XDOM.setAttribute(foObj, 'data-panel-id', this.panelId);
            XDOM.setAttribute(foObj, 'data-record-number', recordNumber);
            foObj.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
            foObj.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
        }
    }
};

GUI.InfoWindow.handleClick = function(e) {
    XDOM.cancelEvent(e);
    var recordNr = XDOM.GLOBAL.getAttribute('data-record-number');
    var foPanel = GUI.InfoWindow.getWindow(GLOBAL.eventSourceElement);
    GLOBAL.eventSourceElement.dataset.openByClick = true;
    // 3 times the king!
    if (foPanel?.dom?.domObject?.getAttribute('data-hidden')!='true') {
        return;
    }

    foPanel.close();
    foPanel.recordNumber = recordNr;
    foPanel.dom.icon = GLOBAL.eventSourceElement;

    foPanel.open();
    return false;
};

GUI.InfoWindow.handleMouseOver = function(e) {
    XDOM.getEvent(e);
    var foPanel = GUI.InfoWindow.getWindow(GLOBAL.eventSourceElement);
    foPanel.close();
    foPanel.dom.icon = GLOBAL.eventSourceElement;
    foPanel.handleMouseOver();
};

GUI.InfoWindow.handleMouseOut = function(e) {
    XDOM.getEvent(e);

    let foPanel = GUI.BasePanel.instances['p-' + GLOBAL.eventSourceElement.id];
    //var foPanel = GUI.InfoWindow.getWindow(GLOBAL.eventSourceElement);
    if (foPanel) {
        foPanel.handleMouseOut();
    }
};

GUI.InfoWindow.handlePanelClick = function() {
    let id = XDOM.GLOBAL.getAttribute('data-eventarg-id');
    let icon = XDOM.getObject(GUI.BasePanel.instances[id].iconId);
    icon.dataset.openByClick = true;

    //GUI.BasePanel.instances[id].openByHover = false;
};

GUI.InfoWindow.prototype.handleMouseOut = function() {
    this.hovering = false;
    let icon = XDOM.getObject(this.iconId);
    if (icon.dataset.openByClick == 'true') {
        return;
    }
    var fsCommand = "GUI.InfoWindow.closeDelayed('" + this.panelId + "')";
    this.closeTimer = setTimeout(fsCommand, this.closeDelay);
    this.cancelDelayedOpen();
};

GUI.InfoWindow.prototype.handleMouseOver = function() {
    var fsCommand = "GUI.InfoWindow.openDelayed('" + this.panelId + "')";
    this.hovering = true;
    GUI.BasePanel.instances[this.panelId] = this;
    this.timer = setTimeout(fsCommand, this.openDelay);
};

GUI.InfoWindow.closeDelayed = function(id) {
    let instance = GUI.BasePanel.instances[id];
    let icon = XDOM.getObject(instance.iconId);
    if (icon.dataset.openByClick != 'true') {
        instance.close('false');
    }
};

GUI.InfoWindow.openDelayed = function(id) {
    if (this.isVisible) {
        return;
    } // -->
    var instance = GUI.BasePanel.instances[id];
    if (instance.hovering) {
        //instance.openByHover = true;
        instance.request();
    }
};

GUI.InfoWindow.prototype.cancelDelayedOpen = function() {
    clearTimeout(this.timer);
    this.timer = null;
};



GUI.InfoWindow.prototype.open = function() {
    //this.openByHover = false;
    let icon = XDOM.getObject(this.iconId);
    icon.dataset.openByClick = 'true';

    if (this.isVisible) {
        return;
    } // -->
    this.cancelDelayedOpen();
    this.request();
};


/**
 * verkrijgt data
 * voor stateless pannels en statefull pannels is dit SESSION.activeData
 * maar voor aanroepen vanuit edit en info window gaat dit via de panel.data Gui
 */
GUI.InfoWindow.prototype.getPanelData = function() {
    let panelId = XDOM.getAttribute(this.iconId, 'data-panel-id'),
        panel = XDOM.getEditWindow(panelId);

    if (panel && panel.data) {
        return { headerData: panel.data };
    }
    return SESSION.activeData;
};

GUI.InfoWindow.prototype.buildParameterString = function() {
    var foField = null;
    var fsValue = '';
    var fsLocation = null;
    var constValue = null;
    var fsRequestUri = '&PRMLEN=' + this.requestFieldsArray.length;
    var fiRecordNr = null;
    var fieldObjName = '';
    var data = this.getPanelData();

    this.hasParams = false;

    for (var i = 0; i < this.requestFieldsArray.length; i++) {
        fieldObjName = this.requestPrefix + this.requestFieldsArray[i].field;
        fsRequestUri += '&PRM' + (i + 1) + '=';
        fsLocation = this.requestFieldsArray[i].location;
        foField = XDOM.getObject(fieldObjName);
        fiRecordNr = null;
        fsValue = '';

        if (!foField || (foField && foField.tagName !== 'INPUT')) {
            switch (fsLocation) {
                case 'headerData':
                    fsValue = encodeURIComponent(data.headerData[this.requestFieldsArray[i].field]);
                    break;
                case 'subfileData':
                    fiRecordNr = parseInt(this.recordNumber) - 1; //array begint bij 0 en recordnummer bij 1
                    if (fiRecordNr >= 0) {
                        foField = XDOM.getObject(fieldObjName + '_' + this.recordNumber);
                        if (!foField || (foField && foField.tagName !== 'INPUT')) {
                            fsValue = encodeURIComponent(data.subfileData[fiRecordNr][this.requestFieldsArray[i].field]);
                        }
                    }
                    break;
                case 'directValue':
                    fsValue = encodeURIComponent(this.requestFieldsArray[i].value);
                    break;
                default:
                    if(foField){
                        constValue = foField.getAttribute('data-const-value');
                        if (constValue) {
                            fsValue = constValue;
                        }
                    }
                    break;
            }
        }

        if (!foField) {
            foField = XDOM.getObject('trigger_' + fieldObjName);
        }

        if (foField) {
            if (foField === this.target) {
                fsValue = encodeURIComponent(this.selectionRequest);
            } else {
                if (!Validate.test(foField)) {
                    return 'invalid';
                }
                fsValue = encodeURIComponent(XDOM.getObjectValue(foField));
            }
        }

        if (fsValue) {
            this.hasParams = true;
        } else {
            fsValue = '';
        }
        fsRequestUri += fsValue;
    }
    return fsRequestUri;
};

GUI.InfoWindow.prototype.request = function() {
    GUI.InfoWindow.closeByMacroId(this.panelId);
    if (!this.useCache) {
        this.clearCache();
    }
    var fbAskLayout = !this.isInitialised;
    var fsrequestParams = this.buildParameterString();
    var fsrequiredString = '';
    var fsRequestUri =
        '/ndscgi/' +
        this.sourceLocation +
        '/ndmctl/' +
        this.macroName +
        '.ndm/JSON?PFMSOMTD=' +
        PFMBOX.PFMSOMTD +
        '&PFMFILID=' +
        PFMBOX.sPFMFILID +
        '&USRID=' +
        PFMBOX.PFMRMTUS +
        '&AUTHTOKEN=' +
        SESSION.AUTHTOKEN +
        fsrequestParams;

    if(this.environmentConditions){
        fsRequestUri +=  '&EnvConditions='+ encodeURIComponent(this.environmentConditions) ;
    }
    this.baseRequest = fsRequestUri;

    if (fbAskLayout && GUI.InfoWindow.configCache[this.cacheKey]) {
        fbAskLayout = false;
    }
    GUI.BasePanel.instances[this.panelId] = this;

    if (!this.hasParams && !fbAskLayout && !this.dataOnly) {
        // geen data nodig
        fsRequestUri += '&CONFIG=data';
    } else {
        // wel data nodig
        if (fbAskLayout) {
            // data en config nodig
            fsRequestUri += '&CONFIG=all';
        } else {
            // geen config nodig
            fsrequiredString = this.returnRequiredString();
            fsRequestUri += '&CONFIG=data' + fsrequiredString;
        }
    }
    let icon = XDOM.getObject(this.iconId);
    icon.dataset.isLoading == 'true';

    const promise = fetch(fsRequestUri)
        .then(response=>response.json())
        .then(json=> {
            GUI.InfoWindow.handleResponse(json,{ id: this.panelId, invoke: '*EXTERNAL' })
        })
    return promise;
};

/**
 * return required fields
 */
GUI.InfoWindow.prototype.returnRequiredString = function() {
    //var requiredReturnFields = this.requiredReturnFields;
    var requiredReturnFields = GUI.InfoWindow.configCache[this.cacheKey].requiredData;

    var requireSting = '';

    for (var value in requiredReturnFields) {
        requireSting += '&' + value.toString() + '=';
        requireSting += encodeURIComponent(requiredReturnFields[value]);
    }

    return requireSting;
};

/**
 * renderd het info window.
 */
GUI.InfoWindow.prototype.render = function() {
    //var fsId = this.panelId;
    if (!this.useCache && this.dom.domObject) {//	POM-4281
        this.dom.domObject.remove();
        this.dom.domObject = null;
    }

    if (this.screenMode === GUI.BasePanel.screenMode.subview) {
        this.setSize = false;
        this.placeHolder = XDOM.getObject(this.iconId)?.parentNode;
        if(!this.placeHolder){
            //this one is removed by field authorisation so don't bother
            return;
        }
        this.placeHolder.setAttribute('data-screen-mode', GUI.BasePanel.screenMode.subview);

        this.panelBackgroundColor = this.placeHolder.parentNode.getAttribute('data-fieldset-background-color');
        this.panelIconGroup = this.placeHolder.parentNode.getAttribute('data-fieldset-icon-group');
        this.panelIconClass = this.placeHolder.parentNode.getAttribute('data-fieldset-icon-class');
        this.fieldProgressionPartId = this.placeHolder.parentNode.getAttribute('fieldPprogression-part');
        if (this.dataSet) {
            this.repositionElements();
        }
    } else {
        this.fieldProgressionPartId = this.panelId;
        this.placeHolder = XDOM.getObject('DTADIV');
    }

    this.base(GUI.InfoWindow, 'render');

    if (this.inSubfile) {
        this.placeHolder.insertBefore(this.dom.domObject, this.placeHolder.firstChild);
    } else {
        this.placeHolder.appendChild(this.dom.domObject);
    }

    GUI.InfoWindow.renderCache[this.cacheKey] = this.dom.domObject;
    this.dom.domObject.setAttribute('data-click-action', 'GUI.InfoWindow.handlePanelClick');
    this.dom.domObject.setAttribute('data-eventarg-id', this.panelId);
    this.dom.domObject.setAttribute('data-update-dom-depth', 'true');

    updatePanelSort(this.dom.domObject);

    XDOM.addEventListenerToNode('[data-focus-action]', 'focus', handleFocus, this.dom.domObject);
    XDOM.addEventListenerToNode('[data-blur-action]', 'blur', handleBlur, this.dom.domObject);
    XDOM.addEventListenerToNode('[data-mouseover-action]', 'mouseover', handleMouseOver, this.dom.domObject);
    XDOM.addEventListenerToNode('[data-mouseout-action]', 'mouseout', handleMouseOut, this.dom.domObject);
    this.alignPanel();
    this.isVisible = true;
};

GUI.InfoWindow.prototype.show = function() {
    if (this.screenMode == GUI.BasePanel.screenMode.subview) {
        //RKR ~ Return als het om een subview gaat. Het object staat er al dus hoeft niet getoond te worden.
        //Dit is aangepast omdat bij Bieman berichten niet werden getoond in een editwindow.
        return;
        //this.placeHolder = XDOM.getObject(this.iconId).parentNode;
    } else {
        this.placeHolder = XDOM.getObject('DTADIV');
    }

    if (this.inSubfile) {
        this.placeHolder.insertBefore(this.dom.domObject, this.placeHolder.firstChild);
    } else {
        this.placeHolder.appendChild(this.dom.domObject);
        this.dom.domObject.setAttribute('data-hidden', 'false');
        this.alignPanel();
    }

    updatePanelSort(this.dom.domObject);

    this.base(GUI.InfoWindow, 'show');
};

GUI.InfoWindow.closeByMacroId = function(macro) {
    for (var id in GUI.BasePanel.instances) {
        if (GUI.BasePanel.instances[id].macroName === macro) {
            GUI.BasePanel.instances[id].close();
        }
    }
};

GUI.InfoWindow.prototype.onResponse = function(response) {
    this.data = response.data;
    this.subfileData = nullWhenEmpty(response.subfileData);
    var foConfig = GUI.InfoWindow.configCache[this.cacheKey];
    var position = null,
        icon = 0;
    if (this.dom.icon) {
        icon = XDOM.getObject(this.dom.icon.id);
        if (!icon) {
            this.close(); //aanroepend element is niet meer in het scherm te zien
        }
    }

    if (!this.isInitialised) {
        if (!foConfig) {

            GUI.InfoWindow.configCache[this.cacheKey] = response.config;
            foConfig = response.config;
        }

        this.condHiddenLines = foConfig.condHiddenLines;
        this.definition = foConfig.panelDef;
        this.authorizationFields = foConfig.authorizationData;
        this.captions = new Captions(foConfig);
        this.services = new GUI.Services(foConfig);
        this.base(GUI.InfoWindow, 'init');

        //if (this.openByHover && !this.hovering) {
        //	return;
        //}

        this.render();
    } else {
        if (!this.dom.domObject && GUI.InfoWindow.renderCache[this.cacheKey]) {
            this.dom.domObject = GUI.InfoWindow.renderCache[this.cacheKey];
        }
        if (this.dom.domObject) {
            this.show();
            this.update();
        } else {
            this.render();
        }
    }

    if (response && response.basicConfig) {
        var titleText =
            getCapt('cTX_SSN') + ': ' + response.basicConfig.jobNbr + ' \x0A' + getCapt('cTX_PGM') + ': ' + response.basicConfig.macroId;
        GUI.infoTitle.register(this.dom.header, titleText);
    }

    When.update(this.dom, this.data);
    Lines.guiUpdate(this);
};

GUI.InfoWindow.handleResponse = function(response, tag) {
    var foWindow = GUI.BasePanel.instances[tag.id];
    let icon = XDOM.getObject(foWindow.iconId);

    if (!foWindow) {
        return;
    } // -->
    // if (response.responseText.startsWith('Fout')) {
    //   SCOPE.main.Dialogue.alert('GUI.InfoWindow.handleResponse: ' + response.responseText);
    // } else {
    foWindow.invoke = tag.invoke;
    foWindow.onResponse(response);
    // }
};

GUI.InfoWindow.prototype.registerEvents = function() {
    if (this.eventsRegistered) {
        return;
    }
    var foOutput = XDOM.getObject(this.id);
    if (!this.dom.icon) {
        this.dom.icon = XDOM.getObject(this.iconId);
    }
    if (this.dom.icon) {
        XDOM.setAttribute(this.dom.icon, 'data-panel-id', this.panelId);
        this.dom.icon.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
        this.dom.icon.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
        this.dom.icon.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
    }

    if (foOutput.tagName === 'INPUT') {
        return;
    }
    foOutput.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
    foOutput.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
    foOutput.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
    foOutput.setAttribute('data-panel-id', this.panelId);
};


GUI.InfoWindow.updateDom = function() {
    const prommises = [];
    var pageObjects = XDOM.queryAll('[data-info-id]');
    var obj = null;
    var infoWindow = null;
    var screenMode = '';
    for (var i = 0, l = pageObjects.length; i < l; i++) {
        obj = pageObjects[i];
        if(obj.dataset.when=="unavailable"){
            continue; //not visable because of when construction
        }
        screenMode = obj.getAttribute('data-screen-mode');
        if (screenMode !== GUI.BasePanel.screenMode.subview) {
            obj.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
            obj.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
            obj.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
        }
        setSubviewNoMargin(obj, screenMode);
        if (screenMode === GUI.BasePanel.screenMode.subview || obj.getAttribute('data-trigger-fields')) {
            infoWindow = GUI.InfoWindow.getWindow(obj);
            prommises.push(infoWindow.init());
        }
    }
    return prommises;
};

GUI.InfoWindow.register = function(id, iconId, attributes) {
    var foOutput = XDOM.getObject(id);
    var foIcon = XDOM.getObject(iconId);

    if (foIcon) {
        XDOM.setAttributes(foIcon, attributes);
        foIcon.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
        foIcon.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
        foIcon.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
    }
    foOutput.setAttribute('data-mouseover-action', 'GUI.InfoWindow.handleMouseOver');
    foOutput.setAttribute('data-mouseout-action', 'GUI.InfoWindow.handleMouseOut');
    foOutput.setAttribute('data-click-action', 'GUI.InfoWindow.handleClick');
    XDOM.setAttributes(foOutput, attributes);
};

/* EditWindow */
/* Load Timestamp 13:59:55.651 */
var EDITPGM = {};


GUI.EditWindow = function (obj) {
    GUI.EditWindow.baseConstructor.call(this, obj);
    this.id = obj.getAttribute("data-edit-id");
    this.toId = obj.getAttribute('data-to-id') || '';
    this.windowType = "edit";
    this.message = '';
    //this.fieldProgression = new GUI.fieldProgression();
};

XDOM.extendObject(GUI.EditWindow, GUI.InfoWindow);


GUI.EditWindow.openInstance = null;


GUI.EditWindow.prototype.open = function () {
    if (this.screenMode != GUI.BasePanel.screenMode.subview) {
        if (GUI.EditWindow.openInstance) {
            GUI.EditWindow.openInstance.close();
        }
        GUI.EditWindow.openInstance = this;
    }
    this.base(GUI.EditWindow, 'open');
};

GUI.EditWindow.prototype.close = function () {
    if (this.screenMode != GUI.BasePanel.screenMode.subview && GUI.EditWindow.openInstance) {
        if (GUI.EditWindow.openInstance.id == this.id) {
            GUI.EditWindow.openInstance = null;
        }
    }
    this.base(GUI.EditWindow, 'close');
};

GUI.EditWindow.updateDom = function () {
    const promises = [];
    var pageObjects = XDOM.queryAll('[data-edit-id]');
    var obj = null;
    for (var i = 0, l = pageObjects.length; i < l; i++) {
        obj = pageObjects[i];
        screenMode = obj.getAttribute("data-screen-mode");
        if (screenMode != GUI.BasePanel.screenMode.subview) {
            obj.setAttribute("data-click-action", "GUI.EditWindow.handleClick");
        }
        setSubviewNoMargin(obj, screenMode);
        if (screenMode == GUI.BasePanel.screenMode.subview || obj.getAttribute("data-trigger-fields")) {
            let editWindow = GUI.EditWindow.getWindow(obj);
            promises.push(editWindow.init());
        }

    }
    return promises;
};

GUI.EditWindow.register = function (id, iconId, attributes) {
    var foOutput = XDOM.getObject(id);
    var foIcon = XDOM.getObject(iconId);

    if (foIcon) {
        XDOM.setAttributes(foIcon, attributes);
        foIcon.setAttribute("data-click-action", "GUI.EditWindow.handleClick");
    }
    foOutput.setAttribute("data-click-action", "GUI.EditWindow.handleClick");
    XDOM.setAttributes(foOutput, attributes);
};

GUI.EditWindow.prototype.validateField = function (obj) {
    return Validate.test(obj);
    //return true;
};

GUI.EditWindow.prototype.validate = function (foFLD) {
    var fsValue = foFLD.value;
    var fsDatatype = XDOM.getAttribute(foFLD, "data-datatype");
    var regEx = null,
        fKAR = null,
        fPOS = null;

    if (foFLD.tagName == "TEXTAREA") {
        return TextArea.validate(foFLD);
        var fiTextLength = TextArea.getLength(foFLD);
        var fiMaxLength = foFLD.maxLength;
        if (fiTextLength > fiMaxLength) {
            this.message = getCapt('gTXTAREAMAX1') + fiMaxLength + getCapt('gTXTAREAMAX4');
            return false;
        }
        return true;
    }
    // gedeeltelijke veld van een masker
    if (Mask.isMask(foFLD)) {
        if (!Mask.isValidPart(foFLD)) {
            this.message = Mask.getErrorMessage(foFLD);
            return false;
        } else {
            return true;
        }
    }

    switch (fsDatatype) {
        case ENUM.dataType.hidden:
            return true;
            break;
        case ENUM.dataType.decimal:
            var foValueCheck = new ValueCheck(foFLD);
            if (!foValueCheck.test()) {
                this.message = foValueCheck.message;
                return false;
            } else {
                if (foFLD.value.trim() == '-') {
                    foFLD.value = '';
                }
            }
            return true;
            break;
        case ENUM.dataType.data:
            regEx = gaREGEXP['*DTA'];
            //controleer op voorloop spaties
            if (!XDOM.getBooleanAttribute(foFLD, "data-left-blank") && fsValue.trim().length > 0 && fsValue.indexOf(' ') == 0) {
                this.message = getCapt('gVLD008');
                return false;
            }
        case ENUM.dataType.text:
        case ENUM.dataType.password:
            //digits

            if (XDOM.getBooleanAttribute(foFLD, "data-digits")) {
                regEx = gaREGEXP['*DIG'];
                if (!regEx.test(fsValue)) {
                    this.message = getCapt('gVLD007');
                    return false;
                }
                return true;
            }

            regEx = gaREGEXP['*TXT'];
            //gewoon
            if (regEx.test(fsValue)) {
                fKAR = fsValue.substring(fPOS, fPOS + 1);
                if (fPOS < fsValue.length) {
                    fsValue = fsValue.substr(fPOS + 1);
                }
                this.message = getCapt('gVLD003') + fKAR;
                return false;
            }
            break;
    }
    return true;
};

GUI.EditWindow.prototype.getData = function () {
    //haal alle velden op van de bij dit window hoordende data
    var request = '', name, value, field = null;
    var fields = XDOM.queryAll("[data-panel-id='" + this.panelId + "']");
    for (var i = 0, l = fields.length; i < l; i++) {
        field = fields[i];
        if (!Validate.test(field)) {
            XDOM.setAttribute(field, "data-old-value", field.value);
            return false;
        }


        if (field.name) {
            name = field.name.replace(this.panelId + '-', '');

            if (name) {

                if (field.getAttribute("data-unicode") == "true") {
                    value = XDOM.hexEncode(field.value);
                } else {
                    value = encodeURIComponent(field.value);
                }


                if (field.getAttribute("data-thousand-separator") == "on") {
                    value = unformatThousand(value);
                }


                request += '&' + name + '=' + value;
            }
        }
    }

    return request;
};

/**
 * controleerd alle input velden en bundelt deze in een form data component
 * @param command RESET || ENTER:autosubmit || ACCEPT:enter toets ingedrukt of klikken op enter(save toets) waarde commd in het WS_CMD veld
 * @param prompt waarde van het laatste gefocusde veld t.b.v. het  WS_PMT veld
 */
GUI.EditWindow.prototype.send = function (command, prompt) {

    var fsRequestData = this.getData();
    if (fsRequestData === false) {
        return;
    }
    Stateless.setSubviewActive(GLOBAL.eventSourceElement);
    var foRequest = new XMLHttpRequest();
    foRequest.addEventListener('load', GUI.EditWindow.handleResponse);
    foRequest.addEventListener('error', function (event) {
        console.log('fout opgetreden in GUI.EditWindow.send');
    });


    //var fsRequestUri =   this.baseRequest +   '/ndscgi/' + this.sourceLocation + '/ndmctl/' + this.macroName + '.ndm/JSON?' + fsRequestData;
    var fsRequestUri = this.baseRequest + fsRequestData;

    fsRequestUri += '&WS_CMD=' + command;
    fsRequestUri += '&WS_PMT=' + prompt;
    fsRequestUri += '&invoker=' + this.panelId;
    fsRequestUri += '&CONFIG=';

    if (!this.useCache) {
        this.clearCache();
        fsRequestUri += 'all';
    } else {
        fsRequestUri += 'data';
    }

    if (GUI.InfoWindow.configCache[this.cacheKey]) {
        for (var value in GUI.InfoWindow.configCache[this.cacheKey].requiredData) {
            fsRequestUri += "&" + value.toString() + "=";
            fsRequestUri += GUI.InfoWindow.configCache[this.cacheKey].requiredData[value];
        }
    }

    setSubviewLoading(this.dom.domObject, true);
    foRequest.open('GET', fsRequestUri);
    foRequest.send();
};


GUI.EditWindow.prototype.update = function () {
    this.base(GUI.EditWindow, 'update');
    if (this.data.WS_RTN === "OK") {

        if (autoSubmit(this.iconId)) {
            return;
        }

        Trigger.fire([this.macroName]);
        if (this.screenMode != GUI.BasePanel.screenMode.subview) {
            setTimeout("GUI.EditWindow.openInstance.close()", 2000);
            //this.close();
        }
    }

    this.updateMessage();

    if (this.data && (this.data.WS_CSR != undefined)) {
        this.setCursor(this.data.WS_CSR);
    }
};

GUI.EditWindow.prototype.updateMessage = function () {
    if (this.data && ((this.data.WS_MGL != undefined) && (this.data.WS_MSG != undefined))) {
        this.footer.setMessage(this.data.WS_MGL, this.data.WS_MSG);
    }
}

GUI.EditWindow.handleResponse = function (response) {
    var fsResponse = response.target.responseText;
    var foResponse = JSON.parse(fsResponse);
    var invoker = foResponse.basicConfig.invoker;
    var foWindow = GUI.BasePanel.instances[invoker];

    if (!foWindow) {
        return;
    } // -->
    if (fsResponse.startsWith('Fout')) {
        SCOPE.main.Dialogue.alert('GUI.EditWindow.handleResponse fout: ' + response.responseText);
    } else {
        if (foResponse.data.WS_RTN == 'OK') {
            if (isAutoSubmitField(foWindow.toId)) {
                Command.enter();
                return;
            }
            Trigger.fire([foWindow.macroName]);
        }
        foWindow.onResponse(foResponse);
    }
};


GUI.EditWindow.prototype.setCursor = function (csrField) {
    var cursorFieldId = this.panelId + "-" + csrField;
    var cursorField = XDOM.getObject(cursorFieldId, this.dom.domObject);

    setSubviewLoading(this.dom.domObject, false);
    setCursorFromStateless();

    if (!cursorField) {
        return;
    }
    if (!Stateless.canHaveFocus(cursorField)) {
        return;
    }

    SESSION.activePage.cursorFocus = cursorField;
    setCursor();
    return;
};

GUI.EditWindow.handleReset = function (e) {
    XDOM.getEvent(e);
    var foEdit = XDOM.GLOBAL.getEditWindow();
    SESSION.submitFromScope = XDOM.GLOBAL.getAttribute('data-for-panel');
    foEdit.send('RESET', '');
};


GUI.EditWindow.handleSubmit = function (e) {
    XDOM.getEvent(e);
    var foEdit = XDOM.GLOBAL.getEditWindow();
    SESSION.submitFromScope = XDOM.GLOBAL.getAttribute('data-for-panel');
    foEdit.send('ACCEPT', '');
};


GUI.EditWindow.prototype.registerSFLEvents = function () {
    if (this.eventsRegistrated) {
        return;
    }

    if (!this.dom.icon) {
        this.dom.icon = XDOM.getObject(this.iconId);
    }
    if (this.dom.icon) {
        this.dom.icon.setAttribute("data-click-action", "GUI.EditWindow.handleClick");
    }
};

GUI.EditWindow.prototype.registerEvents = function () {
    var fsPanelId = this.panelId;
    if (this.eventsRegistrated) {
        return;
    }
    if (!this.dom.icon) {
        this.dom.icon = XDOM.getObject(this.iconId);
    }
    this.dom.icon.setAttribute("data-click-action", "GUI.EditWindow.handleClick");

};

GUI.EditWindow.prototype.renderIcon = function () {
};

GUI.EditWindow.handleClick = function (e) {
    XDOM.cancelEvent(e);
    var panel = GUI.EditWindow.getWindow(GLOBAL.eventSourceElement);
    panel.recordNumber = XDOM.GLOBAL.getAttribute("data-record-number");
    panel.dom.icon = GLOBAL.eventSourceElement;
    panel.open();

    return false;
};


GUI.EditWindow.getWindow = function (obj) {
    var foEditWindow = XDOM.getEditWindow('p-' + obj.id);
    if (foEditWindow) {
        return foEditWindow;
    }
    return new GUI.EditWindow(obj);
};


GUI.EditWindow.propagateSubfile = function (attributes, recordNr) {
    GUI.EditWindow.renderIcon(attributes, recordNr);
};

GUI.EditWindow.renderIcon = function (attributes, recordNumber) {
    var foIcon = null;
    var fsMacro = attributes['data-macro-name'];
    var foApplyToRow = attributes['data-edit-applyto'];
    var foTd = XDOM.getAxis(attributes['data-edit-cell-axis'], recordNumber);

    if (!foTd || !(foApplyToRow == '*ALL' || isIn(recordNumber, foApplyToRow))) {
        return;
    }

    attributes['data-panel-id'] = fsMacro + '-' + recordNumber;
    attributes['data-record-number'] = recordNumber;

    foIcon = XDOM.createElement("DIV", null, "editProgram");
    foTd.appendChild(foIcon);

    XDOM.setAttributes(foIcon, attributes);
    foIcon.setAttribute("data-click-action", "GUI.EditWindow.handleClick");
};
/* EditWindowFooter */
/* Load Timestamp 13:59:55.652 */
/**
 * Footer ten behoeven van editPanel
 */
GUI.EditWindowFooter = function(panel){
    GUI.EditWindowFooter.baseConstructor.call(this,{'type':'updateFooter','id':'updateFooter'});
    this.message = '';
    this.errorLevel = '';
    this.parentObject = panel;
};
XDOM.extendObject(GUI.EditWindowFooter, GUI.BaseObject);

/**
 * opbouwen van footer object
 */
GUI.EditWindowFooter.prototype.render = function(){

    // this.y = this.parentObject.definition.ySize - 3;

    this.dom.domObject  = XDOM.createElement('DIV', null,  this.parentObject.cssClass + "-footer  edit-panel-footer");
    this.dom.messageDiv  = XDOM.createElement('DIV', null,  "edit-window-message");
    this.dom.messagePlaceholder = XDOM.createElement('P');
    this.dom.messageDiv.appendChild(this.dom.messagePlaceholder);

    this.dom.domObject.appendChild(this.dom.messageDiv);
    this.dom.panelFooterButtonsPlaceHolder = XDOM.createElement('DIV', null,  "edit-window-buttons");
    //this.dom.pannelFooterButtons = XDOM.createElement('DIV', null,  "pannelFooterButtons");

    this.dom.domObject.appendChild(this.dom.panelFooterButtonsPlaceHolder);
    // this.dom.panelFooterButtonsPlaceHolder.appendChild(this.dom.pannelFooterButtons);

    this.dom.saveButton = XDOM.createElement('DIV', null,  "edit-save-icon pth-icon");
    this.dom.saveButton.setAttribute("data-for-panel", this.parentObject.panelId);
    this.dom.saveButton.setAttribute("data-click-action","GUI.EditWindow.handleSubmit");
    this.dom.panelFooterButtonsPlaceHolder.appendChild(this.dom.saveButton);
    this.dom.refreshButton = XDOM.createElement('DIV', null,  "edit-refresh-icon pth-icon");
    this.dom.refreshButton.setAttribute("data-for-panel", this.parentObject.panelId);
    this.dom.refreshButton.setAttribute("data-click-action","GUI.EditWindow.handleReset");
    this.dom.panelFooterButtonsPlaceHolder.appendChild(this.dom.refreshButton);
    this.updateState();

    return this.dom.domObject;
};

/**
 *
 */
GUI.EditWindowFooter.prototype.init = function(){};


/**
 * registratie van events en het zetten van een eventuele message
 */
GUI.EditWindowFooter.prototype.updateState = function(){
    // registreren van events

    if(this.message){
        this.dom.messagePlaceholder.innerHTML = this.message;
        this.dom.messageDiv.className = "edit-window-message " + ENUM.attentionLevelReverse[this.errorLevel];
        this.dom.messageDiv.setAttribute("data-message-level" , this.errorLevel);

    }else{
        this.dom.messagePlaceholder.innerHTML = '';
        this.dom.messageDiv.className = "empty-edit-window-message";
        this.dom.messageDiv.setAttribute("data-message-level" , null);


    }

};

GUI.EditWindowFooter.prototype.setMessage = function(errorLevel,message){
    this.errorLevel = errorLevel;
    this.message = message;
    this.updateState();
};

GUI.EditWindowFooter.prototype.clearMessage = function(message,errorLevel){
    this.errorLevel = '';
    this.message = '';
    this.updateState();
};
/* signature */
/* Load Timestamp 13:59:55.652 */
GUI.Signature = function(obj) {
    this.baseId = obj.id;
    this.dom = {};
    this.canvasWrapper = null;
    this.canvasObj = null;
    this.buttonsBar = null;
    this.clearButton = null;
    this.submitButton = null;
    this.isProtected = null;
    this.buttonsBarHeight = 25;
    this.hasDrawn = false;

    this.returnField = null;
    this.backgroundImage = null;

    this.dateField = null;
    this.timeField = null;
    this.cityField = null;
    this.nameField = null;

    this.conditionField = null;
    this.conditionAttribute = null;

    this.referenceLabel = null;
    this.referenceField = null;

    this.position = {
        xPos: obj.getAttribute('data-element-xpos'),
        yPos: obj.getAttribute('data-element-ypos')
    };
    this.dimentions = {
        width: obj.getAttribute('data-element-xsize'),
        height: obj.getAttribute('data-element-ysize')
    };
};

GUI.Signature.instances = [];
GUI.Signature.currentInstanceId = null;

GUI.Signature.Drawer = {
    isDrawing: false,
    canvasId: null,
    touchstart: function(coors, context) {
        context.beginPath();
        context.moveTo(coors.x, coors.y);
        this.isDrawing = true;
    },
    touchmove: function(coors, context, obj) {
        if (this.isDrawing) {
            context.lineTo(coors.x, coors.y);
            context.stroke();
            if (obj && obj.hasDrawn == false) {
                obj.hasDrawn = true;
            }
        }
    },
    touchend: function(coors, context) {
        if (this.isDrawing) {
            this.touchmove(coors, context);
            this.isDrawing = false;
        }
    },
    mousedown: function(coors, context) {
        context.beginPath();
        context.moveTo(coors.x, coors.y);
        this.isDrawing = true;
    },
    mousemove: function(coors, context, obj) {
        if (this.isDrawing) {
            context.lineTo(coors.x, coors.y);
            context.stroke();
            if (obj && obj.hasDrawn == false) {
                obj.hasDrawn = true;
            }
        }
    },
    mouseup: function(coors, context) {
        if (this.isDrawing) {
            this.mousemove(coors, context);
            this.isDrawing = false;
        }
    },
    mouseout: function(coors, context) {
        if (this.isDrawing) {
            this.mousemove(coors, context);
            this.isDrawing = false;
        }
    }
};

GUI.Signature.prototype.setVars = function() {
    var obj = XDOM.getObject(this.baseId);
    if (!obj) {
        return;
    }

    this.timeField = obj.getAttribute('data-signature-time')  || ''
    this.dateField =
        SESSION.activePage.headerData[obj.getAttribute('data-signature-date-field')] ||
        obj.getAttribute('data-signature-date')  || '';


    this.cityField =
        SESSION.activePage.headerData[obj.getAttribute('data-signature-city')] || '';

    this.nameField =
        SESSION.activePage.headerData[obj.getAttribute('data-signature-name')] || '';

    this.signatureUrl =
        SESSION.activePage.headerData[
            obj.getAttribute('data-signature-return-field')
            ] || '';

    this.conditionField =
        SESSION.activePage.headerData[obj.getAttribute('data-condition-field-id')] || '';

    this.conditionAttribute = obj.getAttribute('data-condition-attribute') || '';

    this.returnField = obj.getAttribute('data-signature-return-field')  || '';

    this.referenceLabel = getCaption(
        obj.getAttribute('data-signature-reference-label'), ''
    )
    this.referenceField =
        SESSION.activePage.headerData[
            obj.getAttribute('data-signature-reference-field')
            ] || '';

    this.isProtected = obj.getAttribute('data-protected');
    XDOM.createInputField(this.returnField , this.signatureUrl);
    return;
};

/**
 * voorbereiding van het dom object het zetten van event Handlers
 */
GUI.Signature.prepareDom = function() {
    var pageSignatureObjects = XDOM.queryAllScope('.signature-place-holder');
    var signatureObj = null;

    for (var i = 0, l = pageSignatureObjects.length; i < l; i++) {
        signatureObj = new GUI.Signature(pageSignatureObjects[i]);
        signatureObj.setDimentions();
        signatureObj.renderCanvas();
        signatureObj.renderButtons();
        signatureObj.setEvents();
        signatureObj.setBackground('#f2f2f2');

        signatureObj.prepareCanvas();
        signatureObj.disableButtons();
        GUI.Signature.instances[pageSignatureObjects[i].id] = signatureObj;
    }
};


GUI.Signature.prototype.setEvents = function() {
    if ('ontouchstart' in window) {
        // navigator.userAgent.match(
        //   /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|AppleWebKit|IEMobile/i
        // )
        XDOM.addEventListener(this.canvasObj, 'touchstart', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'touchmove', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'touchend', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'touchmove', function(event) {
            event.preventDefault();
        });
    } else {
        XDOM.addEventListener(this.canvasObj, 'mousedown', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'mousemove', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'mouseup', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'mouseout', GUI.Signature.Draw);
        XDOM.addEventListener(this.canvasObj, 'mousedown', function(event) {
            event.preventDefault();
        });
    }

    //set button events
    this.clearButton.setAttribute(
        'data-click-action',
        'GUI.Signature.clearCanvas'
    );
    this.submitButton.setAttribute(
        'data-click-action',
        'GUI.Signature.sendCanvas'
    );
};

GUI.Signature.prototype.setDimentions = function() {
    this.canvasWrapper = XDOM.getObject(this.baseId);

    this.canvasWrapper.className += ' line' + this.position['yPos']; //y is in procenten van de hele pagina
    this.canvasWrapper.className += ' xpos' + int2css(this.position['xPos'], 3);

    this.canvasWrapper.className +=
        ' xsize' + int2css(this.dimentions['width'], 2);
    this.canvasWrapper.className +=
        ' lines' + int2css(this.dimentions['height'], 2);
};

GUI.Signature.prototype.renderCanvas = function() {
    this.canvasObj = XDOM.createElement('canvas');
    this.buttonsBar = XDOM.createElement('div', null, 'buttonsBar');

    XDOM.setAttribute(this.canvasObj, 'data-signature-id', this.baseId);

    this.canvasObj.width = this.canvasWrapper.clientWidth;
    this.canvasObj.height =
        this.canvasWrapper.clientHeight - this.buttonsBarHeight;

    this.buttonsBar.style.width = this.canvasWrapper.clientWidth + 'px';
    this.buttonsBar.style.height = this.buttonsBarHeight + 'px';

    this.canvasWrapper.appendChild(this.canvasObj);
    this.canvasWrapper.appendChild(this.buttonsBar);
};

GUI.Signature.prototype.renderButtons = function() {
    this.clearButton = XDOM.createElement(
        'div',
        'clearBtn_' + this.baseId,
        'defaultIconBtn signature-clear-button'
    );
    XDOM.setAttribute(this.clearButton, 'data-signature-id', this.baseId);
    XDOM.setAttribute(this.clearButton, 'data-button', 'undo');

    this.submitButton = XDOM.createElement(
        'div',
        'SIGN',
        'defaultIconBtn signature-submit-button'
    );
    XDOM.setAttribute(this.submitButton, 'data-signature-id', this.baseId);
    XDOM.setAttribute(this.submitButton, 'data-button', 'accept');

    GUI.infoTitle.register(this.clearButton, getCapt('gSIGNATURE_CLEAR'));
    GUI.infoTitle.register(this.submitButton, getCapt('gSIGNATURE_SUBMIT'));

    this.buttonsBar.appendChild(this.submitButton);
    this.buttonsBar.appendChild(this.clearButton);
};

GUI.Signature.prototype.enableCanvas = function() {
    this.setBackground('#ffffff');
    this.prepareCanvas();
    this.enableButtons();
};

GUI.Signature.prototype.disableCanvas = function() {
    this.setBackground('#f2f2f2');
    this.prepareCanvas();
    this.disableButtons();
};

GUI.Signature.prototype.disableButtons = function() {
    XDOM.setAttribute(this.submitButton, 'data-button-disabled', true);
    XDOM.setAttribute(this.clearButton, 'data-button-disabled', true);
};

GUI.Signature.prototype.enableButtons = function() {
    XDOM.setAttribute(this.submitButton, 'data-button-disabled', false);
    XDOM.setAttribute(this.clearButton, 'data-button-disabled', false);
};

GUI.Signature.update = function() {
    var pageObjects = XDOM.queryAllScope('.signature-place-holder');
    var signatureObject = null;
    for (var i = 0, l = pageObjects.length; i < l; i++) {
        signatureObject = GUI.Signature.instances[pageObjects[i].id];
        signatureObject.update();
    }
};

GUI.Signature.prototype.update = function() {
    this.isProtected = XDOM.getAttribute(this.baseId, 'data-protected');
    switch (this.isProtected) {
        case 'true':
            this.disableCanvas();
            break;
        default:
            this.enableCanvas();
            break;
    }
};



GUI.Signature.prototype.getDateTime = function() {
    let dateString = '';
    if (this.dateField && this.dateField.length == 8) {

        dateString =  this.dateField.substr(0, 2) +
            '-' +
            this.dateField.substr(2, 2) +
            '-' +
            this.dateField.substr(4, 4);
    }

    //do a trim because one or the other or both can be empty and we check later on if we have something at all
    return (dateString+ ' ' + this.timeField).trim();
}


GUI.Signature.prototype.getTopCanvasLine = function() {
    //generate line @ top
    let city = this.cityField
    let dateTime = this.getDateTime();

    //when both are set combine the two
    if(city && dateTime) {
        return city + ', ' + dateTime;
    }

    // only one is set so combine it wil return only the content of one.
    return city + dateTime;

}


GUI.Signature.prototype.setBackgroundImage = function() {
    if (!this.signatureUrl) return false;

    GUI.Signature.currentInstanceId = this.baseId;

    this.backgroundImage = new Image();
    //this.backgroundImage.onload = GUI.Signature.backgroundImageOnLoad(this.baseId);

    this.backgroundImage.onload = function() {
        GUI.Signature.backgroundImageOnLoad(GUI.Signature.currentInstanceId);
    };

    this.backgroundImage.src = this.signatureUrl;
    return true;

}
GUI.Signature.prototype.prepareCanvas = function() {
    this.setVars();

    const context = this.canvasObj.getContext('2d');
    context.restore(); //clear canvas
    if(this.setBackgroundImage()) return;



    context.textBaseline = 'top';
    context.fillStyle = '#000000';
    context.lineWidth = '0.3';
    context.font = '12px Arial';


    context.fillText(this.getTopCanvasLine(), 10, 10);

    //generate line @ middle
    context.fillStyle = '#aaa';
    context.fillText(this.referenceLabel + ' - ' + this.referenceField, 10, this.canvasObj.height / 2 - 5);

    //generate line @ bottom
    context.fillStyle = '#000';
    context.fillText(this.nameField, 10, this.canvasObj.height - 20);

    this.hasDrawn = false;
};

GUI.Signature.prototype.approved = function() {
    if (this.isProtected && this.hasDrawn) {
        return true;
    }

    return false;
};

GUI.Signature.backgroundImageOnLoad = function(baseId) {
    var signatureObject = GUI.Signature.instances[baseId];

    if (signatureObject) {
        signatureObject.setCanvasBackGround();
    }
};

GUI.Signature.prototype.setCanvasBackGround = function() {
    this.setBackground('#ffffff');

    var context = this.canvasObj.getContext('2d');
    context.drawImage(
        this.backgroundImage,
        0,
        0,
        this.canvasObj.offsetWidth,
        this.canvasObj.offsetHeight
    );
    GUI.Signature.currentInstanceId = null;
};

GUI.Signature.clearCanvas = function(e) {
    XDOM.getEvent(e);

    var canvasId = XDOM.getAttribute(
        GLOBAL.eventSourceElement,
        'data-signature-id'
    );

    if (GUI.Signature.instances[canvasId].approved) {
        if (
            XDOM.getBooleanAttribute(
                GUI.Signature.instances[canvasId].clearButton,
                'data-button-disabled'
            )
        ) {
            return;
        }

        GUI.Signature.instances[canvasId].setBackground('#ffffff');
        GUI.Signature.instances[canvasId].prepareCanvas();
    }
};

GUI.Signature.sendCanvas = function(e) {
    XDOM.getEvent(e);

    var canvasId = XDOM.getAttribute(
        GLOBAL.eventSourceElement,
        'data-signature-id'
    );
    if (!GUI.Signature.instances[canvasId].approved) {
        return;
    }

    var signObj = GUI.Signature.instances[canvasId];

    if (XDOM.getBooleanAttribute(signObj.submitButton, 'data-button-disabled')) {
        return;
    }

    var request = new XMLHttpRequest();
    var fd = new FormData();
    fd.append('blobName', 'signature');
    var fsUri = SESSION.activePage.pageUrl.replace('MAIN', 'UPLOAD');
    var faResponse = null;
    var dataURL = signObj.canvasObj.toDataURL('image/jpeg', 0.8);
    var blob = GUI.Signature.dataURItoBlob(dataURL);
    fd.append('signature', blob);
    request.open('POST', fsUri, false);
    request.send(fd);
    faResponse = request.responseText.split('=')[1];

    if (faResponse) {
        XDOM.createInputField(signObj.returnField, faResponse.trim());
    }
    Command.execute();
    delete SESSION.activePage.controlerFields[signObj.returnField];
};

GUI.Signature.prototype.setBackground = function(color) {
    var context = this.canvasObj.getContext('2d');
    context.fillStyle = color;
    context.fillRect(0, 0, this.canvasObj.width, this.canvasObj.height);
    context.strokeStyle = 'rgb(0,0,0)';
    context.lineWidth = 1;
    context.font = '12px Arial';
};

GUI.Signature.Draw = function(event) {
    XDOM.getEvent(event);
    var objId = GLOBAL.eventSourceElement;
    var canvasId = XDOM.getAttribute(objId, 'data-signature-id');
    if (GUI.Signature.instances[canvasId].isProtected == 'true') return;

    var coors = null;
    if (event.touches) {
        if (event.touches[0]) {
            coors = {
                x:
                    event.targetTouches[0].pageX -
                    (event.targetTouches[0].target.parentElement.offsetLeft +
                        XDOM.getObject('DTADIV').offsetLeft),
                y:
                    event.targetTouches[0].pageY -
                    (event.targetTouches[0].target.parentElement.offsetTop +
                        XDOM.getObject('DTADIV').offsetTop)
            };
            //Debug.add(event.targetTouches[0].pageX +" / "+ event.targetTouches[0].target.parentElement+" / "+XDOM.getObject("DTADIV").offsetLeft);
        }
    } else {
        coors = {
            x: event.offsetX == undefined ? event.layerX : event.offsetX,
            y: event.offsetY == undefined ? event.layerY : event.offsetY
        };
    }

    GUI.Signature.Drawer[event.type](
        coors,
        GLOBAL.eventSourceElement.getContext('2d'),
        GUI.Signature.instances[canvasId]
    );
};

GUI.Signature.dataURItoBlob = function(dataURI) {
    var dataObj = atob(dataURI.split(',')[1]);
    var bufferArray = new ArrayBuffer(dataObj.length);
    var contentArray = new Uint8Array(bufferArray);
    for (var i = 0, l = dataObj.length; i < l; i++) {
        contentArray[i] = dataObj.charCodeAt(i);
    }
    var blob = new Blob([bufferArray], { type: 'image/jpeg' });
    return blob;
};

/* chart */
/* Load Timestamp 13:59:55.652 */
function legend(parent, data) {
    parent.className = 'legend';
    var datas = data.hasOwnProperty('datasets') ? data.datasets : data;
    // remove possible children of the parent
    while (parent.hasChildNodes()) {
        parent.removeChild(parent.lastChild);
    }
    datas.forEach(function (d) {
        var title = document.createElement('span');
        title.className = 'title';
        title.style.borderColor = d.hasOwnProperty('backgroundColor') ? d.backgroundColor : d.color;
        title.style.borderStyle = 'solid';
        parent.appendChild(title);
        var text = document.createTextNode(d.title);
        title.appendChild(text);
    });
}

GUI.Chart = function (obj) {
    GUI.Chart.baseConstructor.call(this, obj);
    this.dataFields = obj.data; //twee dimentionale array met namen van velden die de data bevatten
    this.chartObject = null;
    this.chartType = obj.subtype;
    this.labels = obj.labels;
    this.updateded = false;
    this.legend = obj.legend;
    this.x = 1;
    this.y = 2;
    this.ySize = parseInt(obj.lines);
    this.xSize = parseInt(obj.xSize);
    this.graphicContext = null;

    // Setup mutation observer
    this.loadObserver = new MutationObserver((mutation) => {
        // Callback function for mutation observer
        if (window.SCOPE.pageDoc.contains(this.dom.canvasObject)) {
            // Set the sizes
            this.setContainerSizes();

            // Update the chart
            this.updateState();

            // Disconnect the observer
            this.loadObserver.disconnect();
        }
    });
};

XDOM.extendObject(GUI.Chart, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.Chart.prototype.init = function () {
    this.base(GUI.Chart, 'init');
};

GUI.Chart.prototype.render = function () {
    this.dom.domObject = XDOM.createElement('DIV', null, "chartWrapper " + this.getCssClass());
    this.renderChart();

    // Start the loadObserver on the pageDoc
    this.loadObserver.observe(
        window.SCOPE.pageDoc,
        {
            attributes: false,
            childList: true,
            characterData: false,
            subtree: true
        }
    );

    return this.dom.domObject;
}
/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Chart.prototype.renderChart = function () {

    this.dom.canvasObject = XDOM.createElement('canvas', this.id, null);
    this.dom.chartLegend = XDOM.createElement('DIV', null, "lineLegend");

    this.dom.domObject.appendChild(this.dom.canvasObject);
    this.dom.domObject.appendChild(this.dom.chartLegend);



};

// Removed, not needed
GUI.Chart.prototype.afterAppend = function () {};

// Set container sizes
GUI.Chart.prototype.setContainerSizes = function () {

    if (this.xSize != "auto"){
        this.dom.domObject.style.width = (this.xSize * 9) + "px";
        this.dom.canvasObject.style.width = (this.xSize * 9) + "px";
        this.dom.canvasObject.width = (this.xSize * 9);
    }

    // if (this.ySize != "auto"){
    //     this.dom.domObject.style.height = (this.parentObject.sizes.lineHeightPx * this.ySize) + "px";
    //     this.dom.canvasObject.style.height = (this.parentObject.sizes.lineHeightPx * this.ySize - 5) + "px";
    //     this.dom.canvasObject.height = (this.parentObject.sizes.lineHeightPx * this.ySize - 5);
    // }
    this.dom.canvasObject.style.height = '100%';
    // this.dom.canvasObject.height = '100%';
};

GUI.Chart.prototype.resetChart = function () {
    //verwijder all dom objecten
    // XDOM.removeDOMObject(this.dom.domObject);
    XDOM.removeDOMObject(this.dom.canvasObject);
    XDOM.removeDOMObject(this.dom.chartLegend);
    this.renderChart()
    this.updateded = false;






};

/**
 * @override GuiBaseObject
 */
GUI.Chart.prototype.updateState = function () {
    var fieldValue = '';
    var colorPicker = 0;
    var maxColors = 4; // is 5 colors starting with zero
    var dataSet = {};
    var dataArray = [];
    var colorObj = null;

    this.base(GUI.Chart, 'updateState');
    this.resetChart();

    var barChartData = {};

    // Structure the bar chart data
    barChartData.labels = [];
    barChartData.datasets = [];

    // Format the labels

    for (var i = 0, l = this.labels.length; i < l; i++) {
        fieldValue = this.labels[i];
        barChartData.labels.push(this.currentData[fieldValue]);
    }

    for (var i = 0, l = this.dataFields.length; i < l; i++) {
        var data = [];
        for (var a = 0, b = this.dataFields[i].length; a < b; a++) {
            fieldValue = this.dataFields[i][a];
            data.push(this.currentData[fieldValue]);
        }

        if (MAIN.NAV.Session.currentInstance.skinColor && GUI.Chart.Config.chartColors[MAIN.NAV.Session.currentInstance.skinColor + "_" + colorPicker]) {
            //use a spread to create a new object and not passing the reference
            colorObj = {...GUI.Chart.Config.chartColors[MAIN.NAV.Session.currentInstance.skinColor + "_" + colorPicker]};
        } else {
            //default color
            //use a spread to create a new object and not passing the reference
            colorObj = {...GUI.Chart.Config.chartColors["BLUE_" + colorPicker]};
        }

        barChartData.datasets[i] = colorObj;
        barChartData.datasets[i].data = data;
        barChartData.datasets[i].label = this.currentData[this.legend[i]];

        if (colorPicker < maxColors) {
            colorPicker++;
            continue;
        }

        colorPicker = 0;
        continue;
    }

    // @GSC Don't thin we need the legend anymore
    // legend(this.dom.chartLegend, barChartData);

    // Pull the type from the obfuscation
    const type = this.chartType.replace('*V', '').toLowerCase();

    // Create the chart
    this.chartObject = new window.SCOPE.session.Chart(
        this.dom.canvasObject.getContext("2d"),
        {
            type: type,
            data: barChartData,
            options: {
                responsive: true,
                maintainAspectRatio:false
            }
        }
    );
    this.setContainerSizes();
};


GUI.Chart.Config = {};

//chartColors[ENUM.skin.blue] = [colors.1,colors.2],colors.0;

GUI.Chart.Config.chartColors = [];

GUI.Chart.Config.chartColors["GREY_0"] = {
    backgroundColor: "rgba(0,0,0,1)",
    borderColor: "rgba(122,122,122,1)",
    hoverBackgroundColor: "rgba(0,0,0,1)",
    hoverBorderColor: "rgba(122,122,122,1)"
};
GUI.Chart.Config.chartColors["GREY_1"] = {
    backgroundColor: "rgba(58,58,58,1)",
    borderColor: "rgba(122,122,122,1)",
    hoverBackgroundColor: "rgba(58,58,58,1)",
    hoverBorderColor: "rgba(122,122,122,1)"
};
GUI.Chart.Config.chartColors["GREY_2"] = {
    backgroundColor: "rgba(123,123,123,1)",
    borderColor: "rgba(122,122,122,1)",
    hoverBackgroundColor: "rgba(123,123,123,1)",
    hoverBorderColor: "rgba(122,122,122,1)"
};
GUI.Chart.Config.chartColors["GREY_3"] = {
    backgroundColor: "rgba(233,233,233,1)",
    borderColor: "rgba(122,122,122,1)",
    hoverBackgroundColor: "rgba(233,233,233,1)",
    hoverBorderColor: "rgba(122,122,122,1)"
};
GUI.Chart.Config.chartColors["GREY_4"] = {
    backgroundColor: "rgba(255,255,255,1)",
    borderColor: "rgba(122,122,122,1)",
    hoverBackgroundColor: "rgba(255,255,255,1)",
    hoverBorderColor: "rgba(122,122,122,1)"
};

GUI.Chart.Config.chartColors["BLUE_0"] = {
    backgroundColor: "rgba(0,167,255,1)",
    borderColor: "rgba(0,96,147,1)",
    hoverBackgroundColor: "rgba(0,167,255,1)",
    hoverBorderColor: "rgba(0,96,147,1)"
};
GUI.Chart.Config.chartColors["BLUE_1"] = {
    backgroundColor: "rgba(0,125,192,1)",
    borderColor: "rgba(0,96,147,1)",
    hoverBackgroundColor: "rgba(0,125,192,1)",
    hoverBorderColor: "rgba(0,96,147,1)"
};
GUI.Chart.Config.chartColors["BLUE_2"] = {
    backgroundColor: "rgba(0,96,147,1)",
    borderColor: "rgba(0,96,147,1)",
    hoverBackgroundColor: "rgba(0,96,147,1)",
    hoverBorderColor: "rgba(0,96,147,1)"
};
GUI.Chart.Config.chartColors["BLUE_3"] = {
    backgroundColor: "rgba(0,60,92,1)",
    borderColor: "rgba(0,96,147,1)",
    hoverBackgroundColor: "rgba(0,60,92,1)",
    hoverBorderColor: "rgba(0,96,147,1)"
};
GUI.Chart.Config.chartColors["BLUE_4"] = {
    backgroundColor: "rgba(0,22,34,1)",
    borderColor: "rgba(0,96,147,1)",
    hoverBackgroundColor: "rgba(0,22,34,1)",
    hoverBorderColor: "rgba(0,96,147,1)"
};

GUI.Chart.Config.chartColors["AQUA_0"] = {
    backgroundColor: "rgba(0,72,83,1)",
    borderColor: "rgba(0,129,149,1)",
    hoverBackgroundColor: "rgba(0,72,83,1)",
    hoverBorderColor: "rgba(0,129,149,1)"
};
GUI.Chart.Config.chartColors["AQUA_1"] = {
    backgroundColor: "rgba(0,110,127,1)",
    borderColor: "rgba(0,129,149,1)",
    hoverBackgroundColor: "rgba(0,110,127,1)",
    hoverBorderColor: "rgba(0,129,149,1)"
};
GUI.Chart.Config.chartColors["AQUA_2"] = {
    backgroundColor: "rgba(0,129,149,1)",
    borderColor: "rgba(0,129,149,1)",
    hoverBackgroundColor: "rgba(0,129,149,1)",
    hoverBorderColor: "rgba(0,129,149,1)"
};
GUI.Chart.Config.chartColors["AQUA_3"] = {
    backgroundColor: "rgba(0,163,188,1)",
    borderColor: "rgba(0,129,149,1)",
    hoverBackgroundColor: "rgba(0,163,188,1)",
    hoverBorderColor: "rgba(0,129,149,1)"
};
GUI.Chart.Config.chartColors["AQUA_4"] = {
    backgroundColor: "rgba(0,198,229,1)",
    borderColor: "rgba(0,129,149,1)",
    hoverBackgroundColor: "rgba(0,198,229,1)",
    hoverBorderColor: "rgba(0,129,149,1)"
};

GUI.Chart.Config.chartColors["GREEN_0"] = {
    backgroundColor: "rgba(53,111,0,1)",
    borderColor: "rgba(86,181,0,1)",
    hoverBackgroundColor: "rgba(53,111,0,1)",
    hoverBorderColor: "rgba(86,181,0,1)"
};
GUI.Chart.Config.chartColors["GREEN_1"] = {
    backgroundColor: "rgba(68,143,0,1)",
    borderColor: "rgba(86,181,0,1)",
    hoverBackgroundColor: "rgba(68,143,0,1)",
    hoverBorderColor: "rgba(86,181,0,1)"
};
GUI.Chart.Config.chartColors["GREEN_2"] = {
    backgroundColor: "rgba(86,181,0,1)",
    borderColor: "rgba(86,181,0,1)",
    hoverBackgroundColor: "rgba(86,181,0,1)",
    hoverBorderColor: "rgba(86,181,0,1)"
};
GUI.Chart.Config.chartColors["GREEN_3"] = {
    backgroundColor: "rgba(105,220,0,1)",
    borderColor: "rgba(86,181,0,1)",
    hoverBackgroundColor: "rgba(105,220,0,1)",
    hoverBorderColor: "rgba(86,181,0,1)"
};
GUI.Chart.Config.chartColors["GREEN_4"] = {
    backgroundColor: "rgba(122,255,0,1)",
    borderColor: "rgba(86,181,0,1)",
    hoverBackgroundColor: "rgba(122,255,0,1)",
    hoverBorderColor: "rgba(86,181,0,1)"
};

GUI.Chart.Config.chartColors["ORANGE_0"] = {
    backgroundColor: "rgba(123,66,0,1)",
    borderColor: "rgba(209,112,0,1)",
    hoverBackgroundColor: "rgba(123,66,0,1)",
    hoverBorderColor: "rgba(209,112,0,1)"
};
GUI.Chart.Config.chartColors["ORANGE_1"] = {
    backgroundColor: "rgba(160,86,0,1)",
    borderColor: "rgba(209,112,0,1)",
    hoverBackgroundColor: "rgba(160,86,0,1)",
    hoverBorderColor: "rgba(209,112,0,1)"
};
GUI.Chart.Config.chartColors["ORANGE_2"] = {
    backgroundColor: "rgba(209,112,0,1)",
    borderColor: "rgba(209,112,0,1)",
    hoverBackgroundColor: "rgba(209,112,0,1)",
    hoverBorderColor: "rgba(209,112,0,1)"
};
GUI.Chart.Config.chartColors["ORANGE_3"] = {
    backgroundColor: "rgba(255,144,0,1)",
    borderColor: "rgba(209,112,0,1)",
    hoverBackgroundColor: "rgba(255,144,0,1)",
    hoverBorderColor: "rgba(209,112,0,1)"
};
GUI.Chart.Config.chartColors["ORANGE_4"] = {
    backgroundColor: "rgba(255,188,60,1)",
    borderColor: "rgba(209,112,0,1)",
    hoverBackgroundColor: "rgba(255,188,0,1)",
    hoverBorderColor: "rgba(209,112,0,1)"
};

GUI.Chart.Config.chartColors["RED_0"] = {
    backgroundColor: "rgba(132,0,5,1)",
    borderColor: "rgba(223,0,9,1)",
    hoverBackgroundColor: "rgba(132,0,5,1)",
    hoverBorderColor: "rgba(223,0,9,1)"
};
GUI.Chart.Config.chartColors["RED_1"] = {
    backgroundColor: "rgba(180,0,7,1)",
    borderColor: "rgba(223,0,9,1)",
    hoverBackgroundColor: "rgba(180,0,7,1)",
    hoverBorderColor: "rgba(223,0,9,1)"
};
GUI.Chart.Config.chartColors["RED_2"] = {
    backgroundColor: "rgba(223,0,9,1)",
    borderColor: "rgba(223,0,9,1)",
    hoverBackgroundColor: "rgba(223,0,9,1)",
    hoverBorderColor: "rgba(223,0,9,1)"
};
GUI.Chart.Config.chartColors["RED_3"] = {
    backgroundColor: "rgba(247,2,12,1)",
    borderColor: "rgba(223,0,9,1)",
    hoverBackgroundColor: "rgba(247,2,12,1)",
    hoverBorderColor: "rgba(223,0,9,1)"
};
GUI.Chart.Config.chartColors["RED_4"] = {
    backgroundColor: "rgba(254,71,78,1)",
    borderColor: "rgba(223,0,9,1)",
    hoverBackgroundColor: "rgba(254,71,78,1)",
    hoverBorderColor: "rgba(223,0,9,1)"
};

GUI.Chart.Config.chartColors["PURPLE_0"] = {
    backgroundColor: "rgba(49,0,83,1)",
    borderColor: "rgba(107,0,178,1)",
    hoverBackgroundColor: "rgba(49,0,83,1)",
    hoverBorderColor: "rgba(107,0,178,1)"
};
GUI.Chart.Config.chartColors["PURPLE_1"] = {
    backgroundColor: "rgba(81,0,135,1)",
    borderColor: "rgba(107,0,178,1)",
    hoverBackgroundColor: "rgba(81,0,135,1)",
    hoverBorderColor: "rgba(107,0,178,1)"
};
GUI.Chart.Config.chartColors["PURPLE_2"] = {
    backgroundColor: "rgba(107,0,178,1)",
    borderColor: "rgba(107,0,178,1)",
    hoverBackgroundColor: "rgba(107,0,178,1)",
    hoverBorderColor: "rgba(107,0,178,1)"
};
GUI.Chart.Config.chartColors["PURPLE_3"] = {
    backgroundColor: "rgba(130,0,216,1)",
    borderColor: "rgba(107,0,178,1)",
    hoverBackgroundColor: "rgba(130,0,216,1)",
    hoverBorderColor: "rgba(107,0,178,1)"
};
GUI.Chart.Config.chartColors["PURPLE_4"] = {
    backgroundColor: "rgba(171,45,255,1)",
    borderColor: "rgba(107,0,178,1)",
    hoverBackgroundColor: "rgba(171,45,255,1)",
    hoverBorderColor: "rgba(107,0,178,1)"
};

GUI.Chart.Config.chartColors["PINK_0"] = {
    backgroundColor: "rgba(134,0,71,1)",
    borderColor: "rgba(219,0,116,1)",
    hoverBackgroundColor: "rgba(134,0,71,1)",
    hoverBorderColor: "rgba(219,0,116,1)"
};
GUI.Chart.Config.chartColors["PINK_1"] = {
    backgroundColor: "rgba(160,0,85,1)",
    borderColor: "rgba(219,0,116,1)",
    hoverBackgroundColor: "rgba(160,0,85,1)",
    hoverBorderColor: "rgba(219,0,116,1)"
};
GUI.Chart.Config.chartColors["PINK_2"] = {
    backgroundColor: "rgba(219,0,116,1)",
    borderColor: "rgba(219,0,116,1)",
    hoverBackgroundColor: "rgba(219,0,116,1)",
    hoverBorderColor: "rgba(219,0,116,1)"
};
GUI.Chart.Config.chartColors["PINK_3"] = {
    backgroundColor: "rgba(255,0,135,1)",
    borderColor: "rgba(219,0,116,1)",
    hoverBackgroundColor: "rgba(255,0,135,1)",
    hoverBorderColor: "rgba(219,0,116,1)"
};
GUI.Chart.Config.chartColors["PINK_4"] = {
    backgroundColor: "rgba(255,100,182,1)",
    borderColor: "rgba(219,0,116,1)",
    hoverBackgroundColor: "rgba(255,100,182,1)",
    hoverBorderColor: "rgba(219,0,116,1)"
};


XDOM.extendObject(GUI.Chart.Config, GUI.Chart);

/* choiceService */
/* Load Timestamp 13:59:55.653 */
GUI.ChoiceService = function(obj) {
    GUI.ChoiceService.baseConstructor.call(this,obj);
    this.targetId = nullWhenEmpty(obj.toId);
    this.serviceSource = nullWhenEmpty(obj.serviceSource);
    this.whenField = nullWhenEmpty(obj.whenField);
    this.whenValue = nullWhenEmpty(obj.whenValue);
    this.service = null;
};

XDOM.extendObject(GUI.ChoiceService, GUI.BaseInputObject);

GUI.ChoiceService.instances = [];

GUI.ChoiceService.prototype.init = function(){
    this.base(GUI.ChoiceService, 'init');
    GUI.ChoiceService.instances[this.id] = this;
    this.targetId = this.panelId + '-' + this.targetId;
};


/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.ChoiceService.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("DIV",this.id);
    this.dom.domObject.setAttribute("data-to-id", this.targetId);
    this.dom.domObject.setAttribute("data-service-source", this.serviceSource);
    this.dom.domObject.setAttribute("data-service-id", this.id);
    this.dom.domObject.setAttribute("data-service-type", "*CHC");
    this.dom.domObject.setAttribute("data-service-open", "*USER");
    this.dom.domObject.setAttribute("data-panel-id", this.panelId);

    this.setPosAndDimentions();
    this.updateState();
    this.registerEvents();
    return this.dom.domObject;
};

GUI.ChoiceService.prototype.registerEvents = function(){};

/**
 * @override GuiBaseObject
 */
GUI.ChoiceService.prototype.updateState = function(){

    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.ChoiceService, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
    if(this.whenField){
        if(this.getDataValue(this.whenField )== this.whenValue){
            this.dom.domObject.style.display='';
        }else{
            this.dom.domObject.style.display='none';
        }
    }
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.ChoiceService.prototype.getCssClass = function(){
    var fsCssClass =  this.base(GUI.ChoiceService, 'getCssClass');
    fsCssClass +=" serviceChoice pth-choice dataSectionButton theme-hover-color";
    return fsCssClass;
};


GUI.ChoiceService.prototype.open = function(){
    this.service.open();
};

GUI.ChoiceService.open = function(serviceId){
    GUI.ChoiceService.instances[serviceId].open();
};
/* displayService */
/* Load Timestamp 13:59:55.653 */
GUI.DisplayService = function(obj) {
    GUI.DisplayService.baseConstructor.call(this,obj);
};
GUI.DisplayService = function(obj) {
    GUI.DisplayService.baseConstructor.call(this,obj);
    this.targetId = nullWhenEmpty(obj.toId);
    this.serviceSource = nullWhenEmpty(obj.serviceSource);
    this.whenField = nullWhenEmpty(obj.whenField);
    this.whenValue = nullWhenEmpty(obj.whenValue);
    this.service = null;
};

XDOM.extendObject(GUI.DisplayService, GUI.BaseInputObject);


GUI.DisplayService.instances = [];

GUI.DisplayService.prototype.init = function(){
    this.targetId = this.parentObject.panelId + '-' + this.targetId;
    this.base(GUI.DisplayService, 'init');
    GUI.DisplayService.instances[this.targetId] = this;

};



/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.DisplayService.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("DIV",this.id);
    this.dom.domObject.setAttribute("data-to-id", this.targetId);
    this.dom.domObject.setAttribute("data-service-source", this.serviceSource);
    this.dom.domObject.setAttribute("data-service-id", this.id);
    this.dom.domObject.setAttribute("data-service-type", "*DSP");
    this.dom.domObject.setAttribute("data-service-open", "*USER");
    this.dom.domObject.setAttribute("data-panel-id", this.panelId);

    this.setPosAndDimentions();
    this.updateState();
    this.registerEvents();
    return this.dom.domObject;
};

GUI.DisplayService.prototype.registerEvents = function(){}

/**
 * @override GuiBaseObject
 */
GUI.DisplayService.prototype.updateState = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.DisplayService, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
    if(this.whenField){
        if(this.getDataValue(this.whenField )== this.whenValue){
            this.dom.domObject.style.display='';
        }else{
            this.dom.domObject.style.display='none';
        }
    }
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.DisplayService.prototype.getCssClass = function(){
    var fsCssClass =  this.base(GUI.Calendar, 'getCssClass');
    fsCssClass +=" serviceDisplay pth-display dataSectionButton theme-hover-color";
    return fsCssClass;
};


GUI.DisplayService.open = function(){
    var serviceId = XDOM.GLOBAL.getAttribute("data-eventarg-id");
    GUI.DisplayService.instances[serviceId].service.open();
};



/* quickSearch */
/* Load Timestamp 13:59:55.653 */
GUI.QuickSearch = function (obj) {
    GUI.QuickSearch.baseConstructor.call(this, obj);

    //registreren van value's in response
    this.quicksearchId = nullWhenEmpty(obj.id);
    this.toId = nullWhenEmpty(obj.toId);
    this.searchMacroName = nullWhenEmpty(obj.macroName);
    this.macroLocation = nullWhenEmpty(obj.macroLocation);
    this.parmObject = nullWhenEmpty(obj.parmObject);
    this.returnFields = nullWhenEmpty(obj.returnFields);
    this.activateAfter = nullWhenEmpty(obj.activateAfter);
    this.limitResults = nullWhenEmpty(obj.limitResults);
    this.activateSearch = nullWhenEmpty(obj.activateSearch);
    this.inputFields = nullWhenEmpty(obj.inputFields);
    this.whenField = nullWhenEmpty(obj.whenField);
    this.whenValue = nullWhenEmpty(obj.whenValue);
    this.xPosition = nullWhenEmpty(obj.xPosition);
    this.yPosition = nullWhenEmpty(obj.yPosition);
    this.targetInputObj = null;
};

XDOM.extendObject(GUI.QuickSearch, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.QuickSearch.prototype.render = function () {
    this.dom.domObject = XDOM.createElement("DIV", this.quicksearchId);
    this.dom.domObject.setAttribute("data-search-type", "quickSearch");

    this.dom.domObject.setAttribute("data-to-id", this.panelId + "-" + this.toId);
    this.dom.domObject.setAttribute("data-macro-name", this.searchMacroName);
    this.dom.domObject.setAttribute("data-quicksearch-id", this.quicksearchId);
    this.dom.domObject.setAttribute("data-macro-location", this.macroLocation);
    this.dom.domObject.setAttribute("data-input-fields", this.panelId + "-" + this.inputFields);

    this.dom.domObject.setAttribute("data-quicksearch-activate-after", this.activateAfter);
    this.dom.domObject.setAttribute("data-activate-search", this.activateSearch);

    this.dom.domObject.setAttribute("data-quicksearch-limit-results", this.limitResults);

    this.updateFieldNames();

    this.setPosAndDimentions();
    this.updateState();
    this.registerEvents();
    return this.dom.domObject;
};

GUI.QuickSearch.prototype.registerEvents = function () {
};

GUI.QuickSearch.prototype.updateFieldNames = function () {

    var parmObject = eval(this.parmObject);
    var returnFields = this.returnFields.split(' ');
    var fsObject = "";

    for (var l = returnFields.length, i = 0; i < l; i++) {
        fsObject += this.panelId + "-" + returnFields[i] + " ";
    }

    this.returnFields = fsObject;
    this.dom.domObject.setAttribute("data-return-fields", this.returnFields.trim());

    fsObject = "[";

    for (var i = 0; i < parmObject.length; i++) {
        if (i != 0) {
            fsObject += ", ";
        }
        fsObject += "{ 'location':'" + parmObject[i].location + "' , 'field': '" + this.panelId + "-" + parmObject[i].field + "' }";
    }

    fsObject += "]";

    this.parmObject = fsObject;

    this.dom.domObject.setAttribute("data-parm-object", this.parmObject);
    this.dom.domObject.setAttribute("data-invoker-baseId", this.panelId);
    this.dom.domObject.addEventListener('click', QuickSearch.handleOnClick);
    //update QS target input
    this.targetInputObj = this.parentObject.guiObjects[this.panelId + "-" + this.toId];
    if (this.targetInputObj && this.targetInputObj.dom && this.targetInputObj.dom.domObject) {


        if (this.activateAfter == "*AUTO") {
            this.activateAfter = QuickSearch.getDefaultMinLength(this.targetInputObj.dom.domObject);
        }

        if (!this.targetInputObj.dom.domObject.hasAttribute("data-setDefault-events") &&
            !this.targetInputObj.dom.domObject.hasAttribute("data-quicksearch-activate-after")) {

            this.targetInputObj.dom.domObject.setAttribute("data-quicksearch-id", this.quicksearchId);
            this.targetInputObj.dom.domObject.setAttribute("data-quicksearch-activate-after", this.activateAfter);
        }

    }

    return;

};

/**
 * @override GuiBaseObject
 */
GUI.QuickSearch.prototype.updateState = function () {

    if (!this.dom.domObject) {
        this.dom.domObject = XDOM.getObject(this.quicksearchId);
    }
    this.base(GUI.QuickSearch, 'updateState');
    this.dom.domObject.className = this.getCssClass();
    if (this.whenField) {
        if (this.getDataValue(this.whenField) == this.whenValue) {
            this.dom.domObject.style.display = '';
        } else {
            this.dom.domObject.style.display = 'none';
        }
    }
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.QuickSearch.prototype.getCssClass = function () {
    var fsCssClass = this.base(GUI.Calendar, 'getCssClass');
    fsCssClass += " quickSearch pth-quickSearch dataSectionButton theme-hover-color";
    return fsCssClass;
};

/* querylist */
/* Load Timestamp 13:59:55.654 */
GUI.QueryList = function(obj) {
    GUI.QueryList.baseConstructor.call(this,obj);
    //registreren van value's in response
    //check for *NONE or queries will go wrong
    this.toId						= obj.toId=='*NONE'?'':nullWhenEmpty(obj.toId);

    this.macroToCall		= nullWhenEmpty(obj.macroName);
    this.id = this.toId	 + '-'+ this.macroToCall;
    this.macroLocation	= nullWhenEmpty(obj.macroLocation);
    this.parmObject			= nullWhenEmpty(obj.parmObject);
    this.inputFields	  = nullWhenEmpty(obj.inputFields);
    this.returnFields		= obj.returnFields || '';
    this.buttonIcon		= nullWhenEmpty(obj.iconImage);
    this.panelMode		= nullWhenEmpty(obj.openOptions);
    this.whenField 			= nullWhenEmpty(obj.whenField);
    this.whenValue 			= nullWhenEmpty(obj.whenValue);
    this.xPosition			= nullWhenEmpty(obj.xPosition);
    this.yPosition			= nullWhenEmpty(obj.yPosition);
    this.targetInputObj	= null;
};

XDOM.extendObject(GUI.QueryList, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.QueryList.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("DIV", 					this.id);
    //this.dom.domObject.setAttribute("data-is-gui", "true");

    this.dom.domObject.setAttribute("data-to-id", 				this.panelId+"-"+this.toId);
    this.dom.domObject.setAttribute("data-parm-object", 		this.parmObject);
    this.dom.domObject.setAttribute("data-button-icon", 		"queryList");
    this.dom.domObject.setAttribute("data-button-icon", 	 	this.buttonIcon);
    this.dom.domObject.setAttribute("data-open-options", 	 	this.panelMode);
    this.dom.domObject.setAttribute("data-click-action", 		"QueryList.open");


    this.dom.domObject.setAttribute("data-macro-name", 			this.macroToCall);
    this.dom.domObject.setAttribute("data-parm-prefix", 		this.panelId+"-");
    this.dom.domObject.setAttribute("data-macro-location", 	this.macroLocation);
    this.dom.domObject.setAttribute("data-input-fields", 		this.macroName+"-"+this.inputFields);
    this.dom.domObject.setAttribute('data-panel-id',        this.panelId);
    this.dom.domObject.setAttribute("data-return-fields", 	this.returnFields);
    this.dom.domObject.setAttribute("data-parm-object", this.parmObject);
    this.dom.domObject.setAttribute("data-invoker-baseId", this.macroName);
    //this.updateFieldNames();

    this.setPosAndDimentions();
    this.updateState();
    this.registerEvents();
    return this.dom.domObject;
};

GUI.QueryList.prototype.registerEvents = function(){};


/**
 * @override GuiBaseObject
 */
GUI.QueryList.prototype.updateState = function(){

    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.QueryList, 'updateState');
    this.dom.domObject.className = 'pth-icon dataSectionButton ' + this.getCssClass();
    if(this.whenField){
        if(this.getDataValue(this.whenField )== this.whenValue){
            this.dom.domObject.style.display='';
        }else{
            this.dom.domObject.style.display='none';
        }
    }
    this.setAlias(this.dom.domObject)
};


/* infoWindowIcon */
/* Load Timestamp 13:59:55.654 */
GUI.InfoWindowIcon = function(obj) {
    GUI.InfoWindowIcon.baseConstructor.call(this,obj);
    //registreren van value's in response
    this.toId						= nullWhenEmpty(obj.toId);
    this.macroToCall		= nullWhenEmpty(obj.macroName);
    this.id = this.toId	 + '-'+ this.macroToCall;
    this.macroLocation	= nullWhenEmpty(obj.macroLocation) || 'DBS';
    this.parmObject			= nullWhenEmpty(obj.parmObject);
    this.inputFields	  = nullWhenEmpty(obj.inputFields);
    this.returnFields		= nullWhenEmpty(obj.returnFields);
    this.openOptions    = nullWhenEmpty(obj.openOptions);
    this.whenField 			= nullWhenEmpty(obj.whenField);
    this.whenValue 			= nullWhenEmpty(obj.whenValue);
    this.xPosition			= nullWhenEmpty(obj.xPosition);
    this.yPosition			= nullWhenEmpty(obj.yPosition);

    this.targetInputObj	= null;
};

XDOM.extendObject(GUI.InfoWindowIcon, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.InfoWindowIcon.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("DIV",	this.id, "");
    this.dom.domObject.setAttribute("data-is-gui", "true");

    this.dom.domObject.setAttribute("data-to-id", 					this.macroName+"-"+this.toId);
    this.dom.domObject.setAttribute("data-parm-object", 		this.parmObject);
    this.dom.domObject.setAttribute("data-parm-prefix", 		this.panelId+"-");
    this.dom.domObject.setAttribute("data-open-options", 		this.openOptions);
    this.dom.domObject.setAttribute("data-mouseover-action",	"GUI.InfoWindow.handleMouseOver" );
    this.dom.domObject.setAttribute("data-mouseout-action", "GUI.InfoWindow.handleMouseOut");


    this.dom.domObject.setAttribute("data-click-action", 		"GUI.InfoWindow.handleClick");

    this.dom.domObject.setAttribute("data-macro-name", 			this.macroToCall);
    this.dom.domObject.setAttribute("data-macro-location", 	this.macroLocation);
    this.dom.domObject.setAttribute("data-input-fields", 		this.macroName+"-"+this.inputFields);
    this.dom.domObject.setAttribute('data-panel-id',        this.panelId);

    this.updateFieldNames();

    this.setPosAndDimentions();
    this.updateState();
    this.registerEvents();
    return this.dom.domObject;
};

GUI.InfoWindowIcon.prototype.registerEvents = function(){
    XDOM.addEventListener(this.dom.domObject, 'mouseover', handleMouseOver);
    XDOM.addEventListener(this.dom.domObject, 'mouseout', handleMouseOut);
};

GUI.InfoWindowIcon.prototype.updateFieldNames = function(){
    let parmObject 	 = JSON.parse(this.parmObject.replace(/\'/g,'"'));
    for(let i = 0;i < parmObject.length; i++){
        parmObject[i].field = this.macroName+"-"+parmObject[i].field;
    }
    this.dom.domObject.dataset.parmObject =  this.parmObject;
    this.dom.domObject.setAttribute("data-invoker-baseId", this.macroName);
    return;

};

/**
 * @override GuiBaseObject
 */
GUI.InfoWindowIcon.prototype.updateState = function(){

    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.InfoWindowIcon, 'updateState');
    this.dom.domObject.className  = 'pth-infoProgram ' + this.getCssClass();
    if(this.whenField){
        if(this.getDataValue(this.whenField )== this.whenValue){
            this.dom.domObject.style.display='';
        }else{
            this.dom.domObject.style.display='none';
        }
    }
    this.setAlias(this.dom.domObject)
};


/* editWindowIcon */
/* Load Timestamp 13:59:55.654 */
GUI.EditWindowIcon = function (obj) {
    GUI.EditWindowIcon.baseConstructor.call(this, obj);
    //registreren van value's in response
    this.toId = nullWhenEmpty(obj.toId);
    this.macroToCall = nullWhenEmpty(obj.macroName);
    this.id = this.toId + '-' + this.macroToCall;
    this.macroLocation = nullWhenEmpty(obj.macroLocation) || 'DBS';
    this.parmObject = nullWhenEmpty(obj.parmObject);
    this.inputFields = nullWhenEmpty(obj.inputFields);
    this.returnFields = nullWhenEmpty(obj.returnFields);
    this.openOptions = nullWhenEmpty(obj.openOptions);
    this.whenField = nullWhenEmpty(obj.whenField);
    this.whenValue = nullWhenEmpty(obj.whenValue);
    this.xPosition = nullWhenEmpty(obj.xPosition);
    this.yPosition = nullWhenEmpty(obj.yPosition);
    this.targetInputObj = null;
};

XDOM.extendObject(GUI.EditWindowIcon, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.EditWindowIcon.prototype.render = function () {
    this.dom.domObject = XDOM.createElement("DIV", this.id, "");
    this.dom.domObject.setAttribute("data-is-gui", "true");

    this.dom.domObject.setAttribute("data-to-id", this.macroName + "-" + this.toId);
    this.dom.domObject.setAttribute("data-parm-object", this.parmObject);
    this.dom.domObject.setAttribute("data-parm-prefix", this.panelId + "-");
    this.dom.domObject.setAttribute("data-open-options", this.openOptions);


    this.dom.domObject.setAttribute("data-click-action", "GUI.EditWindow.handleClick");
    this.dom.domObject.setAttribute("data-macro-name", this.macroToCall);
    this.dom.domObject.setAttribute("data-macro-location", this.macroLocation);
    this.dom.domObject.setAttribute("data-input-fields", this.macroName + "-" + this.inputFields);
    this.dom.domObject.setAttribute('data-panel-id', this.panelId);

    this.updateFieldNames();
    this.setPosAndDimentions();
    this.updateState();

    return this.dom.domObject;
};


GUI.EditWindowIcon.prototype.updateFieldNames = function () {
    let parmObject = JSON.parse(this.parmObject.replace(/\'/g, '"'));
    for (let i = 0; i < parmObject.length; i++) {
        parmObject[i].field = this.macroName + "-" + parmObject[i].field;
    }
    this.dom.domObject.dataset.parmObject = this.parmObject;
    this.dom.domObject.setAttribute("data-invoker-baseId", this.macroName);
    return;

};

/**
 * @override GuiBaseObject
 */
GUI.EditWindowIcon.prototype.updateState = function () {
    if (!this.dom.domObject) {
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.EditWindowIcon, 'updateState');
    this.dom.domObject.className = 'pth-icon dataSectionButton pth-infoProgram ' + this.getCssClass();
    if (this.whenField) {
        if (this.getDataValue(this.whenField) == this.whenValue) {
            this.dom.domObject.style.display = '';
        } else {
            this.dom.domObject.style.display = 'none';
        }
    }
    this.setAlias(this.dom.domObject)
};


/* calendar */
/* Load Timestamp 13:59:55.655 */
GUI.Calendar = function(obj) {
    GUI.Calendar.baseConstructor.call(this,obj);
    this.targetId = nullWhenEmpty(obj.toId);
    this.whenField 			= nullWhenEmpty(obj.whenField);
    this.whenValue 			= nullWhenEmpty(obj.whenValue);
};

XDOM.extendObject(GUI.Calendar, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */


GUI.Calendar.prototype.render = function(){

    this.dom.domObject = XDOM.createElement("DIV",this.id);
    this.dom.domObject.setAttribute("data-to-id", this.panelId + '-' + this.targetId);
    this.dom.domObject.setAttribute("data-service-id", this.id);
    this.dom.domObject.setAttribute("data-service-type", "*CAL");
    this.setPosAndDimentions();
    this.updateState();
    this.registerEvents();
    return this.dom.domObject;
};

/**
 * @override GuiBaseObject
 */
GUI.Calendar.prototype.updateState = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.Calendar, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
    if(this.whenField){
        if(this.getDataValue(this.whenField )== this.whenValue){
            this.dom.domObject.style.display='';
        }else{
            this.dom.domObject.style.display='none';
        }
    }
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.Calendar.prototype.getCssClass = function(){
    var fsCssClass =  this.base(GUI.Calendar, 'getCssClass');
    fsCssClass +=" serviceCalendar pth-calendar dataSectionButton theme-hover-color ";
    return fsCssClass;
};

GUI.Calendar.prototype.registerEvents = function(){
    this.dom.domObject.addEventListener('click',Calender.handleOnClick);
}

/* label */
/* Load Timestamp 13:59:55.655 */
GUI.Label = function(obj) {
    GUI.Label.baseConstructor.call(this,obj);
    this.text = '';
    this.captionId = nullWhenEmpty(obj.id);
};

XDOM.extendObject(GUI.Label, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.Label.prototype.init = function(){
    this.base(GUI.Label, 'init');
    this.setDefaults();
    this.text =  this.parentObject.captions.get(this.captionId);
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Label.prototype.render = function(){

    this.dom.domObject = XDOM.createElement("LABEL",this.id);
    this.dom.domObject.appendChild(XDOM.createTextNode(this.text));

    FieldAttribute.setAttentionLevel(this);

    this.setPosAndDimentions();
    this.updateState();
    return this.dom.domObject;
};
/**
 * @override GuiBaseObject
 */
GUI.Label.prototype.updateState = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.Label, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.Label.prototype.getCssClass = function(){
    return this.base(GUI.Label, 'getCssClass');
};

/* input */
/* Load Timestamp 13:59:55.655 */
GUI.Input = function (obj) {
    GUI.Input.baseConstructor.call(this, obj);
    this.dataType = nullWhenEmpty(obj.dataType);
    this.blankWhenZero = nullWhenEmpty(obj.blankWhenZero);
    this.thousandSeparator = nullWhenEmpty(obj.thousandSeparator);
    this.decimalSeparator = ',';
    this.maxScaleSystemLimit = nullWhenEmpty(obj.maxScaleSystemLimit);
    this.maxScaleField = nullWhenEmpty(obj.maxScaleField);
    this.maxLength = nullOrInt(obj.maxLength);
    this.precision = nullOrInt(obj.precision);
    this.scale = nullOrInt(obj.scale);
    this.forFieldProgression = true;
};

XDOM.extendObject(GUI.Input, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 */
GUI.Input.prototype.init = function () {
    this.setDefaults();
    this.base(GUI.Input, 'init');
    //this.parentObject.fieldProgression.add(this);
    if (!this.blankWhenZero) {
        this.blankWhenZero = ENUM.blankWhenZero.blank;
    }

    if (!this.thousandSeparator) {
        this.thousandSeparator = ENUM.thousandSeparator.none;
    }
    if (this.thousandSeparator === ENUM.thousandSeparator.period) {
        this.decimalSeparator = ',';
    }
    if (this.thousandSeparator === ENUM.thousandSeparator.comma) {
        this.decimalSeparator = '.';
    }
    this.setValue();
};

/**
 * haalt de waarde op uit de dataset
 */
GUI.Input.prototype.setValue = function () {
    this.base(GUI.Input, 'setValue');
    if (this.dataType === ENUM.dataType.decimal) {
        if (this.blankWhenZero === ENUM.blankWhenZero.blank && isZero(this.value)) {
            this.value = '';
        }
    }
};

/**
 * voegd voor een numerieke waarde duizend tekens toe
 */
GUI.Input.prototype.formatNumber = function () {
    if (this.dataType !== ENUM.dataType.decimal) {
        return;
    }
    this.formatThousandSeparator();
    this.formatMaxScale();

};

GUI.Input.prototype.formatMaxScale = function () {
    if (!this.maxScaleField) {
        return;
    }
    var maxScale = this.getDataValue(this.maxScaleField);
    var foScale = formatMaxScale(this.value, this.maxScaleSystemLimit, maxScale, this.decimalSeparator);
    this.value = foScale.value;
    this.scaleCss = foScale.cssClass;

};


GUI.Input.prototype.formatThousandSeparator = function () {
    var fsSeparator = '';

    var fsDecimal = '';
    var fsInteger = '';
    var faNumber = null;
    var rgx = /(\d+)(\d{3})/;

    switch (this.thousandSeparator) {
        case    ENUM.thousandSeparator.period:
            fsSeparator = ".";
            break;
        case    ENUM.thousandSeparator.comma:
            fsSeparator = ",";
            break;
        case    ENUM.thousandSeparator.none:
            return;
    }


    faNumber = this.value.split(this.decimalSeparator);
    fsInteger = faNumber[0];
    fsDecimal = faNumber.length > 1 ? this.decimalSeparator + faNumber[1] : '';

    while (rgx.test(fsInteger)) {
        fsInteger = fsInteger.replace(rgx, '$1' + fsSeparator + '$2');
    }
    this.value = fsInteger + fsDecimal;
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Input.prototype.render = function () {
    this.dom.domObject = XDOM.createElement("INPUT", this.id, this.getCssClass());
    this.dom.domObject.name = this.id;
    this.dom.domObject.type = "text";
    this.dom.domObject.maxLength = this.maxLength;
    this.dom.domObject.setAttribute("data-panel-id", this.panelId);
    this.dom.domObject.setAttribute("data-prompt-field", false);
    this.dom.domObject.setAttribute("autocomplete", "off");
    this.dom.domObject.setAttribute("data-datatype", GUI.translateDefinition.dataTypeReverse[this.dataType]);
    this.dom.domObject.setAttribute("data-real-name", this.realName);
    this.dom.domObject.setAttribute("data-line", this.y);
    this.dom.domObject.setAttribute("data-xpos", this.x);
    this.dom.domObject.setAttribute("data-focus-action", "INP.handleOnFocus");
    this.dom.domObject.setAttribute("data-blur-action", "INP.handleOnBlur");

    this.dom.domObject.readOnly = !!this.isProtected;

    if(this.signed){
        this.dom.domObject.setAttribute("data-signed", "true");
    }



    GUI.events.register(this.dom.domObject);

    if (this.autoSubmit) {
        XDOM.setAttribute(this.dom.domObject, "data-autosubmit", "true");
    }

    if (this.isRequired) {
        var requiredSymbolObj = XDOM.createElement("span");
        requiredSymbolObj.setAttribute("data-line", this.y);
        requiredSymbolObj.setAttribute("data-xpos", this.x);
        requiredSymbolObj.setAttribute("data-required", "true");
        this.dom.domObject.appendChild(requiredSymbolObj);
    }


    XDOM.setAttribute(this.dom.domObject, "data-unicode", !!this.ucs2);
    XDOM.setAttribute(this.dom.domObject, "data-left-blank", !!this.leftBlank);
    XDOM.setAttribute(this.dom.domObject, "data-left-zero", !!this.LeftZero);
    XDOM.setAttribute(this.dom.domObject, "data-digits", !!this.digitsOnly);
    XDOM.setAttribute(this.dom.domObject, "data-alpha", !!this.Alpha);
    this.dom.domObject.setAttribute("data-to-upper", !!this.upperCase);

    FieldAttribute.setAttentionLevel(this);

    this.setDecimalPropertys();
    this.setPosAndDimentions();
    this.updateState();

    return this.dom.domObject;
};

/**
 * het zetten van eigeneschappen die speciaal voor *DEC datat types zijn
 */
GUI.Input.prototype.setDecimalPropertys = function () {
    if (this.dataType !== ENUM.dataType.decimal) {
        return;
    }

    this.dom.domObject.setAttribute("data-precision", this.precision);
    this.dom.domObject.setAttribute("maxlength", this.maxLength);
    this.dom.domObject.setAttribute("data-scale", this.scale);
    if (this.thousandSeparator) {
        this.dom.domObject.setAttribute("data-thousand-separator", "on");
    }
};

/**
 * @override GuiBaseObject
 */
GUI.Input.prototype.updateState = function () {
    let value = this.value
    this.base(GUI.Input, 'updateState');
    if (!this.dom.domObject) {
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.className = this.getCssClass();

    if (this.dom.domObject.getAttribute("data-thousand-separator") === "on") {
        value = formatThousand(this.value);
    }




    this.dom.domObject.value = value;
    this.dom.domObject.setAttribute("value", value); //adding value as an attribute because of css

};


GUI.Input.prototype.updateByUser = function () {
    this.value = this.dom.domObject.value;
    this.base(GUI.Input, 'updateState');
    if (!this.dom.domObject) {
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.className = this.getCssClass();
};


/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.Input.prototype.getCssClass = function () {
    fsCss = this.base(GUI.Input, 'getCssClass');
    fsCss += ' ' + this.dataType;
    return fsCss;
};


/**
 *
 * keyup handling
 * afhandelen speciale toetsen:
 * esc en f12 voor sluiten scherm
 * fieldprogression (pijltjes gebruik)
 * enter voor submit
 **/
GUI.Input.handleKeyUp = function (e) {
    XDOM.getEventObject(e);
};

/**
 *
 * onchange afhandeling
 * validatie
 * triggers?
 **/
GUI.Input.handleOnChange = function (e) {
    XDOM.getEventObject(e);
};


/* maskedInput */
/* Load Timestamp 13:59:55.656 */
GUI.MaskedInput = function (obj) {
    GUI.MaskedInput.baseConstructor.call(this,obj);
    this.type = 'masked-input';
    this.width = null; //overwrite de definitie deze property mag niet worden gezet
    this.editMask = obj.editMask;
    //this.check = obj.validateMask; //*CHECK | *NOCHECK
    this.check =  (obj.validateMask =="*CHECK") ? true : false;
    this.forFieldProgression = false;
};

XDOM.extendObject(GUI.MaskedInput, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 */
GUI.MaskedInput.prototype.init = function(){
    this.base(GUI.Input, 'init');
    this.setDefaults();
    this.setValue();
};



/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.MaskedInput.prototype.render = function(){
    this.dom.inputObject = XDOM.createElement("INPUT", this.id, this.getCssClass() );
    this.dom.inputObject.name = this.id;
    this.dom.inputObject.type = "text";
    this.dom.inputObject.setAttribute( "data-panel-id", this.panelId);
    this.dom.inputObject.setAttribute( "data-real-name", this.realName);
    this.dom.inputObject.setAttribute( "data-line", this.y);
    this.dom.inputObject.setAttribute( "data-xpos", this.x);
    this.dom.inputObject.setAttribute( "data-validate-mask", this.check);
    this.dom.inputObject.setAttribute( "data-datatype", "*DTA");
    this.dom.inputObject.setAttribute( "data-mask",  this.editMask);
    //this.dom.inputObject.setAttribute( "data-fieldprogression-part",  this.parentObject.fieldProgressionPartId);

    //this.dom.inputObject.setAttribute("data-focus-action","INP.handleOnFocus");
    //this.dom.inputObject.setAttribute("data-blur-action","INP.handleOnBlur");

    //container
    this.dom.domObject = Mask.renderInput(this.dom.inputObject, this.isProtected);

    this.dom.domObject.appendChild(this.dom.inputObject);

    this.setPosAndDimentions();
    this.updateState();

    return this.dom.domObject;
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.MaskedInput.prototype.getCssClass = function(){
    fsCss = this.base(GUI.Input, 'getCssClass');
    fsCss += ' ' + this.dataType;
    return fsCss;
};


/**
 * @override GuiBaseObject
 */
GUI.MaskedInput.prototype.updateState = function(){
    this.base(GUI.MaskedInput, 'updateState');
    var fsCssClasses = this.getCssClass();
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }

    this.dom.domObject.className  = fsCssClasses + ' mask';
    this.dom.inputObject.value = this.value;
    Mask.setValue(this.dom.inputObject, this.value);

};

GUI.MaskedInput.prototype.updateByUser = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.value = this.dom.inputObject.value;
    this.base(GUI.MaskedInput, 'updateState');

    var fsCssClasses = this.getCssClass();

    this.dom.domObject.className  = fsCssClasses + ' mask';

};


//
//GUI.MaskedInput.inOrout = function(){
//  var fsNewFieldId = XDOM.GLOBAL.getAttribute('data-mask-target');
//  var fsPreviousMaskId = XDOM.getAttribute(SESSION.activePage.lastFocusedField , 'data-mask-target');
//  if(fsNewFieldId === fsPreviousMaskId){
//    if(fsPreviousMaskId){
//    	if(XDOM.fieldIsChanged(SESSION.activePage.lastFocusedField)){
//        GUI.MaskedInput.changePart(SESSION.activePage.lastFocusedField);
//      }
//      return;
//    }
//  	//geen masker in of uit en we zitten ook niet in een masker
//  	return;
//  }
//
//  if(fsNewFieldId){
//    /**
//     * focus is op een nieuw masker element we ondhouden de oude waarde
//     */
//     GUI.MaskedInput.setOldValue(fsNewFieldId);
//  }
//  if(fsPreviousMaskId){
//  	/**
//  	 * we verlaten en masker check of er een change is ontstaan
//  	 */
//  	 if(XDOM.fieldIsChanged(fsPreviousMaskId)){
//  	 	 GUI.MaskedInput.changePart(SESSION.activePage.lastFocusedField);
//       GUI.MaskedInput.change(fsPreviousMaskId);
//     }
//  }
//};

//GUI.MaskedInput.changePart = function(fsId){
//  var foInp = XDOM.getObject(fsId);
//  var foMask = foProp.maskElement;
//  var foPanel = XDOM.GLOBAL.getEditWindow();
//
//  if(foPanel.validateField(foInp)){
//    foMask.complete();
//   // foPanel.footer.setMessage();
//  }
//
//};

//GUI.MaskedInput.change = function(fsId){
//	GUI.events.change(fsId);
//  var foInp = XDOM.getObject(fsId);
//  var foProp = definitions.getPropertyObject(fsId);
//  var foPanel = XDOM.GLOBAL.getEditWindow();
//  foProp.mask.complete();
//  foPanel.validateField(foInp);
//};

//GUI.MaskedInput.setOldValue= function (fsId){
//	var foObj = XDOM.getObject(fsId);
//	XDOM.setAttribute(foObj, "data-old-value", foObj.value);
//};

//GUI.MaskedInput.keyUp = function(){
//	if(!GLOBAL.objectProperties.mask){
//	  return;
//	}
//	foPanel = XDOM.GLOBAL.getEditWindow();
//	if(GLOBAL.objectProperties.maskElement){
//  	if(XDOM.GLOBAL.fieldIsChanged()){
//      foPanel.footer.setMessage();//verwijder de boodschap op het scherm
//	    if(GLOBAL.eventSourceElement.value.length >= GLOBAL.eventSourceElement.maxLength){
//	     //foPanel.fieldProgression.next(); //alleen een fieldprogression als er een verandering is
//	     return true;
//	    }
//    }
//    GLOBAL.objectProperties.mask.getValue();
//    if(GLOBAL.charCode==keyCode.F4){
//      var fsMaskTarget = XDOM.GLOBAL.getAttribute('data-mask-target');
//      if(fsMaskTarget){
//        CALFCN.OPNCAL(fsMaskTarget);
//      }
//    }
//    return true;
//  }
//
//  return false;
//};


/* MaskedOutput */
/* Load Timestamp 13:59:55.656 */
GUI.MaskedOutput = function (obj) {
    GUI.MaskedOutput.baseConstructor.call(this, obj);
    this.type = 'maskedOutput';
    this.mask = obj.editMask;
};

XDOM.extendObject(GUI.MaskedOutput, GUI.BaseObject);


GUI.MaskedOutput.isOutputMask = function (foField, foData) {
    if (foData && foData.editMask) {
        foField.isMask = true;
        foField.editMask = foData.editMask;
        foField.validateMask = foData.validateMask;
    }

    return;
};

/**
 * @override GuiBaseObject
 */
GUI.MaskedOutput.prototype.init = function () {
    this.setDefaults();
    this.setValue();
};

/**
 * haalt de waarde op uit de dataset
 */
GUI.MaskedOutput.prototype.setValue = function () {
    this.base(GUI.Output, 'setValue');
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */

GUI.MaskedOutput.prototype.render = function (showInSubfile) {
    this.dom.domObject = XDOM.createElement("output", this.id);
    this.dom.domObject.setAttribute("data-mask", this.mask);

    if (this.parentObject) {
        this.setPosAndDimentions();
    }


    Mask.renderOutput(this.dom.domObject);
    this.updateState();


    if (showInSubfile) {
        [...this.dom.domObject.querySelectorAll("*")].forEach(obj => obj.addEventListener('click', Table.rowClickHandler));
        this.dom.domObject.addEventListener('click', Table.rowClickHandler)
        XDOM.classNameReplaceOrAdd(this.dom.domObject, 'maskInSubfile', 'maskInSubfile');
    }


    return this.dom.domObject;
};


/**
 * @override GuiBaseObject
 */
GUI.MaskedOutput.prototype.updateState = function () {
    this.base(GUI.Output, 'updateState');
    if (!this.dom.domObject) {
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.className = this.getCssClass();
    Mask.setValue(this.dom.domObject, this.value);
};

GUI.MaskedOutput.prototype.getCssClass = function () {
    var fsCss = 'outputMask ' + this.base(GUI.MaskedOutput, 'getCssClass');
    return fsCss;
};





/* output */
/* Load Timestamp 13:59:55.656 */
GUI.Output = function (obj) {
    GUI.Output.baseConstructor.call(this,obj);
    this.dataType = nullWhenEmpty(obj.dataType);
    this.blankWhenZero = nullWhenEmpty(obj.blankWhenZero);
    this.thousandSeparator  = nullWhenEmpty(obj.thousandSeparator);
    this.decimalSeparator = ',';
    this.scaleCss = '';
    this.maxScaleSystemLimit  = nullWhenEmpty(obj.maxScaleSystemLimit);
    this.maxScaleField = nullWhenEmpty(obj.maxScaleField);
};

XDOM.extendObject(GUI.Output, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.Output.prototype.init = function(){
    this.base(GUI.Output, 'init');

    if(!this.blankWhenZero){
        this.blankWhenZero = ENUM.blankWhenZero.blank;
    }

    if(!this.thousandSeparator){
        this.thousandSeparator = ENUM.thousandSeparator.none;
    }else if(this.thousandSeparator == ENUM.thousandSeparator.period){
        this.decimalSeparator = ',';
    }else if(this.thousandSeparator == ENUM.thousandSeparator.comma){
        this.decimalSeparator = '.';
    }

    this.setDefaults();
    this.setValue();
};

/**
 * haalt de waarde op uit de dataset
 */
GUI.Output.prototype.setValue = function(){

    this.base(GUI.Output, 'setValue');

    XDOM.setAttribute(this.dom.domObject, "data-old-value", this.value);
    XDOM.setAttribute(this.dom.domObject, "data-output-value", this.value);

    if(this.dataType == ENUM.dataType.decimal){
        if(this.blankWhenZero == ENUM.blankWhenZero.blank && isZero(this.value)){
            this.value='';
        }
    }
    if(this.value==''){
        this.value=' ';
    }else{
        this.formatNumber();
    }
};

/**
 * voegd voor een numerieke waarde duizend tekens toe
 */
GUI.Output.prototype.formatNumber = function(){
    if(this.dataType != ENUM.dataType.decimal) {return;}
    this.formatThousandSeparator();
    this.formatMaxScale();

};

GUI.Output.prototype.formatMaxScale = function(){
    if(!this.maxScaleField){return;};
    var maxScale= this.getDataValue(this.maxScaleField);
    var foScale = formatMaxScale(this.value,this.maxScaleSystemLimit, maxScale,this.decimalSeparator);
    this.value = foScale.value;
    this.scaleCss = foScale.cssClass;


};


GUI.Output.prototype.formatThousandSeparator = function(){
    var fsSeparator = '';
    var fsDecimal = '';
    var fsInteger = '';
    var faNumber = null;
    var rgx = /(\d+)(\d{3})/;

    switch(this.thousandSeparator)  {
        case ENUM.thousandSeparator.period:
            fsSeparator = ".";
            break;
        case ENUM.thousandSeparator.comma:
            fsSeparator = ",";
            break;
        case ENUM.thousandSeparator.none:
            return;
            break;
    }


    faNumber = this.value.split(this.decimalSeparator);
    fsInteger = faNumber[0];
    fsDecimal = faNumber.length > 1 ? this.decimalSeparator + faNumber[1] : '';

    while (rgx.test(fsInteger)) {
        fsInteger = fsInteger.replace(rgx, '$1' + fsSeparator + '$2');
    }
    this.value = fsInteger + fsDecimal;
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Output.prototype.render = function(){

    this.dom.domObject = XDOM.createElement("output",this.id, this.getCssClass());
    this.setPosAndDimentions();
    this.updateState();

    FieldAttribute.setAttentionLevel(this);

    return this.dom.domObject;
};



/**
 * @override GuiBaseObject
 */
GUI.Output.prototype.updateState = function(){
    this.base(GUI.Output, 'updateState');
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.className  = this.getCssClass();
    this.dom.domObject.innerText = this.value;

    XDOM.setAttribute(this.dom.domObject, "data-output-value", this.value);
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.Output.prototype.getCssClass = function(){
    fsCss = this.base(GUI.Output, 'getCssClass');
    fsCss += ' ' + this.dataType;
    fsCss += ' ' + this.scaleCss;
    return fsCss;
};
/* memoOut */
/* Load Timestamp 13:59:55.656 */
GUI.MemoOut = function (obj) {
    GUI.MemoOut.baseConstructor.call(this,obj);
    this.dataType = nullWhenEmpty(obj.dataType);
    this.type='memo';
};
XDOM.extendObject(GUI.MemoOut, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.MemoOut.prototype.init = function(){
    this.base(GUI.MemoOut, 'init');
    this.setDefaults();
    this.setValue();
};

/**
 * haalt de waarde op uit de dataset
 */
GUI.MemoOut.prototype.setValue = function(){
    this.base(GUI.MemoOut, 'setValue');
};


/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.MemoOut.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("pre",this.id);
    this.setPosAndDimentions();
    this.updateState();
    return this.dom.domObject;
};



/**
 * @override GuiBaseObject
 */
GUI.MemoOut.prototype.updateState = function(){
    this.base(GUI.MemoOut, 'updateState');
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.className  = this.getCssClass();

    this.dom.domObject.innerText = this.value;
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.MemoOut.prototype.getCssClass = function(){
    fsCss = this.base(GUI.MemoOut, 'getCssClass');
    return fsCss;
};
/* memoIn */
/* Load Timestamp 13:59:55.657 */
GUI.MemoIn = function (obj) {
    GUI.MemoIn.baseConstructor.call(this,obj);
    this.maxLength = obj.maxLength;
    this.forFieldProgression = true;
};

XDOM.extendObject(GUI.MemoIn, GUI.Input);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.MemoIn.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("TEXTAREA", this.id);
    this.dom.domObject.name = this.id;
    this.dom.domObject.maxLength = this.maxLength;
    this.dom.domObject.type="text";
    this.dom.domObject.readOnly = !!this.isProtected;

    XDOM.setAttribute(this.dom.domObject, "data-panel-id", this.panelId);
    XDOM.setAttribute(this.dom.domObject, "data-panel-id", this.panelId);
    XDOM.setAttribute(this.dom.domObject, "autocomplete", "off" );
    XDOM.setAttribute(this.dom.domObject, "data-datatype", this.dataType);
    XDOM.setAttribute(this.dom.domObject, "data-real-name", this.realName);
    XDOM.setAttribute(this.dom.domObject, "data-line", this.y);
    XDOM.setAttribute(this.dom.domObject, "data-xpos", this.x);
    XDOM.setAttribute(this.dom.domObject, "data-prompt-field", false);

    if(this.ucs2){
        this.dom.domObject.setAttribute("data-unicode", "true");
    }
    this.dom.domObject.setAttribute("data-to-upper", !!this.upperCase);
    if(this.autoSubmit){
        XDOM.setAttribute(this.dom.domObject, "data-autosubmit", "true");
    }

    this.setPosAndDimentions();
    this.updateState();
    //this.registerEvents();
    return this.dom.domObject;
};



/* hidden */
/* Load Timestamp 13:59:55.657 */
GUI.Hidden = function(obj) {
    GUI.Hidden.baseConstructor.call(this,obj);
    this.text = '';
    this.constValue = null;
    this.forFieldProgression = false;
};

XDOM.extendObject(GUI.Hidden, GUI.Input);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Hidden.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("input",this.id);
    this.dom.domObject.name = this.name;
    this.dom.domObject.type = "hidden";
    XDOM.setAttribute(this.dom.domObject, "data-panel-id", this.panelId);
    XDOM.setAttribute(this.dom.domObject, "data-datatype", "hidden");
    XDOM.setAttribute(this.dom.domObject, "data-real-name", this.realName);

    this.updateState();
    return this.dom.domObject;
};

GUI.Hidden.prototype.init = function(){
    if(this.value!="*ID"){
        this.constValue = this.value;
    }

    this.setDefaults();
    this.base(GUI.Hidden, 'init');
};

GUI.Hidden.prototype.updateState = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    if(this.constValue){
        this.dom.domObject.value = this.constValue;
    }else{
        this.dom.domObject.value = this.value;
    }
};
/* link */
/* Load Timestamp 13:59:55.657 */
GUI.Link = function (obj) {
    GUI.Link.baseConstructor.call(this,obj);
    this.dataType = nullWhenEmpty(obj.dataType);
    this.protocol = nullWhenEmpty(obj.protocol);
    this.aliasField = nullWhenEmpty(obj.aliasField);
    this.aliasType = nullWhenEmpty(obj.aliasType);
    this.urlType = nullWhenEmpty(obj.urlType);
    this.aliasText = '';
    this.extension = '';
    this.type = 'Link';
};
XDOM.extendObject(GUI.Link, GUI.BaseObject);



GUI.Link.isLink = function(foField, foData){

    if(foField.dataType == "*LNK"){
        foField.protocol 		 = foData.protocol;
        foField.aliasType 	 = foData.aliasType;
        foField.aliasField 	 = foData.aliasField;
        if(foData.urlType == "*HashedUrl"){
            foField.urlType = foData.urlType;
        }
    }

    return;
};

/**
 * @override GuiBaseObject
 */
GUI.Link.prototype.init = function(){
    this.base(GUI.Link, 'init');
    this.setDefaults();
    if(!this.aliasType){
        this.aliasType = ENUM.aliasType.data;
    }
    if(this.aliasType == ENUM.aliasType.data && this.aliasField){ //voor link output
        this.datafield = this.aliasField;
    }
    this.setValue();
};



GUI.Link.prototype.setValue = function(){
    switch(this.aliasType){
        case ENUM.aliasType.label:
            this.aliasText = this.parentObject.captions.get(this.datafield);
            break;
        case ENUM.aliasType.data:
            this.aliasText = this.getDataValue(this.datafield);
            break;
        case ENUM.aliasType.image:
            this.extension = this.getDataValue(this.aliasField);
            break;
    }
    this.base(GUI.Link, 'setValue');
};


/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Link.prototype.render = function(showInSubfile){
    this.dom.domObject = XDOM.createElement("div",this.id, this.getCssClass());
    this.dom.link = XDOM.createElement("a",this.id + "-link");
    this.dom.domObject.appendChild(this.dom.link);

    this.updateState();

    if(showInSubfile){
        XDOM.classNameReplaceOrAdd(this.dom.domObject, 'linkInSubfile', 'linkInSubfile');
    }
    return this.dom.domObject;
};



/**
 * @override GuiBaseObject
 */
GUI.Link.prototype.updateState = function(){
    this.base(GUI.Link, 'updateState');

    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
        this.dom.link = XDOM.getObject(this.id + "-link");
    }

    if(this.value == ""){
        XDOM.removeDOMObject(this.dom.link);
        this.dom.link = XDOM.createElement("a",this.id + "-link");
        this.dom.domObject.appendChild(this.dom.link);
        return;
    }

    switch(this.protocol){
        case ENUM.protocol.http:
            this.dom.link.target = '_blank';

            if(this.value.indexOf("http") === 0)  {
                this.dom.link.href = this.value;
            }else{
                this.dom.link.href = 'http://' + this.value;
            }

            break;
        case ENUM.protocol.file:
            this.dom.link.target = "_blank";
            this.dom.link.href = this.value;
            break;
        case ENUM.protocol.mail:
            this.dom.link.target = "_top";
            this.dom.link.href = 'mailto:"' + this.value + '"';
            break;
    }

    if(this.aliasType == ENUM.aliasType.image){
        XDOM.setAttribute(this.dom.link, "data-alias-field" , this.aliasField);
        XDOM.setAttribute(this.dom.link, "data-alias-type" , this.aliasType);
        XDOM.setAttribute(this.dom.link, "data-protocol" , this.protocol);
        XDOM.setAttribute(this.dom.link, "data-icon" , this.extension);

        this.dom.link.className = 'fa fa-icon dataSectionButton theme-hover-color';

    }

    if(this.urlType == "*HashedUrl"){
        XDOM.removeAttribute(this.dom.link,"target");

        this.dom.link.href 		= "javascript:void(0);";
        XDOM.setAttribute(this.dom.link, "data-url-type" , this.urlType);
        XDOM.setAttribute(this.dom.link, "value" , this.value);
        XDOM.setAttribute(this.dom.link, "data-uri" , this.value);

        XDOM.setAttribute(this.dom.link, "data-click-action" , "Link.handleOnClick");
        XDOM.setAttribute(this.dom.link, "onclick" , "return false;");

        this.dom.link.className = 'fa fa-icon dataSectionButton theme-hover-color';
    }


    this.dom.link.innerHTML = this.aliasText;
    this.dom.domObject.className  = this.getCssClass();

    XDOM.setAttribute(this.dom.link, "data-datatype" , "*LNK");


    if(this.parentObject){
        this.setPosAndDimentions();
    }

};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.Link.prototype.getCssClass = function(){
    return ' text ' + this.base(GUI.Link, 'getCssClass');
};
/* LogicalOut */
/* Load Timestamp 13:59:55.658 */
GUI.LogicalOut = function (obj) {
    GUI.LogicalOut.baseConstructor.call(this,obj);
    this.type = 'LogicalOut';
    this.onValue = obj.onValue;
    //this.defaultValue = nullWhenEmpty(obj.defaultValue);

    if(obj.offValue == "*UNDEF"){
        obj.offValue = "";
    }

    this.offValue = obj.offValue;
};

XDOM.extendObject(GUI.LogicalOut, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.LogicalOut.prototype.init = function(){
    this.base(GUI.LogicalOut, 'init');
    this.setValue();
};

//GUI.LogicalOut.prototype.setValue = function(){
//  this.base(GUI.LogicalOut, 'setValue');
//  if(!this.defaultValue){
//    this.defaultValue = '1';
//  }
//};


/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.LogicalOut.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("p",this.id, this.getCssClass());

    XDOM.setAttribute(this.dom.domObject, "data-datatype", "logical");
    XDOM.setAttribute(this.dom.domObject, "data-real-name", this.realName);
    XDOM.setAttribute(this.dom.domObject, "data-line", this.y);
    XDOM.setAttribute(this.dom.domObject, "data-xpos", this.x);
    XDOM.setAttribute(this.dom.domObject, "data-panel-id", this.panelId);

    this.setPosAndDimentions();
    this.updateState();
    return this.dom.domObject;
};


/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.LogicalOut.prototype.getCssClass = function(){
    fsCss = this.base(GUI.Input, 'getCssClass');
    fsCss += ' checkbox pth-icon dataSectionButton theme-hover-color';

    return fsCss;
};

/**
 * @override GuiBaseObject
 */

GUI.LogicalOut.prototype.updateState = function(){
    this.base(GUI.LogicalIn, 'updateState');
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }

    this.dom.domObject.className  = this.getCssClass();

    if(this.value==this.onValue){
        this.dom.domObject.setAttribute("data-logical-state",   Logical.state.checked);
    }else if(this.offValue == '' || this.value==this.offValue){
        this.dom.domObject.setAttribute("data-logical-state",   Logical.state.unchecked);
    }else{
        this.dom.domObject.setAttribute("data-logical-state",   Logical.state.unknown);
    }
};


/* LogicalIn */
/* Load Timestamp 13:59:55.658 */
GUI.LogicalIn = function (obj) {
    GUI.LogicalIn.baseConstructor.call(this,obj);
    this.type = 'LogicalIn';
    this.onValue = obj.onValue;
    if(obj.offValue == "*UNDEF"){
        obj.offValue = "";
    }

    this.offValue = obj.offValue;
};

XDOM.extendObject(GUI.LogicalIn,GUI.Input);

/**
 * @override GuiBaseObject
 * @returns HTMLhiddenObject
 */
GUI.LogicalIn.prototype.render = function(){
    var foFrag = document.createDocumentFragment();
    this.dom.domObject =  XDOM.createElement("a",this.id );
    this.dom.domObject.type='button';

    XDOM.setAttribute(this.dom.domObject, "data-datatype", "logical");
    XDOM.setAttribute(this.dom.domObject, "data-real-name", this.realName);
    XDOM.setAttribute(this.dom.domObject, "data-line", this.y);
    XDOM.setAttribute(this.dom.domObject, "data-xpos", this.x);
    XDOM.setAttribute(this.dom.domObject, "data-panel-id", this.panelId);
    XDOM.setAttribute(this.dom.domObject, "data-prompt-field", false);

    if(this.autoSubmit){
        XDOM.setAttribute(this.dom.domObject, "data-autosubmit", "true");
    }

    this.dom.hiddenObject = XDOM.createElement("input",this.id + '-out');
    this.dom.hiddenObject.name = this.name;
    this.dom.hiddenObject.type = "hidden";


    XDOM.setAttribute(this.dom.hiddenObject, "data-panel-id", this.panelId);
    XDOM.setAttribute(this.dom.hiddenObject, "data-datatype", "*LGL");
    XDOM.setAttribute(this.dom.hiddenObject, "data-real-name", this.realName);
    XDOM.setAttribute(this.dom.hiddenObject, "data-on-value", this.onValue);
    XDOM.setAttribute(this.dom.hiddenObject, "data-off-value", this.offValue);


    foFrag.appendChild(this.dom.hiddenObject);
    foFrag.appendChild(this.dom.domObject);

    this.registerEvents();
    this.updateState();
    return foFrag;

};

GUI.LogicalIn.prototype.registerEvents = function(){
    GUI.events.register(this.dom.domObject);
    this.dom.domObject.setAttribute("data-click-action","GUI.LogicalIn.handleOnClick");
    this.dom.domObject.setAttribute("data-keyup-action","GUI.LogicalIn.handleKeyUp");
};

GUI.LogicalIn.prototype.toggle = function(){
    if(this.value==this.onValue){
        this.value= this.offValue;
    }else{
        this.value= this.onValue;
    }
    this.dom.hiddenObject.value = this.value;
};

GUI.LogicalIn.prototype.updateByUser = function(){
    this.base(GUI.Input, 'updateState');
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.className  = this.getCssClass();
    if(this.isProtected){}
};

/**
 * @override GuiBaseObject
 */
GUI.LogicalIn.prototype.updateState = function(){
    this.base(GUI.LogicalIn, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
    this.dom.hiddenObject.value = this.value;

    if(this.value==this.onValue){
        this.dom.domObject.setAttribute("data-logical-state",   Logical.state.checked);
    }else if(this.offValue == '' || this.value==this.offValue){
        this.dom.domObject.setAttribute("data-logical-state",   Logical.state.unchecked);
    }else{
        this.dom.domObject.setAttribute("data-logical-state",   Logical.state.unknown);
    }

    //this.isProtected = false;
    //if(XDOM.getAttribute(this.dom.domObject, 'data-protected') == 'true'){
    // 	this.isProtected = true;
    //}
};




/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.LogicalIn.prototype.getCssClass = function(){
    fsCss = this.base(GUI.Input, 'getCssClass');
    fsCss += ' checkbox pth-icon dataSectionButton theme-hover-color ';

    return fsCss;
};

GUI.LogicalIn.toggle = function(fsId){
    var foPanel 		= XDOM.GLOBAL.getEditWindow();
    var foGuiObj 		= foPanel.getGuiObject(fsId);

    if(foGuiObj.isProtected){
        return;
    }

    foGuiObj.toggle();
    GUI.events.change(XDOM.getObject(fsId));
    foGuiObj.updateState();
};

GUI.LogicalIn.handleKeyDown = function(e){
    XDOM.getEvent(e);
    OCULUS.checkKeyCode(e);
    XDOM.setSelection();
    if(GLOBAL.charCode==keyCode.enter){
        XDOM.cancelEvent(e);
        foPanel.send('ACCEPT',XDOM.GLOBAL.getAttribute('data-real-name'));
    }
};

GUI.LogicalIn.handleKeyUp = function(){

    if(isLogical(GLOBAL.eventSourceElement) && GLOBAL.charCode==keyCode.space){
        GUI.LogicalIn.toggle(GLOBAL.eventSourceElement.id);
        return true;
    }
};

GUI.LogicalIn.handleOnClick = function(){
    GUI.LogicalIn.toggle(GLOBAL.eventSourceElement.id);
};

/* sessionMenuBtn */
/* Load Timestamp 13:59:55.658 */
/*remove file*/
/* procedureBtn */
/* Load Timestamp 13:59:55.658 */
///**
// * GUI.SessionTab losses tab
// * @param session sessie object waar deze tab bij hoort
// */
//GUI.ProcedureBtn = function(subProcedure, width, row){
//  this.id = subProcedure.optionNr;
//  this.row = row;
//  this.title = subProcedure.title;
//  this.subProcedure = subProcedure;
//  this.dom = {};
//  this.fsCssClasses = "btnDefault col buttonLength"+width;
//  //this.fsCssClasses = "btnDefault col-md-auto buttonLength"+width;
//  this.infoTitle = null;
//  //this.containingDiv = "sessionContentWrapper";
//};
//GUI.ProcedureBtn.currentInstance = null;
//GUI.ProcedureBtn.hovered= null;
//
//GUI.ProcedureBtn.handleClick = function(fsId){
//	var foNewInstance = SESSION.stack.currentProcedure.buttonInstances[fsId].subProcedure;
//  var foSubProcedure = null;
//
//	if(GUI.ProcedureBtn.currentInstance && GUI.ProcedureBtn.currentInstance.subProcedure == foNewInstance){
//		return; //niet mogelijk om op de actieve knop te klikken
//	}
//
//  Search.close();
//  if(GUI.ProcedureBtn.currentInstance){
//    GUI.ProcedureBtn.currentInstance.deactivate();
//  }
//
//  foSubProcedure = foNewInstance;
//  SESSION.stack.clearHistory(SESSION.stack.currentProcedure);
//  foSubProcedure.load();
//};
//
//GUI.ProcedureBtn.handleMouseDown = function(){
//	//prevent blur action while navigate
//	SESSION.session.cancelBlurEvent = true;
//};
//
//
///**
// * opbouwen van tab
// */
//GUI.ProcedureBtn.prototype.render = function(){
//
//  //var foParent =           XDOM.getObject('MVCPRCR' + this.row);
//  var foParent =           XDOM.getObject('MVCPRCR1');
//
//  this.dom.domObject =     XDOM.createElement("DIV","prcBtn"+this.id, this.fsCssClasses);
//  //this.dom.ieRadius =      XDOM.createElement("DIV","iePrcRadius"+this.id ,"ieRadiusMaskSmall");
//  this.dom.backGround =    XDOM.createElement("DIV","prcBackGround"+this.id,"contentSubMenuBtnBg");
//
//  this.dom.domObject.appendChild(this.dom.backGround);
//  //this.dom.domObject.appendChild(this.dom.ieRadius);
//  //this.dom.ieRadius.appendChild(this.dom.backGround);
//
//  this.dom.backGround.appendChild(XDOM.createTextNode(this.subProcedure.description));
//  foParent.appendChild(this.dom.domObject);
//
//  SESSION.stack.currentProcedure.buttonInstances[this.id] = this;
//  this.registerEvents();
//};
//
//GUI.ProcedureBtn.prototype.cleanUp = function(){
//  this.dom.domObject = null;
//  this.dom.backGround = null;
//  this.subProcedure = null;
//};
//
//
//GUI.ProcedureBtn.prototype.activate = function(){
//  if(this.subProcedure.available){
//     this.dom.domObject.className = this.fsCssClasses+" activeBtn";
//     GUI.ProcedureBtn.currentInstance = this;
//
//  }
////  GUI.infoTitle.hide();
//};
//
//GUI.ProcedureBtn.prototype.deactivate = function(){
//  this.dom.domObject.className = this.fsCssClasses;
//};
//
//GUI.ProcedureBtn.prototype.registerEvents = function(){
//  var fsId = this.id;
//  var fsTitle = this.title+' - '+this.subProcedure.subProcedureName;
//  if(this.subProcedure.available){
//	  XDOM.addEventListener(this.dom.domObject,"click", function(){GUI.ProcedureBtn.handleClick(fsId);});
//	  XDOM.addEventListener(this.dom.domObject,"mousedown", function(){GUI.ProcedureBtn.handleMouseDown();});
//	  GUI.infoTitle.register(this.dom.domObject ,fsTitle);
//	}else{
//		 this.dom.backGround.className += ' unavailable';
//	}
//};

/* retrieve */
/* Load Timestamp 13:59:55.659 */
/* global GUI, XDOM, ENUM */

GUI.Retrieve = function(obj){

    GUI.Retrieve.baseConstructor.call(this,obj);
    this.toId = obj.toId;
    this.serviceSource = obj.serviceSource;
    this.whenField = obj.whenField;
    this.whenValue = obj.whenValue;
    this.datafield = obj.toId;
    this.service = null;
};

XDOM.extendObject(GUI.Retrieve, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.Retrieve.prototype.init = function(){
    if(!this.datafield){
        this.datafield = this.toId;
    }
    this.base(GUI.Retrieve, 'init');
    this.service = this.parentObject.services.get(this.serviceSource);



    this.setDefaults();
    this.setValue();
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Retrieve.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("div",this.id);
    this.dom.domObject.setAttribute("data-to-id", this.panelId + '-' + this.toId);
    this.dom.domObject.setAttribute("data-service-type", ENUM.serviceType.retrive);
    this.dom.domObject.setAttribute("data-panel-id", this.panelId);
    this.setPosAndDimentions();
    this.updateState();
    return this.dom.domObject;
};


/**
 * haalt de waarde op uit de dataset
 * @param obj
 */
GUI.Retrieve.update = function(obj){
    var panel = XDOM.getEditWindow(obj);
    if(!panel){
        return false;
    }

    var retrieve = panel.guiObjects[obj.id];
    retrieve.updateByUser();
    return true;

};

GUI.Retrieve.prototype.updateByUser = function(){
    var toValue = XDOM.getObjectValue(this.panelId + '-' + this.toId);
    this.value = this.service.get(toValue);
    this.dom.domObject.innerHTML = this.value;
};
/**
 * haalt de waarde op uit de dataset
 */
GUI.Retrieve.prototype.setValue = function(){
    this.base(GUI.Output, 'setValue');
    if(this.value !==''){
        if(this.service){
            this.value = this.service.get(this.value);
        }else{
            this.value ='';
        }
    }
};
/**
 * @override GuiBaseObject
 */
GUI.Retrieve.prototype.updateState = function(){
    this.base(GUI.Output, 'updateState');
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    if(!this.allowShow()){
        this.dom.domObject.style.display='none';
        return;
    }
    this.dom.domObject.className  = this.getCssClass();
    this.dom.domObject.innerHTML = this.value;
    this.dom.domObject.style.display='';
};

/**
 * controleert of dit retrieve veld mag worden getoond
 * dit mag alleen als:
 * 1 het veld: "whenField" is gedefinieerd en de waarde komt overeen met het veld "whenValue" en het veld value is niet leeg
 * 2 het veld: "whenField" is '' meer het value is niet leeg
 * @returns {boolean}
 */
GUI.Retrieve.prototype.allowShow = function(){
    if(this.value===''){
        return false;
    }
    if(this.whenField && this.getDataValue(this.whenField) !== this.whenValue){
        return false;
    }
    return true;
};


/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.Retrieve.prototype.getCssClass = function(){
    var fsCss = this.base(GUI.Output, 'getCssClass');
    return fsCss;
};
/* image */
/* Load Timestamp 13:59:55.659 */
GUI.Image = function(obj) {
    GUI.Image.baseConstructor.call(this,obj);
    this.uri = obj.imageURI;
    this.image = null;
    this.sizesInPixels = true; //de grote wordt niet bepaald door css maar als width en height
    this.errorMsgObj = null;
};

XDOM.extendObject(GUI.Image, GUI.BaseObject);

/**
 * @override GuiBaseObject
 */
GUI.Image.prototype.init = function(){
    this.base(GUI.Image, 'init');
    GUI.Images[this.id] = this;
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Image.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("DIV",this.id);
    var foImage =  new Image();
    //this.setPosAndDimentions();

//  var fiMaxHeightPx =   this.parentObject.getHeightPx(this.height);
    var fiMaxWidthtPx =  this.parentObject.getWidthPx(this.width);

    //if(parseInt(fiMaxHeightPx)<= 0){ fiMaxHeightPx = "none"; }
    if(parseInt(fiMaxWidthtPx)<= 0){ fiMaxWidthtPx = "none"; }

    foImage.id = this.id+"_IMG";
    foImage.style.maxWidth  = '100%';
    foImage.style.height  = 'auto';
    foImage.style.width 	= 'auto';
    foImage.style.cursor = '-webkit-zoom-in';
    foImage.setAttribute("data-click-action", "oculusImage.expand" );

    this.dom.domObject.appendChild(foImage);
    this.dom.domObject.className  = this.getCssClass();
    if(this.height) {
        foImage.style.maxHeight = '100%';
        this.dom.domObject.className  += ' lines'+int2css(this.height, 2);
    }
    this.dom.image = foImage;
    this.updateState();
    return this.dom.domObject;
};


/**
 * @override GuiBaseObject
 */
GUI.Image.prototype.updateState = function(){
    this.base(GUI.Image, 'updateState');

    if(this.value){
        this.dom.image.src = this.value;
    }else if(this.uri){
        this.dom.image.src = this.currentData[this.uri];
    }else{
        GUI.Image.onError(this.dom.image);
        return;
    }

    GUI.Image.onSucces(this.dom.image);
    //this.dom.image.onerror = function(){this.dom.image.onerror(this.dom.image);};

};

GUI.Image.prototype.onError = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.dom.domObject.appendChild(this.dom.errorMessage);
};

GUI.Images ={};


GUI.Image.onError = function(foImage){

    if(XDOM.getObject("imgError")){
        return;
    }

    var foParent = foImage.parentNode;
    foImage.style.display = "none";

    this.errorMsgObj = XDOM.createElement("p","imgError",null);
    foParent.appendChild(this.errorMsgObj);
};

GUI.Image.onSucces = function(foImage){

    if(XDOM.getObject("imgError")){

        var foParent = foImage.parentNode;
        foImage.style.display = "block";

        XDOM.removeDOMObject(this.errorMsgObj);
    }

};


/* subProcedureTab */
/* Load Timestamp 13:59:55.659 */
GUI.subProcedureTab = function(macro){
    this.id = macro.id;
    this.macro = macro;
    this.domObjectId = '';
    this.fsCssClasses = null;
    this.label = null;
    this.btnPos = this.id + 1;
};

//GUI.subProcedureTab.currentInstance = null;
//GUI.subProcedureTab.prototype.render = function(width, btnPosition, totalTabs){
//  //var fsTitle = this.macro.title+' (CTRL+'+this.btnPos+') '+this.macro.macroName;
//  var fsTitle 	= this.macro.title+' (CTRL+'+btnPosition+') '+this.macro.macroName;
//  var domObject = null;
//  var domParent = XDOM.getObject('TABDIV');
//  var fsId 			= this.id;
//  this.fsCssClasses 	= "tabLength"+width;
//  this.domObjectId 		= "btnPos"+btnPosition;
//  domObject 					= XDOM.createElement("input",this.domObjectId, this.fsCssClasses);
//  domObject.type 			= 'button';
//  domObject.value 		= this.macro.description;
//
//  domParent.appendChild(domObject);
//
//  SESSION.stack.currentSubprocedure.tabInstances[this.id] = this;
//
//  GUI.infoTitle.register(domObject, fsTitle);
//  XDOM.addEventListener(domObject,"click", function(){GUI.subProcedureTab.handleClick(fsId);});
//};

//GUI.subProcedureTab.prototype.cleanUp = function(){
//  this.macro = null;
//};


/**
 * vernieuwen van dom objects dit is nodig voor ie die soms geen toegang meer heeft tot het dom object en dan een access denied fout geeft
 **/
//GUI.subProcedureTab.prototype.refreshDomObjects = function(){};

//GUI.subProcedureTab.prototype.activate = function(){
//	var obj = XDOM.getObject(this.domObjectId);
//  if(obj){
//    obj.className = this.fsCssClasses+" active";
//	  GUI.subProcedureTab.currentInstance = this;
//	}
//};


//GUI.subProcedureTab.prototype.deactivate = function(){
//	var obj = XDOM.getObject(this.domObjectId);
//	if(obj){
//    obj.className = this.fsCssClasses;
//  }
//};

//GUI.subProcedureTab.handleClick = function(fsId){
//  var foNewInstance = null;
//  if(SESSION.submitInProgress){
//  	//er is al een submit het laden van de nieuwe macro wordt uitgesteld tot na de onload
//  	SESSION.NextMacroId = fsId;
//  	return;
//  }
//  SESSION.NextMacroId = null;
//
//  foNewInstance = SESSION.stack.currentSubprocedure.tabInstances[fsId];
//
//	if(GUI.subProcedureTab.currentInstance == foNewInstance){
//		return; //niet mogelijk om op de actieve knop te klikken
//	}
//
//  if(GUI.subProcedureTab.currentInstance){
//    GUI.subProcedureTab.currentInstance.deactivate();
//  }
//
//
//  //sla de subfile postitie op ivm met terug keren naar ML
//  Subfile.storeSubfilePos();
//
//  GUI.subProcedureTab.currentInstance = foNewInstance;
//  SESSION.stack.clearHistory(SESSION.stack.currentSubprocedure);
//  GUI.subProcedureTab.currentInstance.macro.load();
//
//};
/* dataSet */
/* Load Timestamp 13:59:55.660 */
GUI.DataSet = function(obj) {
    GUI.DataSet.baseConstructor.call(this,obj);
    this.dataType = nullWhenEmpty(obj.dataType);
    this.definition = obj;
    this.recordHeight = null;
    this.headerHeight = null;
    this.footerHeight = null;
    this.recordRows = null;
    this.headerRows = null;
    this.footerRows = null;
    this.subfileObjects = [];
    this.headerObjects = [];
    this.footerObjects = [];
    this.text = '';
    this.widthPx = null;
    this.sizesInPixels = true; //de grote wordt niet bepaald door css maar als width en height
};

XDOM.extendObject(GUI.DataSet, GUI.BaseObject);

GUI.DataSet.prototype.init = function(){
    this.base(GUI.DataSet, 'init');
    var faSubfileElements = this.definition.subfile;
    var faHeaderElements = this.definition.header;
    var faFooterElements = this.definition.footer;
    var foObjDev = null;
    var foGuiObject = null;
    var currentRow = 0;
    var currentHeight = null;

    this.setDefaults();

    this.captions = this.parentObject.captions;


    for(var i = 0, l = faSubfileElements.length;i<l;i++){
        foObjDev = faSubfileElements[i];


        foGuiObject = GUI.factory.get(foObjDev, this);

        currentRow = parseInt(foGuiObject.y);
        currentHeight = parseInt(foGuiObject.height);
        if(!isNaN(currentHeight)){
            currentRow +=currentHeight;
        }
        if(currentRow > this.recordRows){
            this.recordRows = currentRow;
        }


        foGuiObject.rowNumber = i;
        foGuiObject.partOff = GUI.DataSet.Part.record;
        foGuiObject.init();
        this.subfileObjects[foGuiObject.id]=foGuiObject;
    }




    currentHeight = 0;
    currentRow = 0;
    for(var i = 0, l = faHeaderElements.length;i<l;i++){
        foObjDev = faHeaderElements[i];


        foGuiObject = GUI.factory.get(foObjDev);

        currentRow = parseInt(foGuiObject.y);
        currentHeight = parseInt(foGuiObject.height);
        if(!isNaN(currentHeight)){
            currentRow +=currentHeight;
        }
        if(currentRow > this.headerRows){
            this.headerRows = currentRow;
        }
        foGuiObject.partOff = GUI.DataSet.Part.header;
        foGuiObject.parentObject = this;
        foGuiObject.init();
        this.headerObjects[foGuiObject.id]=foGuiObject;
    }



    currentHeight = 0;
    currentRow = 0;
    for(var i = 0, l = faFooterElements.length;i<l;i++){
        foObjDev = faFooterElements[i];
        foGuiObject = GUI.factory.get(foObjDev, this);
        currentRow = parseInt(foGuiObject.y);
        currentHeight = parseInt(foGuiObject.height);
        if(!isNaN(currentHeight)){
            currentRow +=currentHeight;
        }
        if(currentRow > this.footerRows){
            this.footerRows = currentRow;
        }
        foGuiObject.partOff = GUI.DataSet.Part.footer;
        foGuiObject.init();
        this.footerObjects[foGuiObject.id]=foGuiObject;
    }

    if(this.headerRows){this.headerRows++;}
    if(this.footerRows){this.footerRows++;}
    this.recordRows++;
    this.headerHeight = this.parentObject.sizes.lineHeight  * (this.headerRows);
    this.footerHeight = this.parentObject.sizes.lineHeight  * (this.footerRows);
    this.bodyHeight = this.parentObject.sizes.lineHeight  * (this.height-this.headerRows-this.footerRows);
    this.footerHeight += 'px';
    this.headerHeight += 'px';
    this.bodyHeight += 'px';

    this.recordHeight = this.parentObject.sizes.lineHeight * this.recordRows + 'px';


};


GUI.DataSet.prototype.resetHeight = function(height){
    this.height+=height;
    this.bodyHeight = this.parentObject.sizes.lineHeight  * (this.height-this.headerRows-this.footerRows);
    this.bodyHeight += 'px';
};



/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.DataSet.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("DIV",this.id,'dataset');
    this.setPosAndDimentions(this);
    this.renderHeader();
    this.renderBody();
    this.renderFooter();
    this.updateState();
    return this.dom.domObject;
};


GUI.DataSet.prototype.renderBody = function(){
    this.dom.body = XDOM.createElement( 'DIV', "dataset-body-" + this.id, "dataset-Body");
    this.dom.body.style.height = this.bodyHeight;
    for(var i =0,l=this.subfileData.length;i<l;i++){
        this.renderRecord(i);
    }
    this.dom.domObject.appendChild(this.dom.body);
};



GUI.DataSet.prototype.renderRecord = function(i){
    var foRecordDiv = XDOM.createElement( 'DIV', "dataset-record-" + i, "dataset-record");
    foRecordDiv.style.height = this.recordHeight;
    for(var id in  this.subfileObjects){

        this.subfileObjects[id].currentData = this.subfileData[i];
        this.subfileObjects[id].setValue();
        foRecordDiv.appendChild( this.subfileObjects[id].render());
    }
    this.dom.body.appendChild(foRecordDiv);
};




GUI.DataSet.prototype.renderFooter = function(){
    this.dom.footer = XDOM.createElement( 'DIV', "dataset-footer-" + this.id, "dataset-footer");
    this.dom.footer.style.height = this.footerHeight;
    for(var id in  this.footerObjects){
        this.footerObjects[id].currentData = this.currentData;
        this.footerObjects[id].setValue();
        this.dom.footer.appendChild( this.footerObjects[id].render());
    }
    this.dom.domObject.appendChild(this.dom.footer);
};

GUI.DataSet.prototype.renderHeader = function(){
    this.dom.header = XDOM.createElement( 'DIV', "dataset-header-" + this.id, "dataset-header");
    this.dom.header.style.height = this.headerHeight;
    for(var id in  this.headerObjects){
        this.headerObjects[id].currentData = this.currentData;
        this.headerObjects[id].setValue();
        this.dom.header.appendChild( this.headerObjects[id].render());
    }
    this.dom.domObject.appendChild(this.dom.header);
};










/**
 * @override GuiBaseObject
 */
GUI.DataSet.prototype.updateState = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }
    this.base(GUI.DataSet, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
};


GUI.DataSet.prototype.setPosAndDimentions = function(obj){
    var fiColWidth = 100/ this.width;
    if(obj==this){ //zichzelf wel renderen als onderdeel van parent maar niet voor onderdelen die genest zijn
        this.base(GUI.DataSet, 'setPosAndDimentions');
        return;
    }


    obj.dom.domObject.style.top = this.parentObject.sizes.lineHeightPx * (obj.y -.5) + 'PX';

    if(obj.width){
        obj.dom.domObject.style.width = floor(obj.width * fiColWidth ,2) + "%";
    }

    if(obj.height){
        obj.dom.domObject.style.height = this.parentObject.sizes.lineHeightPx * obj.height + "px";
    }

    obj.dom.domObject.style.left = floor(obj.x * fiColWidth ,2) + "%";// this.parentObject.sizes.colWidthPx * obj.x + 'px';

};

GUI.DataSet.prototype.getHeightPx = function(nr){
    return nr * 20 + "px";
    //return this.parentObject.getHeightPx(nr);
};

GUI.DataSet.prototype.getWidthPx = function(nr){
    return nr * 7 + "px";
};

GUI.DataSet.Part = {'header':'header','footer':'footer','record':'record'};




/* constant */
/* Load Timestamp 13:59:55.660 */
GUI.Constant = function(obj) {
    GUI.Label.baseConstructor.call(this,obj);
    this.constant = obj.constant;
};

XDOM.extendObject(GUI.Constant, GUI.Label);

/**
 * @override GuiBaseObject
 */
GUI.Constant.prototype.init = function(){
    this.base(GUI.Constant, 'init');
    this.setDefaults();
};

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.Constant.prototype.render = function(){
    this.dom.domObject = XDOM.createElement("LABEL",this.id);
    this.dom.domObject.innerHTML = this.constant; //innerHTML i.v.m. ge-scapede codes
    this.dom.domObject.setAttribute("data-const-value",this.constant )
    this.setPosAndDimentions();
    this.updateState();
    return this.dom.domObject;
};
/* SessionLauncher */
/* Load Timestamp 13:59:55.660 */

GUI.SessionLauncher = function(obj) {
    GUI.SessionLauncher.baseConstructor.call(this,obj);
    this.environment=obj.environment;

    this.environmentField = obj.environmentField;
    this.datafield = this.environmentField;
    this.authorizedFor = obj.authorizedFor;
    this.location=obj.location;
    this.locationType=obj.locationType;
    this.parms=obj.parms;
    this.formFields=obj.formFields;
    this.label=obj.label;
    this.title=obj.title;
    this.whenField=obj.whenField;
    this.whenValue=obj.whenValue;
    this.value = '';
};

XDOM.extendObject(GUI.SessionLauncher, GUI.BaseInputObject);

/**
 * @override GuiBaseObject
 * @returns HTMLDomObject
 */
GUI.SessionLauncher.prototype.render = function(){
    var fsLabel=  this.parentObject.captions.get(this.label);
    var fsTitle=  this.parentObject.captions.get(this.title);
    this.dom.domObject = XDOM.createElement("DIV",this.id,"launchSessionPlaceHolder");
    this.dom.icon = XDOM.createElement("DIV",this.id + "_icon","launchSessionButton pth-newSession dataSectionButton theme-hover-color");
    this.dom.label = XDOM.createElement("label",this.id + "_label","launchSessionLabel");

    this.dom.domObject.appendChild(this.dom.icon);
    this.dom.domObject.appendChild(this.dom.label);

    this.dom.label.appendChild(XDOM.createTextNode(fsLabel));

    this.dom.icon.setAttribute("data-new-session-id", this.id);
    this.dom.icon.setAttribute("data-new-session-environment", this.environment);
    this.dom.icon.setAttribute("data-new-session-environment-field-id",this.environmentField);
    this.dom.icon.setAttribute("data-new-session-authorized-for",this.authorizedFor);

    this.dom.icon.setAttribute("data-new-session-location", this.location);
    this.dom.icon.setAttribute("data-new-session-location-type", this.locationType);
    this.dom.icon.setAttribute("data-new-session-params", this.parms);
    this.dom.icon.setAttribute("data-new-session-form-fields", this.formFields);
    this.dom.icon.setAttribute("data-new-session-title",fsLabel);
    this.dom.icon.setAttribute("data-new-session-description",fsTitle);

    this.dom.icon.setAttribute("data-when-field", this.whenField);
    this.dom.icon.setAttribute("data-when-value", this.whenValue);

    GUI.infoTitle.register(this.dom.icon, fsTitle);

    this.setPosAndDimentions();
    this.updateState();
    return this.dom.domObject;
};

GUI.SessionLauncher.prototype.init = function(){
    this.base(GUI.SessionLauncher, 'init');
    var faFields = this.formFields.split(' ');
    for(var i = 0, l=faFields.length;i<l;i++){
        faFields[i] = this.panelId + '-' + faFields[i];
    }
    this.formFields = faFields.join(' ');
};


GUI.SessionLauncher.prototype.registerEvents = function(){

};



/**
 * @override GuiBaseObject
 */
GUI.SessionLauncher.prototype.updateState = function(){
    if(!this.dom.domObject){
        this.dom.domObject = XDOM.getObject(this.id);
    }

    this.base(GUI.SessionLauncher, 'updateState');
    this.dom.domObject.className  = this.getCssClass();
    this.setValue();
    NAV.sessionLauncher.authorize(this.dom.icon);
};

/**
 * @override GuiBaseObject
 * @returns cssClasses
 */
GUI.SessionLauncher.prototype.getCssClass = function(){
    var fsCssClass =  this.base(GUI.SessionLauncher, 'getCssClass');
    fsCssClass +=" sessionLauncher";
    return fsCssClass;
};


/**
 * haalt de waarde op uit de dataset
 */
GUI.SessionLauncher.prototype.setValue = function(){
    this.base(GUI.SessionLauncher, 'setValue');
    if(this.environmentField){
        this.dom.icon.setAttribute("data-new-session-environment", this.value);
    }else{
        this.dom.icon.setAttribute("data-new-session-environment",SESSION.enviroment);
    }

};
/* templates */
/* Load Timestamp 13:59:55.660 */
const template = {};

template.session = {};
template.session.tab = function (def) {
    return `<div class="sessionTabContainer ${def.fixed}"
              data-default-theme = "${def.defaultTheme}" 
              data-admin-id = "${def.IDT}"
              
              >
            <a  data-last-open="true"
                role="button" tabindex="0"
                class="sessionTab theme-border-color theme-inactive-background-color"
                data-color = "${def.color}"
                data-event-class="SessionTab"
                data-hotkey-handler="SessionTab"
                data-focus = ""
                data-session-job-nr="${def.jobNr}"
                data-enviroment = "${def.ENV}"
                data-admin-id = "${def.IDT}"
                data-administration-name = "${def.adminName}"
                data-session-description = "${def.DSC}"

            >
                <i data-font-color="alert" data-hidden="true" class="pth-exclamation-triangle"></i>
                <span >${def.DSC}</span>
                <i class="pth-close closeIcon" data-event-class="SessionTab" data-click="close" ></i>
            </a>
    </div>`;
};

template.session.hometab = function (def) {
    return `<div class="sessionTabContainer"
               data-homepage= "true"
               data-default-theme = "${def.defaultTheme}"  data-admin-id = "${def.IDT}">
             <a role="button" tabindex="0"  class="sessionTab theme-border-color theme-inactive-background-color"
                 data-color = "${def.color}"
                 data-event-class="SessionTab"
                 data-hotkey-handler="SessionTab"
                 data-focus = ""
                 data-session-job-nr="${def.jobNr}"
                 data-admin-id = "${def.IDT}"
                 data-enviroment = "${def.ENV}"
                 data-administration-name = "${def.adminName}"
                 data-session-description = "${def.DSC}"

             >
                 <i data-font-color="alert" data-hidden="true" class="pth-exclamation-triangle"></i>
                 <i class="pth-home homeTab theme-font-color"></i>
                 ${template.session.hometab.closeButton()}
                 
             </a>
     </div>`;
};
template.session.hometab.closeButton = () => {
    if (SCOPE.main.Settings.get('ALLOW_CLOSE_HOME')) {
        return '<i class="pth-close closeIcon" data-event-class="Home" data-click="closeTab" ></i>'
    }
    return '';
};

template.mainMenu = {};


template.subProcedure = {};
template.subProcedure.dummy = `<div class="  col-md float-left subProcedureBtnContainer" ></div>`;
template.subProcedure.title = function (def) {
    return `<span  class="subprocedure-single-button-title">${def.option.DSC} (${def.option.TTL}) - ${
        def.option.SBP
    }</span>`;
};

//theme-active-background-color theme-active-border-color theme-focus-background-color theme-focus-border-color theme-hover-background-color

template.subProcedure.fixedButton = function (maxWidth, def, hidden = false) {
    return `
    <div class=" col-md float-left subProcedureBtnContainer" data-enable-max-width="${maxWidth}" data-hidden="${hidden}">
        <a  role="button" tabindex="0" class="subProcedureBtn theme-active-background-color theme-hover-background-color"
            data-event-class="SubProcedureButton"
            data-hotkey-handler="SubProcedureButton"
            data-focus = ""
            data-fixed="true"
            data-hidden=${def.hidden || 'false'}
            data-available="${def.available}"
            data-nr="${def.optionNr}"
            title="${def.option.TTL} (${def.option.SBP})"
            ${XDOM.Def2Attributes(def.option)} >
            <span class="">${def.option.DSC}</span>
        </a>
    </div>`;
};

template.subProcedure.dropDownOneButton = function (def) {
    return `<div class="container-full dropdown-content theme-active-background-color theme-focus-background-color theme-focus-border-color" data-hidden="true">
                    <div class="row row-no-margin row-no-padding row-subprocedure-menu" >
                        <div role="button" tabindex="0" data-hidden="true" data-only-option="true" ${XDOM.Def2Attributes(
        def
    )} ></div>
                    </div>
                </div>`;
};

template.subProcedure.dropDownButton = function (def) {
    return `
    <div role="button" tabindex="0" class=" float-left dropdown-item"
        data-event-class="SubProcedureButton"
        data-hotkey-handler="SubProcedureButton"
        data-available="${def.available}"
        data-focus = ""
        title="${def.option.TTL} (${def.option.SBP})"
        ${XDOM.Def2Attributes(def.option)} >
        <!--${userOrDevTitle(def.option.TTL, def.option.SBP)}-->
        <span class="">${def.option.DSC}</span>
    </div>`;
};

/*
template.subProcedure.doubleRow = function(buttons){
    return `
    <div class="container-full" >
        <div class=" row row-no-margin row-no-padding ">
            <div class="col-lg-12 col-xl-6 float-left" >
                <div class=" row row-no-margin row-no-padding row-subprocedure-menu">
                    ${buttons[0]}
                </div>
            </div>
            <div class="col-lg-12 col-xl-6  float-left">
                <div class=" row row-no-margin row-no-padding row-subprocedure-menu">
                    ${buttons[1]}
                </div>
            </div>
        </div>
    </div>`;
};

*/
template.subProcedure.doubleRow = function (buttons) {
    return `
    <div class="container-full " >
        <div class=" row row-no-margin row-no-padding ">
            <div class="col-lg-12 float-left" >
              <div class=" row row-no-margin row-no-padding row-single-section row-subprocedure-menu">
                ${buttons[0]}
                <div class="clearfix hidden-xl"></div>
                ${buttons[1]}
              </div>
            </div>
        </div>
    </div>`;
};

template.subProcedure.singleRow = function (buttons) {
    return `
    <div class="container-full " >
        <div class=" row row-no-margin row-no-padding ">
            <div class="col-lg-12 float-left" >
            <div class=" row row-no-margin row-no-padding row-single-section row-subprocedure-menu">
                    ${buttons}
                </div>
            </div>
        </div>
    </div>`;
};

template.subProcedure.dropDown = function (buttons) {
    return `
    <div class="dropdown-content theme-active-background-color theme-focus-background-color theme-focus-border-color" >
            <div class=" row row-no-margin row-no-padding row-subprocedure-menu">
                ${buttons}
            </div>
    </div>`;
};

template.procedure = {};

template.procedure.dummy = `<div class="dummyBtn  col-md  hidden-xl float-left procedureBtnContainer" ></div>`;

template.procedure.buttonGroup = function (buttonGroup) {
    return `
            <div class="button-group theme-border-color" data-flex-button-count="${buttonGroup.nr}">
              <div class="row row-no-padding row-no-margin button-group-row">
                <div class="procedure-subtitle  col-md float-left" data-hidden=${buttonGroup.title.trim() ===
    ''}> <span> ${buttonGroup.title} </span></div>
              </div>
              <div class="row row-no-padding row-no-margin button-group-row">
                ${buttonGroup.buttons}
              </div>
            </div>`;
};

template.procedure.button = function (procedure, subProcedures) {
    return `<div class=" col-md float-left procedureBtnContainer"
                    data-has-options="${procedure.hasOptions}"
                    data-enable-max-width="${procedure.maxWidth}"
                    data-focus = "" data-hidden=${procedure.option.hidden}>
                    <a role="button" tabindex="0" class="procedureBtn theme-active-background-color theme-active-border-color theme-hover-background-color theme-hover-border-color theme-focus-background-color theme-focus-border-color"
                            data-event-class="ProcedureMenu"
                            data-hotkey-handler="ProcedureMenu"
                            data-nr="${procedure.optionNr}"
                            title="${procedure.option.DSC} (${procedure.option.TTL}), ${procedure.option.PRC}"
                            ${XDOM.Def2Attributes(procedure.option)}>
                        <div><span>${procedure.option.DSC}</span></div>
                        <i class="pth-icon hasDropdownList theme-active-color theme-focus-font-color" data-button-icon="arrowDown"> </i>
                        ${subProcedures}
                    </a>
            </div>`;
};

template.procedure.title = function (option) {
    return `<span class="procedure-single-button-title"> ${userOrDevTitle(
        option.DSC + ' (' + option.TTL + ')',
        option.PRC
    )}</span>`;
};
template.procedure.singleRow = function (buttons, buttonCount) {
    return `
    <div class="col  float-left" >
        <div class=" row row-no-margin row-no-padding row-single-section row-procedure-menu">
          <div class=" row row-no-margin row-no-padding container-procedure-menu-buttons" data-button-count="${buttonCount}">
            ${buttons}
          </div>
        </div>
    </div>`;
};

template.procedure.doubleRow = function (buttons) {
    return `
    <div class="col  float-left" >
        <div class=" row row-no-margin row-no-padding row-single-section row-procedure-menu">
            ${buttons[0]}
            <div class="clearfix hidden-xl"></div>
            ${buttons[1]}
        </div>
    </div>`;
};

template.menu = {};
template.menu.program = function (def) {
    return `
    <div class="dropdown-item"
        role="button" tabindex="0" class="dropdown-item"
        title="${def.TTL} (${def.PGM})"
        data-event-class="MainMenuSubItem"
        data-admin-id="${this.IDT}"
        data-focus = ""
        data-hotkey-handler="MainMenuSubItem"
        ${XDOM.Def2Attributes(def)}>
        <!--${userOrDevTitle(def.TTL, def.ENV, def.APP, def.PGM)}-->
        <a>
            <span>${def.DSC}</span>
        </a>
    </div>`;
};

template.menu.entry = function (item, subItems) {
    return `
    <div class="dropdown-item"
        data-test="geen"
        data-focus = ""
        data-hotkey-handler="MainMenuSubItem"
        data-event-class="MainMenuSubItem"
        
        data-admin-id="${item.IDT}"
        ${XDOM.Def2Attributes(item.definition)}>
        <a role="button" tabindex="0" >
            <span class="dropDownArrow">${item.DSC}</span>
        </a>
        ${subItems}
    </div>`;
};

template.admin = function (def) {
    const homeApp = def.homeApp || def.homeAppDir || ''; //backwards compatibility 7C, 7D
    return `<a role="button" tabindex="0" class="administration-button" data-environment="${def.option.ENV}" data-filter-value="${def.option.DSC.toLowerCase()}" data-color= "${
        def.color
    }" data-default-theme = "${def.defaultTheme}">
                <div class="administrationOption  theme-background-color"
                     title="${userOrDevTitle(def.option.TTL, def.option.ENV)}"
                     ${XDOM.Def2Attributes(def.option)}
                     data-button-state="inactive"
                     data-admin-id="${def.option.IDT}"
                     data-focus = ""
                     data-event-class="Administration"
                     data-auto-load-home = "${def.autoLoadHome}"
                     data-option-pgm="${def.homeOption || ''}"
                     data-option-env="${def.option.ENV}"
                     data-option-app="${homeApp}"
                     >
                    <div class="icon">
                      <img src="/${def.option.LGO}" name="administationLogo" alt = "${userOrDevTitle(def.option.TTL, def.option.ENV)}" title="${userOrDevTitle(
        def.option.TTL,
        def.option.ENV
    )}" />
                    </div>
                    <div class="text"> <span>${def.option.DSC}</span></div>
                    <div class="session-counter"></div>
                </div>
            </a>`;
};

template.link = {};
template.link.item = function (item) {
    return `
    <a href="${item.LNK}" class="col-sm-4 col-lg-3 linkTile" target="_blank">
        <i class="icon fa ${item.ICO}" > <span class="applicationTooltip">${item.DSC}</span> </i>

    </a>`;
};

template.link.tile = function (links) {
    return `
           <div class="administrationOption tileWrapper" >
             <div class="row row-no-padding row-no-margin show-grid">
               ${links}
             </div>
           </div>
            `;
};
template.macro = {};
template.macro.singleRow = function (buttons) {
    return `${buttons}`;
};

template.macro.tab = function (macro, index) {
    return `<a  role="button" tabindex="0" title="${macro.TTL} (ALT + ${index + 1}), ${macro.MCR}"
            class="macro-tab theme-active-border-color theme-focus-border-color"
            data-hotkey-handler="MacroTab"
            data-macro-index="${index + 1}"
            data-hotkey-down-handler="MacroTab"
            data-block-autosubmit="true"
            data-event-class="MacroTab"
            ${XDOM.Def2Attributes(macro)}
            data-button-state="">
          <span>${macro.DSC}</span>
        </a>`;
};

template.secondMainMenuButon = function (def) {
    return `<a role="button" 
               class="burger-button"
               tabindex="0"
               data-event-class="${def.eventClass}"
               data-click="${def.action}"
               data-admin-id = "${def.IDT}"
               data-button-state="${def.state}"
               data-env="${def.ENV}">
               <i class="${def.icon}"></i>
            </a>`;
};

template.home = {};

template.home.content = function (admin) {
    return `<div style="font-family: 'arial'; 
                      margin-top:300px; 
                      font-size:20px; 
                      width:100%; 
                      text-align:center; 
                      overflow: hidden;
          ">
          <span style="position: relative; float:left; font-family: 'arial'; width:100%; font-size:22px; font-weight: bold;">Actieve administratie:</span> <span style="position: relative; float:left; font-family: 'arial'; width:100%; font-size:30px; color: #4e4e4e;">${
        admin.DSC
    } </span></div>`;
};

/* subProcedureMenu */
/* Load Timestamp 13:59:55.661 */
var subProcedureMenu = {};

(function () {
    function splitButtons(buttons){
        if(buttons.length % 2 === 1){
            buttons.push(template.procedure.dummy)
        }
        let setSize = buttons.length/2;
        return [buttons.slice(0,setSize).join(''),buttons.slice(setSize).join('')];
    }

    function render(subProcedures){

        let optionCount = subProcedures.length || 1,
            enableMaxWidth = false;

        if(optionCount < 8){
            enableMaxWidth = true;
        }

        let buttons = subProcedures.map(o=>template.subProcedure.fixedButton(enableMaxWidth, o));
        XDOM.getObject("navigationWrapper").setAttribute("data-hide-menu", "false");
        if(subProcedures.length > 8){
            buttons = splitButtons(buttons);
            return template.subProcedure.doubleRow(buttons);
        }
        if(subProcedures.length == 1){
            XDOM.getObject("navigationWrapper").setAttribute("data-hide-menu", "true");
            return "";
            //return template.subProcedure.title(subProcedures[0]) + template.subProcedure.fixedButton(subProcedures[0], true);
        }

        return template.subProcedure.singleRow(buttons.join(''));
    }


    function renderPullDown(subProcedures){
        if(subProcedures.length==1){
            return template.subProcedure.dropDownOneButton(subProcedures[0].option)
        }
        let buttons = subProcedures.map(template.subProcedure.dropDownButton).join('');
        return template.subProcedure.dropDown(buttons);
    }

    function toggleSubProcMenu(){
        let procedureMenuWrapper = XDOM.getObject("procedureMenu");
        if(procedureMenuWrapper){
            procedureMenuWrapper.setAttribute("data-submenu-visible", SCOPE.sessionDoc.getElementById("toggleSubprocedureMenu").checked);
        }
    }

    this.toggleSubProcMenu = toggleSubProcMenu;
    this.render = render;
    this.renderPullDown = renderPullDown;
}).apply( subProcedureMenu);


/* ProcedureMenu */
/* Load Timestamp 13:59:55.661 */
var ProcedureMenu = {};
(function () {

    function load(item) {
        let singleItem = item.querySelector('[data-main-menu="true"] > [data-option-typ="PGM"]');
        MAIN.colapseAllMenus();
        XDOM.invokeClick(singleItem);
    }

    function down(item) {
        if (item.parentNode.dataset.hasOptions == "false") {
            return; //er is maar 1 subprocedure en deze knop heeft geen dropdown
        }
        if (item.parentNode.dataset.openSubitems != "true") {//item nog niet geopend
            MAIN.colapseAllMenus();
            item.parentNode.setAttribute("data-open-subitems", "true");
            item.setAttribute("data-hover", "true");
            return;
        }
        let firstSubItem = item.parentNode.querySelector('div.dropdown-item');
        MAIN.focusMenu(firstSubItem);

    }

    function left(item) {
        let nr = parseInt(item.dataset.nr) - 1,
            prevItem = document.querySelector(`.procedureBtnContainer a[data-nr="${nr}"]`);
        if (!prevItem) {
            return;
        }
        focus(prevItem);
    }

    function right(item) {
        let nr = parseInt(item.dataset.nr) + 1,
            nextItem = document.querySelector(`.procedureBtnContainer a[data-nr="${nr}"]`);
        if (!nextItem) {
            return;
        }
        focus(nextItem);
    }

    function focus(item) {
        MAIN.colapseAllMenus();
        MAIN.focusMenu(item);
    }

    function hotkey(kCode, item) {
        switch (kCode) {
            case keyCode.arrowRight:
                right(item);
                break;
            case keyCode.arrowLeft:
                left(item);
                break;
            case keyCode.arrowDown:
            case keyCode.space:
                down(item);
                break;
            case keyCode.enter:
                load(item);
                break
        }
    }

    function keyup(ev) {
        let item = document.querySelector('[data-focus="true"][data-hotkey-handler]');
        if (item) {
            let handlerClass = window[item.dataset.hotkeyHandler];
            if (handlerClass) {
                handlerClass.hotkey(ev.event.keyCode, item)
            }
            return;
        }
        return true;
    }

    /**
     *
     * @param {string} PRC procedure name
     * @param {string} SBP subprocedure name
     * @TODO JVE Search.close();  hoort hier niet naar een (sub)procedure onload of zo iets
     */
    function load(subProcedureButton) {
        let procedureName = '',
            procedure = null,
            subProcedureName = '',
            subProcedure = null;
        procedureName = XDOM.Attributes2Def(subProcedureButton).PRC
        procedure = SESSION.session.getProcedure(procedureName);
        subProcedureName = XDOM.Attributes2Def(subProcedureButton).SBP ||
            procedure.defaultSubProcedureName ||
            procedure.subProcedures[0].SBP;

        subProcedure = procedure.getSubProcedure(subProcedureName);

        if (!subProcedureButton) {
            subProcedureButton = document.querySelector(`[data-option-sbp="${subProcedureName}"]`);
        }

        activate(procedure.PRC);
        if (!subProcedure) {
            return;
        }
        SubProcedureButton.activate(subProcedureButton);
        Search.close();
        procedure.load(subProcedure);

    }

    function click(ev) {
        if (ev.invokeObject.tagName == "BODY" || isActive(ev.invokeObject)) {
            return;
        }
        let procedureBtn = ev.invokeObject,
            procedureName = XDOM.Attributes2Def(procedureBtn).PRC,
            procedure = SESSION.session.getProcedure(procedureName),
            subProcedureButton = XDOM.getParentByAttribute(procedureBtn,'data-only-option'),
            subProcedureName =  procedure.defaultSubProcedure?procedure.defaultSubProcedure.SBP :'';
        if (subProcedureButton) {
            subProcedureName = XDOM.Attributes2Def(subProcedureButton).SBP || subProcedureName;
        }

        SessionMenus.load(procedureName, subProcedureName);
        return true;
    }


    function mousedown() {
        SESSION.session.cancelBlurEvent = true;
    }

    function renderSingleProcedure(options) {
        let procedureOptions = options.filter(o => typeof o !== "string");
        if (procedureOptions.length > 1 ) {
            return false
        }
        if(procedureOptions.length==0){//only menu options
            return null;
        }
        procedureOptions[0].hidden = true;
        procedureOptions = procedureOptions.map(o => renderButton(o, 1)).join('');
        XDOM.getObject("procedureMenu").setAttribute("data-hide-menu", "true");
        return procedureOptions;
    }

    function splitOptions(options) {
        let setSize = Math.ceil(options.length / 2);
        return [options.slice(0, setSize), options.slice(setSize)];
    }

    function renderButtonGroup(group) {
        group.nr = group.options.length;

        if(group.nr===0){
            return '';
        }

        let buttons = group.options.map(renderButton)
        if (group.canSplit) {
            if (buttons.length % 2) {
                buttons.push(template.procedure.dummy);
            }
            let splitSize = Math.ceil(buttons.length / 2);
            let upperRow = buttons.slice(0, splitSize);
            let lowerRow = buttons.slice(splitSize)
            upperRow.push('<div class="clearfix hidden-xl"></div>');
            buttons = upperRow.concat(lowerRow);
        }
        group.buttons = buttons.join('');

        return template.procedure.buttonGroup(group);
    }

    function renderMultipleProcedures(options) {
        if (typeof options[0] !== "string") {
            options.unshift(""); // eerste element altijd een string voor title
        }
        let optionCount = options.filter(o => typeof o !== "string").length
        splitpos = Math.ceil(optionCount / 2);
        let option = null,
            buttonGroups = [],
            buttonCount = 0;


        for (let i = 0, l = options.length; i < l; i++) {
            option = options[i];
            if (typeof option === "string") {
                buttonGroups.push({title: option, options: []});
            } else {
                buttonCount++;
                option.useMaxWidth = (optionCount < 8);

                option.split = '';
                if (buttonCount == splitpos) {
                    option.split = '<div class="clearfix hidden-xl"></div>';
                }
                buttonGroups[buttonGroups.length - 1].options.push(option);
                buttonGroups[buttonGroups.length - 1].canSplit = (optionCount > 10);
            }
        }
        return template.procedure.singleRow(buttonGroups.map(renderButtonGroup).join(''), buttonCount);
    }

    function renderButton(procedure) {
        if (typeof procedure == 'string') {
            return;
        }
        procedure.initOptions();
        let subProcedures = subProcedureMenu.renderPullDown(procedure.subProcedures);

        procedure.hasOptions = (procedure.subProcedures.length > 1);
        procedure.option.hidden = (procedure.hidden == true);
        return template.procedure.button(procedure, subProcedures);
    }

    function mouseover(e) {
        if (e.target.dataset.openSubitems == "true") {
            return;
        }
        MAIN.colapseAllMenus();
        MAIN.removeFocus();
        enableHover();
    }

    function enableHover() {
        administrationMainMenu = document.getElementById("procedureMenu");
        administrationMainMenu.setAttribute("data-hover-enabled", "true");
    }
    function renderInvalidProcedures(){
        console.clear();
        console.log('deze procedure heeft geen geldige opties:');

        SESSION.session.invalidProcedures.forEach(prc=>{
            console.log(`    - ${prc.reason}    for ${prc.PRC} (${prc.DSC})` );
        })



        let apps = '';
        for (let [key, value] of Object.entries(SESSION.session.validApps)) {
            if(value){
                apps += key + ', ';
            }
        }
        console.log('geldige Applicaties zijn:', apps);


        let mods = '';
        for (let [key, value] of Object.entries(SESSION.session.validModules)) {
            if(value){
                mods += key + ', ';
            }
        }
        console.log('geldige Modules zijn:', mods);

        return `    <div class=" col-md float-left ">
            <a role="button" tabindex="0" class="procedureBtn" data-option-status="definitionMissing">
              Deze procedure heeft geen geldige opties, zie de log file voor meer informatie
            </a>
        </div>`;
    }

    function render(procedures) {
        let buttonsBar = renderSingleProcedure(procedures) || renderMultipleProcedures(procedures),
            placeHolder = SESSIONDOC.querySelector(".procedureMenu .row");

        if(!SESSION.session.hasValidProcedures){
            buttonsBar = renderInvalidProcedures();
        }

        placeHolder.innerHTML = buttonsBar;
        XDOM.addEventListenerToNode(".procedureBtnContainer", "mouseover", mouseover, placeHolder);
        MAIN.activateMenu(placeHolder);

        // Check tablet mode and hide
        if (SCOPE.mainDoc.body.classList.contains('tablet-mode')) {
            SESSIONDOC.querySelectorAll('.procedureMenu')[0].classList.add('tablet-hidden');
        }
    }


    function focusMenu() {
        if (SESSION.session.getDefaultPRC()) {
            return;
        }
        let item = SESSIONDOC.querySelector(".procedureMenu .row .procedureBtnContainer a");
        if(!item){
            return;
        }
        MAIN.focusMenu(item);
        item.setAttribute("data-initial-focus", "true");

    }

    function updateFromMain() {
        let procedureName = SESSION.stack.currentProcedure.PRC,
            subProcedureName = SESSION.stack.currentSubprocedure.SBP,
            procedure = SESSION.session.getProcedure(procedureName),
            suprocedurePlaceholder = document.getElementById("subProcedureMenu");

        suprocedurePlaceholder.innerHTML = subProcedureMenu.render(procedure.subProcedures);
        SubProcedureButton.activate(subProcedureName);
        activate(procedureName);
    }

    function activate(procedureName) {
        let procedureButton = document.querySelector(`[data-option-prc="${procedureName}"]`),
            buttons = document.querySelectorAll(`.procedureBtnContainer a[data-button-state="active"]`);
        activateOneButton(buttons, procedureButton);
    }


    this.left = left;
    this.right = right;
    this.load = load;
    this.render = render;
    this.activate = activate;
    this.click = click;
    this.keyup = keyup;
    this.hotkey = hotkey;
    this.down = down;
    this.mousedown = mousedown;
    this.updateFromMain = updateFromMain;
    this.focusMenu = focusMenu;
}).apply(ProcedureMenu);



/* subProcedureButton */
/* Load Timestamp 13:59:55.661 */
var SubProcedureButton = {};
(function () {



    function left(item){
        let nr=parseInt(item.dataset.nr) -1,
            prevItem= document.querySelector(`.subProcedureBtn[data-nr="${nr}"]`);
        if(!prevItem){
            return;
        }
        MAIN.focusMenu(prevItem);
    }

    function right(item){
        let nr=parseInt(item.dataset.nr) +1,
            nextItem= document.querySelector(`.subProcedureBtn[data-nr="${nr}"]`);
        if(!nextItem){
            return;
        }
        MAIN.focusMenu(nextItem);
    }


    // function left(item){

    //     if(item && item.parentNode.previousElementSibling){
    //         MAIN.focusMenu(item.parentNode.previousElementSibling.querySelector('a'));
    //     }

    // }

    // function right(item){

    //     if(item && item.parentNode.nextElementSibling){
    //         MAIN.focusMenu(item.parentNode.nextElementSibling.querySelector('a'));
    //     }
    // }

    function down(item){
        if(!item.nextElementSibling){
            return;
        }
        MAIN.focusMenu(item.nextElementSibling);
    }

    function nextProcedure(item){
        MAIN.colapseAllMenus();
        ProcedureMenu.right(item.parentNode.parentNode.parentNode);
    }

    function prevProcedure(item){
        MAIN.colapseAllMenus();
        ProcedureMenu.left(item.parentNode.parentNode.parentNode);
    }

    function up(item){
        if(item.previousElementSibling){
            MAIN.focusMenu(item.previousElementSibling);
            return;
        }
        MAIN.colapseAllMenus();
        MAIN.focusMenu(item.parentNode.parentNode.parentNode);
    }

    function hotkey(kCode, item){
        if(item.dataset.fixed==="true"){
            switch(kCode){
                case keyCode.arrowRight:
                    right(item);
                    break;
                case keyCode.arrowLeft:
                    left(item);
                    break;
                case keyCode.space:
                case keyCode.enter:
                    open(item);
                    break
            }
            return;
        }
        switch(kCode){
            case keyCode.arrowUp:
                up(item);
                break;
            case keyCode.arrowRight:
                nextProcedure(item);
                break;
            case keyCode.arrowLeft:
                prevProcedure(item);
                break;
            case keyCode.arrowDown:
                down(item);
                break;
            case keyCode.enter:
            case keyCode.space:
                open(item);
                break
        }
    }
    function keyup(ev){
        let item = document.querySelector('[data-focus="true"][data-hotkey-handler]');
        if(item){
            let handlerClass = window[item.dataset.hotkeyHandler];
            if(handlerClass){
                handlerClass.hotkey(ev.event.keyCode, item)
            }
            return true;
        }
        return false;
    }
    function close(btn){
        // if(btn.dataset.fixed=="true"){return;}
        let procedureButton = XDOM.getParentByAttribute(btn, "data-open-subitems");
        MAIN.removeFocus(SESSIONDOC);
        if(!procedureButton){
            return;
        }
        procedureButton.setAttribute("data-open-subitems","false");
        procedureButton.querySelector("a").setAttribute("data-hover","false");
    }


    function open(btn){
        if(SESSION.submitInProgress) return;
        close(btn);

        let pocedureName = XDOM.Attributes2Def(btn).PRC,
            subProcedureName = XDOM.Attributes2Def(btn).SBP;
        activate(subProcedureName);
        SessionMenus.load(pocedureName,subProcedureName);
    }

    function click(ev){
        if(isActive(ev.invokeObject)){return;}
        if(ev.invokeObject.dataset.available ==="false"){
            SCOPE.main.Dialogue.alert(`Subprocedure : ${ev.invokeObject.title} ${getCapt('gSRV001')}`,getCapt('gSRV001'));
            return;
        }
        open(ev.invokeObject);
        return true;
    }

    function mousedown(){
        SESSION.session.cancelBlurEvent = true;
    }

    function activate(subProcedure){
        let  subProcedureButton1 = document.querySelector(`#subProcedureMenu [data-option-sbp="${subProcedure}"]`),
            subProcedureButton2 = document.querySelector(`#procedureMenu [data-option-sbp="${subProcedure}"]`),
            buttons1 = document.querySelectorAll('#subProcedureMenu [data-button-state], #procedureMenu [data-option-sbp]'),
            buttons2 = document.querySelectorAll('#procedureMenu [data-subprocedure-active]');

        if(subProcedureButton1){
            XDOM.setAttributesToNodeList(buttons1,"data-button-state", "inactive");
            subProcedureButton1.setAttribute("data-button-state", "active");

        }
        if(subProcedureButton2){
            XDOM.setAttributesToNodeList(buttons2,"data-subprocedure-active", "false");
            subProcedureButton2.setAttribute("data-subprocedure-active", "true");
        }
    }

    this.keyup = keyup;
    this.click = click;
    this.hotkey = hotkey;
    this.mousedown = mousedown;
    this.activate = activate;
}).apply( SubProcedureButton);

/* macrotab */
/* Load Timestamp 13:59:55.662 */
var MacroTab = {};
(function () {

    function load(item){
        XDOM.invokeClick(item);
    }

    function left(item){

        if(item.previousElementSibling){
            focus(item.previousElementSibling);
        }
    }

    function right(item){
        if(item.nextElementSibling){
            focus(item.nextElementSibling);
        }
    }

    function focus(item){
        MAIN.focusMenu(item);
    }

    function hotkey(kCode, item){
        switch(kCode){
            case keyCode.arrowRight:
                right(item);
                break;
            case keyCode.arrowLeft:
                left(item);
                break;
            case keyCode.enter:
            case keyCode.space:
                load(item);
                break;
        }
    }

    function keyup(ev){
        let item = PAGEDOC.querySelector('[data-focus="true"][data-hotkey-handler]');
        return hotkey(ev.event.keyCode, item);
    }

    function hotkeyDown(kCode, item){
        if(kCode== keyCode.enter){
            load(item);
            return true
        }

    }
    function click(ev){
        if(ev.invokeObject.tagName == "BODY" || isActive(ev.invokeObject)){
            return;
        }
        let macroName =  XDOM.Attributes2Def(ev.invokeObject).MCR,
            macro = SESSION.stack.currentSubprocedure.getMacro(macroName);
        if(SESSION.submitInProgress){
            //er is al een submit het laden van de nieuwe macro wordt uitgesteld tot na de onload
            SESSION.NextMacroId = macroName;
            return;
        }
        SESSION.NextMacroId = null;
        Subfile.storeSubfilePos();
        SESSION.stack.clearHistory(SESSION.stack.currentSubprocedure);
        macro.load();
        return true;
    }


    function mousedown(){
        SESSION.session.cancelBlurEvent = true;
    }


    function render(options){

        let placeholder = XDOM.getObject('TABDIV'),
            macros = options.map(template.macro.tab).join('');

        placeholder.innerHTML = template.macro.singleRow(macros);
        activate()
    }

    function focusMenu(){
        MAIN.focusMenu(SESSIONDOC.querySelector(".procedureMenu .row .macroTabContainer"));
        SESSIONDOC.getElementsByTagName("a")[0].focus();
    }

    function updateFromMain(){
        activate();
    }

    function activate(macroName= SESSION.stack.currentMacro.MCR){
        let macroTab = PAGEDOC.querySelector(`a[data-option-mcr="${macroName}"]`),
            buttons = PAGEDOC.querySelectorAll(`.macroTabContainer a[data-button-state="active"]`);
        if(!macroTab) {
            return;
        }
        activateOneButton(buttons, macroTab);
    }

    this.load = load;
    this.render = render;
    this.activate = activate;
    this.click = click;
    this.keyup = keyup;
    this.hotkey = hotkey;
    this.hotkeyDown = hotkeyDown;
    this.mousedown = mousedown;
    this.updateFromMain = updateFromMain;
    this.focusMenu = focusMenu;
}).apply( MacroTab);


/* sessionMenus */
/* Load Timestamp 13:59:55.662 */
var SessionMenus = {};
(function () {
    async function load(procedureName, subProcedureName) {
        let procedure = SESSION.session.getProcedure(procedureName),
            subProcedure = procedure.getSubProcedure(subProcedureName);
        ProcedureMenu.activate(procedureName);

        if (!subProcedure) {
            return;
        }
        Search.close();
        if (!NAV.Procedure.currentInstance || NAV.Procedure.currentInstance.PRC !== procedureName) {
            await procedure.load(subProcedure);
        } else {
            await subProcedure.load();
        }

        SubProcedureButton.activate(subProcedureName);
    }

    function updateFromMain() {
        let procedureName = SESSION.stack.currentProcedure.PRC,
            subProcedureName = SESSION.stack.currentSubprocedure.SBP,
            procedure = SESSION.session.getProcedure(procedureName),
            suprocedurePlaceholder = document.getElementById('subProcedureMenu');

        if (!SESSION.stack.currentSubprocedure.isTarget) {
            // huidige subProcedure is geen target
            suprocedurePlaceholder.innerHTML = subProcedureMenu.render(procedure.subProcedures);
            SubProcedureButton.activate(subProcedureName);
        }
        MacroTab.activate();
    }

    function sort() {
        const tabs = Array.prototype.slice.call(SCOPE.mainDoc.querySelectorAll('.sessionTabContainer')),
            container = SCOPE.mainDoc.getElementById('sessionTabWrapper');
        tabs.sort((a, b) => (a.dataset.adminId > b.dataset.adminId ? 1 : -1));
        tabs.forEach(tab => tab.remove());
        tabs.forEach(tab => container.appendChild(tab));
        $('#sessionTabWrapper').sortable('refresh');
    }


    function getOptions(admins) {
        const def = [];

        admins.forEach(adminId => {
            def.push(getContextAdminOption(adminId));
        });
        return def;
    }

    /**
     *
     * @param adminId
     * @returns {null|Object[]}
     */
    function getContextAdminOption(adminId) {
        const captions = getCaptionSet('SessionContext');
        const admin = SCOPE.mainDoc.querySelector(`.administrationOption[data-option-idt="${adminId}"]`);
        if (!admin) {
            return null;
        }
        // Return the admins in nested context format
        return SCOPE.main.ImpCtx.item(
            admin.getAttribute('data-option-dsc'),
            'fas fa-caret-right',
            [
                SCOPE.main.ImpCtx.section(null, [
                    SCOPE.main.ImpCtx.item(
                        captions.showAll,
                        'fas fa-eye',
                        null,
                        () => {
                            AdminControler.setHidden(admin, false);
                        }
                    )
                ]),
            ],
            null
        );
    }

    function checkAvailableAdmins() {
        const tabs = SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer:not([data-disabled="true"])`);
        let firstAdmin = '',
            hasMultipleVisableAdmins = false,
            hasHiddenAdmins = false;
        tabs.forEach(tab => {
            if (tab.dataset.hidden !== 'true') {
                if (!firstAdmin) {
                    firstAdmin = tab.dataset.adminId;
                }
                if (firstAdmin !== tab.dataset.adminId) {
                    hasMultipleVisableAdmins = true;
                }
            } else {
                hasHiddenAdmins = true;
            }
        });

        return {hasHiddenAdmins: hasHiddenAdmins, hasMultipleVisableAdmins: hasMultipleVisableAdmins};
    }

    function hasMoreThanOneSession() {
        return SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer:not([data-hidden="true"])`).length > 1;
    }

    function contextmenu(ev) {

        const {hiddenAdmins} = AdminControler.getOpenAdmins();
        const enforceSingleAdminSessions = SCOPE.main.Settings.get('SHOW_SINGLE_ENV_SESSIONS');
        const {hasHiddenAdmins, hasMultipleVisableAdmins} = checkAvailableAdmins();
        const captions = getCaptionSet('SessionContext');
        // Declare section arrays
        const admin = [];
        const session = [];

        if (hasMultipleVisableAdmins) {
            // Sort the sessions by admin
            admin.push(SCOPE.main.ImpCtx.item(
                captions.sort,
                'fas fa-sort',
                null,
                () => {
                    sort(ev.invokeObject);
                }
            ));
        }

        if (hasHiddenAdmins) {
            // Get the hidden admins
            let hAdmins = getOptions(hiddenAdmins);

            // Push the hidden admins to the context menu
            hAdmins.forEach((hAdmin) => {
                admin.push(hAdmin);
            });

            if (!enforceSingleAdminSessions) {
                // Show all hidden tabs
                admin.push(SCOPE.main.ImpCtx.item(
                    captions.showAll,
                    'fas fa-eye',
                    null,
                    () => {
                        AdminControler.showAllAdmins();
                    }
                ));
            }
        }

        if (hasMoreThanOneSession()) {
            // Close all open tabs
            session.push(SCOPE.main.ImpCtx.item(
                captions.closeAll,
                'fas fa-times-circle',
                null,
                () => {
                    SCOPE.main.SessionTab.closeAll();
                }
            ));
        }

        // Create a new context menu SCOPE.mainDoc.body
        const ctx = new SCOPE.main.ImpCtx(SCOPE.mainDoc.body, ev.event);

        // Check for session related actions and add to context
        if (session.length) {
            ctx.add(SCOPE.main.ImpCtx.section('Sessies', session));
        }

        // Check for admin related actions and add to context
        if (admin.length) {
            ctx.add(SCOPE.main.ImpCtx.section('Administratie', admin));
        }

        // Add no options
        if (!session.length && !admin.length) {
            return;
            //ctx.add(SCOPE.main.ImpCtx.section('Geen opties', []));
        }

        // Open the context menu
        ctx.openCtx();

        // Attach open context menu to the scope for iframe closes
        SCOPE.main.ctx = ctx;
    }

    //   function showFirstEnabledAdmin() {
    //     tab = SCOPE.mainDoc.querySelector(`.sessionTabContainer:not([data-disabled="true"])`);
    //     if (tab) {
    //       SessionTab.showOnlyThisAdmin(tab);
    //     }
    //   }

    //   function disableTabs(target) {
    //     const adminId = target.dataset.adminId,
    //       tabs = SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer[data-admin-id="${adminId}"]`),
    //       hasHiddenTabs =
    //         SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer[data-hidden="true"]:not([data-disabled="true"])`).length >
    //         0;
    //     tabs.forEach(tab => tab.setAttribute('data-hidden', true));
    //     tabs.forEach(tab => tab.setAttribute('data-disabled', true));
    //     // if (hasHiddenTabs) {
    //     //   showFirstEnabledAdmin(adminId);
    //     // }
    //   }

    //   function enableTabs(target) {
    //     const adminId = target.dataset.adminId,
    //       tabs = SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer[data-admin-id="${adminId}"]`),
    //       hasHiddenTabs =
    //         SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer[data-hidden="true"]:not([data-disabled="true"])`).length >
    //         0;
    //     tabs.forEach(tab => tab.setAttribute('data-hidden', false));
    //     tabs.forEach(tab => tab.setAttribute('data-disabled', false));
    //     if (hasHiddenTabs) {
    //       SessionTab.showOnlyThisAdmin(target);
    //     }
    //   }

    //   function setDisabled(invokeObject, disabled) {
    //     const adminId = target.dataset.adminId,
    //       tabs = SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer[data-admin-id="${adminId}"]`);
    //     tabs.forEach(tab => tab.setAttribute('data-hidden', disabled));
    //     tabs.forEach(tab => tab.setAttribute('data-disabled', disabled));
    //   }

    //   this.disableTabs = disableTabs;
    //   this.enableTabs = enableTabs;
    this.sort = sort;
    this.contextmenu = contextmenu;
    this.updateFromMain = updateFromMain;
    this.load = load;
}.apply(SessionMenus));

SCOPE.main.SessionMenus = SessionMenus;

/* SessionUserAction */
/* Load Timestamp 13:59:55.662 */
var SessionUserAction = {};
(function() {
    function skin() {
        MAIN.userSettings.themePicker();
    }
    function print(ev) {
        MAIN.userSettings.printScreen();
    }
    function close(ev) {
        if (ev.invokeObject.dataset.buttonEnabled !== 'true') {
            return;
        }

        if (SESSION.isSingleView) {
            TopView.close();
            return; //=> actieve scherm is een topview dus sluit dit scherm eerst.
        }

        // Depending on the extendedNav we search for the actie or just the single session tab close button
        let query = OCULUS.extendedNav?'.sessionTab[data-button-state="active"] .closeIcon':'.sessionTab .closeIcon'

        let closeButton = MAINDOC.querySelector(query);
        if (!closeButton) {
            return;
        }
        closeButton.dataset.reason = 'session-opions-close-clicked';
        XDOM.invokeClick(closeButton);
    }
    function help(ev) {
        Help.procedure(ev);
    }

    function favourites(ev) {
        if (ev.invokeObject.dataset.buttonEnabled !== 'true') {
            return;
        }
        SCOPE.main.Favourites.add(SESSION.session);
    }

    this.favourites = favourites;
    this.skin = skin;
    this.print = print;
    this.close = close;
    this.help = help;
}.apply(SessionUserAction));

/* MacroNavigation */
/* Load Timestamp 13:59:55.663 */
var MacroNavigation = {};

(function () {
    function activate(ev){
        let obj = ev.invokeObject;
        // if(obj.dataset.buttonEnabled=="false"){
        //     return;
        // }
        XDOM.invokeClick(obj)
        ev.cancel();
    }
    function focus(obj){
        //is the object an actual button?
        if(!obj?.dataset?.eventClass) return false;
        //is the buttopn enabled

        if(obj.dataset.buttonEnabled=="false") return false;
        //we are all good so focus
        obj.focus();
        return true;
    }

    function down(obj){
        let next = obj.nextSibling;
        while(next){
            if(focus(next)){
                return true;
            }
            next = next.nextSibling;
        }
        return false;
    }

    function macroHelp(){
        Help.macro();
    }


    function up(obj){
        let next = obj.previousSibling;
        while(next){
            if(focus(next)){
                return;
            }
            next = next.previousSibling;
        }
    }

    function keyup(ev){

        switch(ev.keyCode){
            case keyCode.enter:
            case keyCode.space:
                activate(ev);

                break;
            case keyCode.arrowDown:
                down(ev.invokeObject);
                break;
            case keyCode.arrowUp:
                up(ev.invokeObject);
            default:
                return false;
        }
        return true;
    }

    this.macroHelp = macroHelp;
    this.keydown = keyup;
    this.down = down;
}).apply( MacroNavigation);

/* AdminControler */
/* Load Timestamp 13:59:55.663 */
var AdminControler = {};
(function() {
    let adminId = '';

    function init(invokeObject) {
        adminId = invokeObject.dataset.adminId;
    }

    /**
     *
     */
    function getOpenAdmins() {
        const openAdmins = new Map(),
            visibleAdmins = new Map();
        hiddenAdmins = new Map()
        Q('.sessionTabContainer').forEach(tab => {
            openAdmins.set(tab.dataset.adminId, tab.dataset.adminId);
            if(tab.dataset.hidden == 'true'){
                hiddenAdmins.set(tab.dataset.adminId, tab.dataset.adminId);
            }else{
                visibleAdmins.set(tab.dataset.adminId, tab.dataset.adminId);
            }
        });

        return { openAdmins:openAdmins,
            visibleAdmins:visibleAdmins,
            hiddenAdmins:hiddenAdmins,
            multipleVisableAdmins:(visibleAdmins.size>1),
            moreThanOneAdmin:(openAdmins.size>1)
        }
    }

    /**
     *
     * @param {HTMLElement} invokeObject
     */
    function showOnlyThisAdmin(invokeObject) {
        if (!invokeObject) {
            return;
        }
        hideAllAdmins();
        setHidden(invokeObject, false);
    }

    function hideAllAdmins() {
        const tabs = Q(`.sessionTabContainer`),
            frames = Q(`.sessionFrame`); //, .MainMenuByAdmin
        tabs.forEach(tab => tab.setAttribute('data-hidden', true));
        frames.forEach(frame => frame.setAttribute('data-hidden', true));
    }

    /**
     * @param {HTMLElement} invokeObject
     */
    function closeAdmin(invokeObject) {
        init(invokeObject);
        const toClose = Q(`.sessionTabContainer[data-admin-id="${adminId}"] [data-click="close"]`);
        toClose.forEach(tab => XDOM.invokeClick(tab));
    }

    function showAllAdmins(invokeObject) {
        const tabs = Q(`.sessionTabContainer`);
        tabs.forEach(tab => tab.setAttribute('data-hidden', false));
    }

    /**
     * @param {HTMLElement} invokeObject
     * @param {boolean} hidden
     *
     * @returns {boolean} admin has open sessions
     */
    function setHidden(invokeObject, hidden) {
        init(invokeObject);
        const frames = Q(`.sessionFrame[data-admin-id="${adminId}"], .MainMenuByAdmin[data-admin-id="${adminId}"]`),
            toHideIsActive = Q(`.sessionTabContainer[data-admin-id="${adminId}"]`).length > 0,
            hasTabs = setHiddenTabs(invokeObject, hidden);
        //tabs.forEach(tab => tab.setAttribute('data-hidden', hidden));
        if (hidden) {
            frames.forEach(frame => frame.setAttribute('data-hidden', hidden));
            if (toHideIsActive) {
                showAnOtherAdmin();
            }
        } else {
            activateLastOpenTab();
        }
        return hasTabs;
    }

    /**
     * sets hidden property of tabs
     * @param {HTMLElement} invokeObject
     * @param {boolean} hidden
     *
     * @returns {boolean} admin has open sessions
     */
    function setHiddenTabs(invokeObject, hidden) {
        init(invokeObject);
        const tabs = Q(`.sessionTabContainer[data-admin-id="${adminId}"]`);
        tabs.forEach(tab => tab.setAttribute('data-hidden', hidden));
        return tabs.length > 0;
    }

    /**
     * enables/disables administrations
     * @param {HTMLElement} invokeObject
     * @param {boolean} disabled
     */
    function setDisabled(invokeObject, disabled) {
        init(invokeObject);

        const frames = Q(`.sessionFrame[data-admin-id="${adminId}"], .MainMenuByAdmin[data-admin-id="${adminId}"]`),
            tabs = SCOPE.mainDoc.querySelectorAll(`.sessionTabContainer[data-admin-id="${adminId}"]`);

        invokeObject.setAttribute('data-disabled', disabled);
        frames.forEach(frame => frame.setAttribute('data-disabled', disabled));
        tabs.forEach(tab => {
            tab.setAttribute('data-hidden', disabled);
            tab.setAttribute('data-disabled', disabled);
        });

        if (disabled) {
            showAnOtherAdmin();
        } else {
            activateLastOpenTab();
        }
    }

    /**
     * opens last activated session tab given (global to closure scope)  current admin
     */
    function activateLastOpenTab() {
        const lastOpenTab = Q(`.sessionTabContainer[data-admin-id="${adminId}"] a[data-last-open=true]`)[0],
            admintab = Q(`.administrationOption[data-admin-id="${adminId}"]`)[0];

        if (lastOpenTab) {
            // admintab.setAttribute('data-button-state', ''); //this is needed otherwise the onclick event wil not do anything

            lastOpenTab.setAttribute('data-button-state', ''); //this is needed otherwise the onclick event wil not do anything
            // XDOM.invokeClick(admintab);
            XDOM.invokeClick(lastOpenTab);
            //does this job has its own particular colour?
            //is so we need to set main again to reflect the colour of the environment not the colour of the job
            if(lastOpenTab.getAttribute('data-skin-assigned-to-job')){
                SCOPE.main.newTheme.setMain()
            }
            return true;
        }
        return false;
    }

    /**
     * shows an other available admin
     */
    function showAnOtherAdmin() {
        //try to get the first admin tab that is not hidden or disabled
        //if it's not there try a hidden tab
        let adminTab =
            Q(`.sessionTabContainer:not([data-disabled="true"])[data-hidden="false"]:not([data-admin-id="${adminId}"])`)[0] ||
            Q(`.sessionTabContainer:not([data-disabled="true"]):not([data-admin-id="${adminId}"])`)[0];
        if (adminTab) {
            setHidden(adminTab, false);
        }
    }

    /** helper function to shorthand  SCOPE.mainDoc.querySelectorAl
     * @param {string} domquery
     * @returns {NodeList}
     */
    function Q(query) {
        return SCOPE.mainDoc.querySelectorAll(query);
    }

    /** helper yo get basic propertys from invokeObject
     * @param {HTMLElement}
     * @returns {adminId:String, disabled:boolean, hidden:boolean, openTabs:boolean}
     */
    function getInvokeProps(invokeObject) {
        return {
            disabled: invokeObject.dataset.disabled == 'true',
            hidden: Q(`.sessionTabContainer[data-hidden="true"][data-admin-id="${adminId}"]`).length > 0,
            openTabs: Q(`.sessionTabContainer[data-admin-id="${adminId}"]`).length > 0
        };
    }

    function forceAdminHeaderOpen() {
        Q(`.applicationHeader`)[0].setAttribute('data-forced-open', true);
    }
    function removeForceAdminHeaderOpen() {
        Q(`.applicationHeader`)[0].setAttribute('data-forced-open', false);

        document.removeEventListener('closeCtxMenu', removeForceAdminHeaderOpen);
    }
    /**
     * opens context menu for Admin tile
     * @param {PTHEvent} ev
     */
    function adminContext(ev) {
        init(ev.invokeObject);
        //const admins = getOpenAdmins(ev.invokeObject),
        const {moreThanOneAdmin} = getOpenAdmins(ev.invokeObject),
            enforceSingleAdminSessions = SCOPE.main.Settings.get('SHOW_SINGLE_ENV_SESSIONS'),
            { disabled, hidden, openTabs } = getInvokeProps(ev.invokeObject),
            def = [],
            captions = getCaptionSet('AdminContext');;

        // Declare section arrays
        const thisAdmin = [];
        const allAdmin = [];

        // Check for disabled
        if (disabled) {
            // Toggle enabled
            thisAdmin.push(SCOPE.main.ImpCtx.item(
                captions.enable,
                'fas fa-times-circle',
                null,
                () => {
                    setDisabled(ev.invokeObject, false);
                }
            ));
        } else {
            // Check if single admin session is forced
            if (!enforceSingleAdminSessions) {
                // Check for open tabs and open admin sessions
                if (moreThanOneAdmin && openTabs) {
                    // Show sessions from this admin
                    thisAdmin.push(SCOPE.main.ImpCtx.item(
                        captions.showThisAdmin,
                        'fas fa-eye-slash',
                        null,
                        () => {
                            showOnlyThisAdmin(ev.invokeObject);
                        }
                    ));
                }
                // Check if hidden
                if (hidden) {
                    // Show sessions from this administration
                    thisAdmin.push(SCOPE.main.ImpCtx.item(
                        captions.unhide,
                        'fas fa-eye',
                        null,
                        () => {
                            setHidden(ev.invokeObject, false);
                        }
                    ));
                    // Check for open tabs and open admin sessions
                } else if (moreThanOneAdmin && openTabs) {
                    // Hide
                    thisAdmin.push(SCOPE.main.ImpCtx.item(
                        captions.hide,
                        'fas fa-eye-slash',
                        null,
                        () => {
                            setHidden(ev.invokeObject, true);
                        }
                    ));
                }
                //   // Disable
                //   thisAdmin.push(SCOPE.main.ImpCtx.item(
                //     captions.disable,
                //     'fas fa-eye-slash',
                //     null,
                //     () => {
                //       setHidden(ev.invokeObject, true);
                // }
                //   ));
                // Check if sessions are open
                if (openTabs) {
                    // Close all sessions for this administration
                    thisAdmin.push(SCOPE.main.ImpCtx.item(
                        captions.closeThisAdmin,
                        'fas fa-times-circle',
                        null,
                        () => {
                            closeAdmin(ev.invokeObject);
                        }
                    ));
                }
            }
        }

        // Create a new context menu
        let ctx = new SCOPE.main.ImpCtx(document.getElementById('applicationHeader'), ev.event);

        // Add sections to context menu
        if (thisAdmin.length) {
            ctx.add(SCOPE.main.ImpCtx.section(ev.invokeObject.getAttribute('data-option-dsc'), thisAdmin));
        }

        if (allAdmin.length) {
            ctx.add(SCOPE.main.ImpCtx.section('Administratie', allAdmin));
        }

        // Hold the admin header open
        forceAdminHeaderOpen();

        // Open the context menu
        ctx.openCtx();

        // Attach open context menu to the scope for iframe closes
        SCOPE.main.ctx = ctx;
        // Setup event listener for context menu close
        const closeCtx = () => {
            // Allow admin header to toggle again
            removeForceAdminHeaderOpen();

            document.removeEventListener('closeCtx', closeCtx);
        }

        document.addEventListener('closeCtx', closeCtx);

    }

    function updateFromSettings(){
        if(SCOPE.main.Settings.get('SHOW_SINGLE_ENV_SESSIONS')){
            //show Only tabs that belong to the current active session tab
            const activeTab = SCOPE.mainDoc.querySelector('.sessionTab[data-button-state="active"]');
            showOnlyThisAdmin(activeTab);
            return;
        }

        showAllAdmins();
    }


    this.updateFromSettings = updateFromSettings;
    this.setHiddenTabs = setHiddenTabs;
    this.closeAdmin = closeAdmin;
    this.setHidden = setHidden;
    this.showOnlyThisAdmin = showOnlyThisAdmin;
    this.showAllAdmins = showAllAdmins;
    this.adminContext = adminContext;
    this.getOpenAdmins = getOpenAdmins;
}.apply(AdminControler));

/* conditionalAttribute */
/* Load Timestamp 13:59:55.663 */
/**
 * bepaald verschillende attributen op basis van de huidige data
 * als het dataField gelijk is aan de string "true" dan wordt het attribute gezet
 * @param attributes
 * @param parentObject
 * @returns {GUI.ConditionalAttribute}
 */

GUI.ConditionalAttribute = function(obj, parentObject){
    this.attribute =  obj.condAttrValue;
    this.indicatorField =obj.condAttrBoolean;
    this.parentObject = parentObject;
};

/**
 * bepaald de verschillende attributen op dasis van de huidige data set
 */
GUI.ConditionalAttribute.prototype.update = function(){
    if(!this.attribute && this.attribute!=''){return;}
    var apply = this.parentObject.getDataValue(this.indicatorField) == '1';
    var obj =    this.parentObject.dom.domObject;
    ConditionalAttribute.set(obj,this.attribute,apply) ;
};









/* cssClass */
/* Load Timestamp 13:59:55.664 */

/**
 * bepaalt css class ob basis van object
 * @param object
 * @returns {GUI.CssClass}
 */

GUI.CssClass = function(object){
    this.object = object;
    this.widthPreFix = '';
};


/**
 * verkrijgt alle css classes
 * @returns {string} de css classes voor dit object
 */
GUI.CssClass.prototype.getClass = function(){
    if(this.object.type=='input'){
        this.widthPreFix = 'xInp';
    }else{
        this.widthPreFix = 'x';
    }
    var fsCss =
        this.getCssColorClass() +
        this.getCssAlignClass() +
        this.getVisabilityClass() +
        this.getDecorationClass() +
        this.getPosAndSizesClass();
    return fsCss;
};


/**
 * geeft class terug op basis van
 * @returns {String}
 */
GUI.CssClass.prototype.getDecorationClass = function(){
    var fsCss = '';
    if(this.object.textLevel){
        fsCss += ' txtLevel'+ this.object.textLevel;
    }
    if(this.object.underline){
        fsCss += ' underline';
    }
    if(this.object.showAsLabel){
        fsCss += ' dataAsLabel';
    }
    // if(this.object.upperCase){
    //   fsCss += ' text-uppercase';
    // }


    return fsCss;
};

/**
 * verkrijgt een class op basis van zichtbaarheid
 * @returns {string} css class
 */
GUI.CssClass.prototype.getVisabilityClass = function(){
    if(this.object.conditionalAttributes.isHidden || this.object.isHidden){
        return ' hidden';
    }
    if(this.object.conditionalAttributes.isProtected || this.object.isProtected){
        return ' protected ';
    }
    return '';
};


/**
 * maakt css classes op basis van
 * attentionLevel, backgroundColor, textColor en conditional attributes en signed
 * als een attentionLevel is gezet dan heeft textColor,  backgroundColor, en conditional attributes(voor zover van toepassing) en signed geen invloed
 * als signed is gezet en de display waarde van dit element is kleiner dan 0 dan heeft textColor geen invloed
 * als een conditional attribute is gezet dan heeft textColor en  backgroundColor geen invloed
 * @returns {String}
 */
GUI.CssClass.prototype.getCssColorClass = function(){
    var fsCss = '';

    if(this.object.textColor){
        fsCss = " font_" + this.object.textColor + " ";
    }

    if(this.object.backgroundColor){
        fsCss+= " bkgd_" + this.object.backgroundColor + " ";
    }

    if(this.object.isProtected || this.object.conditionalAttributes.isProtected){
        fsCss+= " protect ";
    }


    if (this.object.textColorField) {
        fsCss+= " font_" + this.object.getColor(this.object.textColorField);
    }
    if (this.object.backgroundColorField) {
        fsCss+=" bkgd_" + this.object.getColor(this.object.backgroundColorField)
    }

    return fsCss;
};



/**
 * maakt css classes op basis van
 * textAlign
 * @returns {String}
 */
GUI.CssClass.prototype.getCssAlignClass = function(){
    if(this.object.type=="memo"){
    }
    var fsAlign = '';

    if(this.object.conditionalAttributes.align){
        fsAlign = this.object.conditionalAttributes.align;
    }else if(this.object.textAlign){
        fsAlign =this.object.textAlign ;
    }else if(this.object.dataType == ENUM.dataType.decimal){
        fsAlign = ENUM.textAlign.right;
    }



    if(fsAlign){
        this.widthPreFix += fsAlign;
        return " align" + fsAlign + " ";
    }
    // geen align bekent dan default
    this.widthPreFix += "Left";
    return '';
};



GUI.CssClass.prototype.getPosAndSizesClass = function(){
    var w = this.object.width;
    var h = this.object.height;
    var x = this.object.x;
    var y = this.object.y;
    var fsPosition = ' line' + (y);


    fsPosition += ' xpos';

    if(x<10){
        fsPosition += '00' + x;
    }else if (x<100){
        fsPosition += '0' + x;
    }else{
        fsPosition += x;
    }

    fsPosition += ' ';

    if(h){
        fsPosition += ' lines';
        if(h < 10){
            fsPosition += 0;
        }
        fsPosition += h + ' ';
    }




    if(!w){
        return fsPosition;
    }

    if(w<10){
        return fsPosition += this.widthPreFix + '0' + w;
    }
    if(w<=20){
        return fsPosition += this.widthPreFix + w;
    }
    if(w<=25){
        return fsPosition += this.widthPreFix + '25';
    }
    if(w<=30){
        return  fsPosition += this.widthPreFix + '30';
    }
    if(w<=40){
        return fsPosition += this.widthPreFix + '40';
    }
    if(w<=50){
        return fsPosition += this.widthPreFix + '50';
    }
    if(w<=60){
        return fsPosition += this.widthPreFix + '60';
    }
    if(w<=70){
        return fsPosition += this.widthPreFix + '70';
    }
    if(w<=80){
        return fsPosition += this.widthPreFix + '80';
    }
    if(w<=90){
        return fsPosition += this.widthPreFix +'90';
    }





    return fsPosition += this.widthPreFix + '105';
};

//GUI.CssClass.prototype.isSigned = function(){
//  if(this.object.dataType != ENUM.dataType.decimal){return false;}
//  var fsValue = this.object.value.replace(',','.');
//  var fiValue = parseFloat(fsValue);
//  if(fiValue< 0 ){
//    return true;
//  }
//  return false;
//};
/* captions */
/* Load Timestamp 13:59:55.664 */
/* global SESSION */

function Captions(obj){
    this.defaultCaptions = obj.captionsDftLang;
    this.userCaptions = obj.captionsUserLang;
}

Captions.returnCaption = function(key){

    var domCaptions = SESSION.activePage.domCaptions;

    if(domCaptions.userCaptions && hasValue(domCaptions.userCaptions[key])){
        return domCaptions.userCaptions[key];
    }
    if(domCaptions.defaultCaptions && hasValue(domCaptions.defaultCaptions[key])){
        return domCaptions.defaultCaptions[key];
    }
    return null;
};

Captions.prototype.get = function(key){
    if(this.userCaptions && hasValue(this.userCaptions[key])){
        return this.userCaptions[key];
    }
    if(this.defaultCaptions && hasValue(this.defaultCaptions[key])){
        return this.defaultCaptions[key];
    }
    return 'error undefined caption: ' + key;
};


Captions.getTitle = function (origin,captionCode, defaultText, recordNr){
    let title = '';
    switch(origin){
        case "*VAR":
            if(recordNr != null){
                title = SESSION.activeData.subfileData[recordNr][captionCode];
            }else{
                title= SESSION.activeData.headerData[captionCode];
            }
            break;
        case "*LBL":
            title = getCaption(captionCode, captionCode + ": niet bekend");
            break;
        default:
            title = defaultText ;
            break;
    }
    return title || '';

}
/* translate */
/* Load Timestamp 13:59:55.664 */
GUI.setDataAttributes = function (obj) {
    if (!obj.dataAttr) {
        return;
    }
    if (obj.dataAttr.includes('*SIGNED')) {
        obj.signed = true;
    }
    if (obj.dataAttr.includes('*UPPER')) {
        obj.upperCase = true;
    }
    if (obj.dataAttr.includes('*UCS2')) {
        obj.ucs2 = true;
    }

    if (obj.dataAttr.includes('*LFTBLK')) {
        obj.leftBlank = true;
    }
    if (obj.dataAttr.includes('*LFTZRO')) {
        obj.LeftZero = true;
    }
    if (obj.dataAttr.includes('*DIGITS')) {
        obj.digitsOnly = true;
    }
    if (obj.dataAttr.includes('*ALPHA')) {
        obj.Alpha = true;
    }

}

GUI.translateDefinition = function (obj) {
    if (obj.translated) {
        return;
    }//als een definitie hergebruikt wordt voor een ander info window hoeft hij niet meer te worden vertaald-->
    if (obj.dataType) {
        obj.dataType = GUI.translateDefinition.dataType[obj.dataType];
    }

    if (obj.textAlign) {
        obj.textAlign = GUI.translateDefinition.textAlign[obj.textAlign];
    }

    if (obj.textLevel) {
        obj.textLevel = GUI.translateDefinition.textLevel[obj.textLevel];
    }

    if (obj.fieldAttr) {
        obj.fieldAttribute = obj.fieldAttr;
    }
    if (obj.AttnField) {
        obj.attentionLevelField = obj.AttnField;
    }
    if (!obj.xSize) {
        obj.xSize = obj.maxLength;
    }
    GUI.setDataAttributes(obj);


    if (obj.colorApplyTo === "*BKGD") {
        if (obj.colorName && obj.colorName !== "*VAR") {
            obj.backgroundColor = GUI.translateDefinition.color[obj.colorName];
        } else {
            obj.backgroundColorField = obj.colorField;
        }
    }

    if (obj.colorApplyTo === "*FONT") {
        if (obj.colorName && obj.colorName !== "*VAR") {
            obj.textColor = GUI.translateDefinition.color[obj.colorName];
        } else {
            obj.textColorField = obj.colorField;
        }
    }
    obj.translated = true;
};


GUI.translateDefinition.textAlign = {
    "*LEFT": "Left",
    "*RIGHT": "Right",
    "*CENTER": "Center"
};

GUI.translateDefinition.dataType = {
    "*TXT": "text",
    "*DTA": "data",
    "*DEC": "decimal",
    "*LGL": "logical",
    "*LNK": "link",
    "*MEMO": "memo"
};

GUI.translateDefinition.dataTypeReverse = {
    "text": "*TXT",
    "data": "*DTA",
    "decimal": "*DEC",
    "logical": "*LGL",
    "link": "*LNK",
    "memo": "*MEMO"
};


GUI.translateDefinition.conditionalAttribute = {
    "*MSG": "message",
    "*INF": "information",
    "*ATN": "attention",
    "*ALR": "alert",
    "*ERR": "error",
    "*HIDDEN": "hidden",
    "*PROTECT": "protect", //alleen bij input niet bij label
    "*RIGHT": "alignRight",
    "*CENTER": "alignCenter"
};

GUI.translateDefinition.color = {
    "*BLACK": "black",
    "*GRAY": "gray",
    "*PINK": "pink",
    "*ORANGE": "orange",
    "*GREEN": "green",
    "*YELLOW": "yellow",
    "*RED": "red", //alleen bij input niet bij label
    "*BLUE": "blue",
    "*VIOLET": "violet",
    "*BROWN": "brown"
};

GUI.translateDefinition.textLevel = {
    "*LVL1": "1",
    "*LVL2": "2"
};
/* service */
/* Load Timestamp 13:59:55.664 */
GUI.Services = function(obj){
    this.definitions = obj.serviceData;
    this.services ={};
    this.init();
};

GUI.Services.prototype.init= function(){
    for(var s in this.definitions){
        this.services[s] = new GUI.Service(this.definitions[s],s);
    }
};

GUI.Services.prototype.get = function(id){
    return this.services[id];
};

/**
 * vertaald service definitie naar oud format t.b.v. oude code service en choice popups
 * @param key
 * @returns
 */
GUI.Services.prototype.getOldFormat = function(key){
    var foNewService = this.services[key];
    var foOldService = {};
    if(!foNewService){
        return null;
    }
    foOldService.TTL = foNewService.title;
    foOldService.OPT = [];
    // foOldService.OPT = foNewService.options;
    for(var o in foNewService.options){
        foOldService.OPT[o] = foNewService.options[o];
        //foOldService.OPT.push([o,foNewService.options[o]]);
    }
    return foOldService;
};

GUI.Service = function(obj,id){
    this.id = id;
    this.title = '';
    this.options = [];
    this.init(obj);
};

GUI.Service.prototype.init = function(obj){
    //this.initOptions(obj.ServiceDftLang.options);
    if(!obj || !(obj.ServiceDftLang || obj.ServiceUserLang) ){
        this.title = getCapt('gNOSERVICEOBJECT');
        this.options = [];
        return;
    }
    this.title = obj.ServiceDftLang.title;
    this.options = obj.ServiceDftLang.options;
    if(obj.ServiceUserLang){
        // this.initOptions(obj.ServiceUserLang.options);
        this.options = obj.ServiceUserLang.options;
        if(obj.ServiceUserLang.title !=''){
            this.title = obj.ServiceUserLang.title;
        }
    }
};


GUI.Service.prototype.get = function(key){
    var serviceDescription = "";

    for ( var i = 0, l = this.options.length; i < l; i++) {
        if (key.toUpperCase() == this.options[i][0].toUpperCase() ) {
            serviceDescription = this.options[i][1];
            break;
        }
    }

    return serviceDescription;

    //if(this.options[key]){
    //  return this.options[key];
    //}
    //return '';
};

//GUI.Service.prototype.initOptions = function(options){
//  var key = '';
//  var value = '';

//  for(var i = 0, l = options.length;i<l;i++){
//    key = options[i][0];
//    value = options[i][1];
//    this.options[key] = value;
//  }
//};
/* infoTitle */
/* Load Timestamp 13:59:55.665 */
GUI.infoTitle = {};


GUI.infoTitle.prepareDom = function () {
    var pageObjects = XDOM.queryAllScope('[data-title-origin="*LBL"]');
    GUI.infoTitle.registerNodeList(pageObjects);
};

GUI.infoTitle.update = function () {
    var pageObjects = XDOM.queryAllScope('[data-title-origin="*VAR"]');
    GUI.infoTitle.registerNodeList(pageObjects);
};

GUI.infoTitle.registerNodeList = function (nodeList) {
    for (var i = 0, l = nodeList.length; i < l; i++) {
        GUI.infoTitle.register(nodeList[i]);
    }
};

GUI.infoTitle.register = function (id, captions) {
    var obj = XDOM.getObject(id);
    if (!obj) {
        return;
    }
    var title = '';

    var captionCode = obj.getAttribute('data-title-variable');
    var recordNr = getClientRecordNr(obj);
    switch (obj.getAttribute('data-title-origin')) {
        case '*VAR':
            if (recordNr != null) {
                title = SESSION.activeData.subfileData[recordNr][captionCode];
            } else {
                title = SESSION.activeData.headerData[captionCode];
            }
            title = XDOM.hexDecode(title);
            break;
        case '*LBL':

            if (isStatelessObject(obj)) {
                title = Stateless.Page.getCaption(captionCode);
                if (title) {
                    break;
                }
            }
            title = getCapt(captionCode);
            break;
        default:
            title = captions;
            break;
    }
    obj.setAttribute('title', title);
    return;
};

/* events */
/* Load Timestamp 13:59:55.665 */
GUI.events = function () {
};

GUI.events.register = function (inp) {
    inp.setAttribute("data-focus-action", "INP.handleOnFocus");
    inp.setAttribute("data-blur-action", "INP.handleOnBlur");
};

GUI.events.keyDown = function () {
    foPanel = XDOM.GLOBAL.getEditWindow();
    if (!foPanel) {
        return false;
    }
    switch (GLOBAL.charCode) {
        case keyCode.enter:
            if (XDOM.GLOBAL.getAttribute('data-datatype') != ENUM.dataType.memo) {
                SESSION.submitFromScope = XDOM.GLOBAL.getAttribute('data-panel-id');
                foPanel.send('ACCEPT', XDOM.GLOBAL.getAttribute('data-real-name'));
            }
            break;
    }
    return true;
};

GUI.events.change = function (foInp) {
    addAttributes(foInp);
    var foPanel = XDOM.getEditWindow(foInp);
    if (!foPanel) {
        return false;
    }
    var foGuiObj = foPanel.getGuiObject(foInp.id);
    foPanel.footer.setMessage();
    foGuiObj.updateByUser();
    GUI.events.autoSubmit(foInp);
    return true;
};


GUI.events.autoSubmit = function (obj) {
    if (!isAutoSubmitField(obj)) {
        return;
    }
    let inp = getCurrendFocused() || obj,
        panel = XDOM.getEditWindow(obj),
        PanelId = XDOM.GLOBAL.getAttribute('data-panel-id');
    realName = obj.dataset.realName;

    SESSION.submitFromScope = PanelId;
    if (inp.dataset.panelId == PanelId) {
        realName = inp.dataset.realName;
    }
    panel.send('ENTER', realName);
}
/* attention */
/* Load Timestamp 13:59:55.665 */
/**
 * bepaald verschillende attributen op basis van de huidige data
 * als het dataField gelijk is aan de string "true" dan wordt het attribute gezet
 * @param attributes
 * @param parentObject
 * @returns {GUI.ConditionalAttribute}
 */

GUI.AttentionLevel = function(obj, parentObject){
    this.attentionLevelField = nullWhenEmpty(obj.attentionLevelField);
    this.parentObject = parentObject;
};

/**
 * bepaald de verschillende attributen op dasis van de huidige data set
 */
GUI.AttentionLevel.prototype.update = function(){
    if(!this.attentionLevelField){return;}
    var attentionLevel = this.parentObject.getDataValue(this.attentionLevelField);
    var obj =    this.parentObject.dom.domObject;
    obj.setAttribute("data-attention-level",attentionLevel);
};









/* fp */
/* Load Timestamp 13:59:55.666 */
/* global GLOBAL, Stateless, XDOM, keyCode, FieldProgression, ENUM */

function fp(obj , container){
    this.x = 0;
    this.y = 0;
    this.obj = obj;
    this.container = container || XDOM.getParentByAttribute(obj,"data-fieldprogression-index");
    this.row = [];
    this.type = "";
};

/**
 * gaat naar het eerste veld van de regel
 * @returns {undefined}
 */
fp.prototype.first = function(){
    this.getRow();
    if(this.row.length === 0){
        return false;
    }
    XDOM.focus(this.row[0]);
    return true;
};
/**
 * gaat naar het laatste veld van de regel
 * @returns {undefined}
 */
fp.prototype.last = function(){
    this.getRow();
    if(this.row.length === 0){
        return false;
    }
    XDOM.focus(this.row[this.row.length-1]);
    return true;
};

fp.toEndOnSelectionAll = function(){
    let field = GLOBAL.eventSourceElement;
    if(field.maxLength==1 && XDOM.fieldIsChanged(field) && XDOM.getObjectValue(field)){
        return false;
    }
    fp.setCursorToEnd();
    return true;
}

/**
 * gaat naar het element rechts van het huidige element
 * als deze niet is gevonden dan wordt .down() aangeroepen
 */
fp.prototype.next = function(){
    if (GLOBAL.eventSourceElement.type === "text" && GLOBAL.eventSourceElement.value != '') {
        switch (GLOBAL.selection) {
            case ENUM.selection.unKnown:
            case ENUM.selection.none:
            case ENUM.selection.start:
                return false; //navigatie binnen textElement
                break;
            case ENUM.selection.all:
                if(fp.toEndOnSelectionAll()){
                    return true; //cursor naar het einde van het veld niet bij een lengte van 1 en een verandering
                }
                break;
            case ENUM.selection.end:
                //verder gaan met fieldprogression
                break;
        }
    }
    this.getRow();
    var pos = this.row.indexOf(this.obj)+1;
    for(var l=this.row.length;pos<l;pos++){
        if(this.row[pos]){
            XDOM.focus(this.row[pos]);
            return;
        }
    }
    //is deze regel de subfile header dan niets doen
    if(this.type!="subfileHead"){
        //geen element meer op de zelfde regel ga een regel naar beneden
        this.down(true);
    }

};




/**
 * gaat naar het element links van het huidige element
 * als deze niet is gevonden dan wordt .up() aangeroepen
 */
fp.prototype.previous = function(){
    if (GLOBAL.eventSourceElement.type == "text" && GLOBAL.eventSourceElement.value != '') {
        switch (GLOBAL.selection) {
            case ENUM.selection.unKnown:
            case ENUM.selection.none:
            case ENUM.selection.end:
                return false; //navigatie binnen textElement
                break;
            case ENUM.selection.all:
                return true; //cursor naar het begin van het veld
                break;
            case ENUM.selection.start:
                break;
        }
    }

    this.getRow();
    var pos = this.row.indexOf(this.obj)-1;
    for(;pos>=0;pos--){
        if(this.row[pos]){
            XDOM.focus(this.row[pos]);
            return;
        }
    }
    //geen element meer op de zelfde regel ga een regel naar beneden
    this.up(true);
};

/**
 * verkrijgt een fp object afhankelijk van waar object in de pagina is gedefinieerd
 * @param {type} objIn
 * @returns {fp}
 */
fp.get = function(objIn){
    var obj = objIn || GLOBAL.eventSourceElement,
        tr = XDOM.getParentByTagName(obj,'TR'),
        progression = null,
        tag = 'DIV';


    if(obj.tagName==="TBODY" || obj.tagName==="THEAD"){
        tag=obj.tagName;
    }

    if(tr){
        tag = tr.parentNode.tagName;
    }


    switch(tag){
        case "TBODY":
            progression = new fp.subfileBody(obj);
            break;
        case "THEAD":
            progression = new fp.subfileHead(obj);
            break;
        case "DIV": // single line ellement
            progression = new fp.singleLine(obj);
            break;
        default: //body
            return;
            break;

    }
    if(progression.init()){
        return progression;
    }
    return null;

};

/**
 * controleerd of het obj container als parent heeft
 * bij geneste containers wordt de meest directe parent als container beschouw
 * @param {type} obj
 * @param {type} container
 * @returns {Boolean}
 */
fp.isInContainer = function(obj, container){
    return (container=== XDOM.getParentByAttribute(obj,"data-fieldprogression-index"));
};

/**
 * hulp functie om een gesorteerde array te krijgen met alle elementen in de juiste volgorde
 * @param {type} a
 * @param {type} b
 * @returns {Number}
 */
fp.comparePos = function(a,b) {
    var aXpos =  parseInt(a.getAttribute("data-xpos"));
    var bXpos =  parseInt(b.getAttribute("data-xpos"));
    if(!aXpos){
        aXpos = 0;
    }
    if(!bXpos){
        bXpos = 0;
    }
    if (aXpos < bXpos)
        return -1;
    if (aXpos > bXpos)
        return 1;
    return 0;
};


/**
 * zet de elementen in this.row in de juiste volgorde
 */
fp.prototype.orderRow = function(){
    if(!this.row || this.row.length<=1){
        return;
    }
    this.row = Array.prototype.slice.call(this.row, 0);
    this.row.sort(fp.comparePos);
};

fp.next = function(obj){
    var progression = fp.get(obj);
    progression.next();
};

fp.handleKeyUp = function(){

    let progression = fp.get();
    //  if(fp.subfileBody.handleSelection(progression)){
    //    return true;
    //  }

    //controleer of de lengte van het veld de maxlength heeft
    //in dat geval

    if(!progression){
        return false;
    }

    switch(GLOBAL.charCode){
        case keyCode.arrowLeft:
            progression.previous();
            break;
        case keyCode.arrowRight:
            progression.next();
            break;
        case keyCode.arrowUp:
            progression.up();
            break;
        case keyCode.arrowDown:
            progression.down();
            break;
        default:
            return false;
            break;
    }

    GLOBAL.eventObject.cancel();
    GLOBAL.eventObject.remapKeyCode();
    return true;
};



/**
 * voor het bepalen van de selectie en
 * in verband met het uitschakelen van scroll gedrag binnen chrome bij pijltjes toetesen
 **/
fp.handleKeyDown = function(){
    XDOM.setSelection();

    if(GLOBAL.eventObject.ctrlKey){
        //FieldProgression.handleCrtlKeyDown();
    }
    if(GLOBAL.charCode===keyCode.arrowUp ||GLOBAL.charCode===keyCode.arrowDown){
        //binnen een memoveld met er nog wel gewerkt kunnen worden met pijltje omhoog en naar beneden.
        if(GLOBAL.eventObjectTAG !== "TEXTAREA"){
            XDOM.cancelAndRemap();
        }
    }
};

fp.setCursorToEnd = function() {
    XDOM.setCursor(GLOBAL.eventSourceElement, GLOBAL.eventSourceElement.value.length);
};

/**
 * zet de field progression index
 * @param {type} obj
 * @returns {undefined}
 */
fp.setIndex = function(obj){
    obj.setAttribute("data-fieldprogression-index", fp.counter++);
};
/**
 * conter voor data-fieldprogression-index
 * deze begint bij 5 omdat de eerste 4 vergeven zijn namelijk voor :
 * DTADIV (single line deel) 1
 * COLHDG 2
 * SFL 3 en
 * het extended deel
 * @type Number
 */
fp.counter = 5;
/* fp-sfl-body */
/* Load Timestamp 13:59:55.666 */
/* global fp, XDOM */
/**
 * subfile body field progression object
 * @returns {fp.subfileBody}
 */
fp.subfileBody = function(obj,container){
    fp.subfileBody.baseConstructor.call(this,obj,container);
};
XDOM.extendObject(fp.subfileBody, fp);


/**
 * initialisatie
 */
fp.subfileBody.prototype.init = function(){
    if(!this.container){
        return false;
    }
    this.type = 'subfileBody';
    this.y = parseInt(XDOM.getParentAttribute(this.obj,"data-record-number"));
    this.axis = this.obj.getAttribute("data-axis");
    this.totatalRecords = this.container.getElementsByTagName("tbody").length;
    return true;
};

/**
 * haalt alle elementen op van de record y binnen de huidige container
 * geordend van links naar rechts
 */
fp.subfileBody.prototype.getRow = function(){
    if(!this.container){
        this.row = [];
        return;
    }
    var query = "input[data-record-number='" + this.y + "']:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])",
        inputs = this.container.querySelectorAll(query),
        query = "a[data-record-number='" + this.y + "']:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])",
        As = this.container.querySelectorAll(query);
    this.row = Array.prototype.slice.call(inputs).concat(Array.prototype.slice.call(As));
    this.orderRow();
};

fp.subfileBody.handleSelection = function(progression){
    if(progression.type === 'subfileBody'){
        return false;
    }

    let selectionProgression = fp.subfileBody.getselectionProgression();

    if(!selectionProgression){
        return false;
    }


    switch(GLOBAL.charCode){
        case keyCode.arrowUp:
            return selectionProgression.up();
            break
        case keyCode.arrowDown:
            return selectionProgression.down();
            break;
        default:
            return false;
            break;
    }
    return false;
}

fp.subfileBody.getselectionProgression = function(){
    var tbody  = XDOM.query('[data-record-selected="true"]'),
        obj = null;
//oplossing bedenken waneer wel en waneer niet
    if(!tbody){ return null;}
    obj = tbody.querySelectorAll('a:not([data-axis="registration-radio"]), input')[0];
    if(!obj){return null;}
    return fp.get(obj);
}


fp.subfileBody.prototype.up = function(fromPrevious){
    var query = '',
        obj = null;
    this.y--;

    if(this.y>0 && fromPrevious){
        this.last();
        return;
    }

    while(this.y>0){
        query = "[data-record-number='" + this.y + "'][data-axis='" + this.axis + "']:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])";
        obj =  this.container.querySelector(query);
        if(obj){
            XDOM.focus(obj);
            return;
        }
        this.y--;
    }

    if(this.y===0){
        this.gotoHeader();
    }
};
/**
 * gaat naar de het laatste element in de regel
 * @returns {undefined}
 */
fp.subfileBody.prototype.last = function(){
    this.getRow();
    XDOM.focus(this.row[this.row.length-1]);

};
/**
 * gaat naar de het eerste element in de regel
 * @returns {undefined}
 */
fp.subfileBody.prototype.first = function(){
    this.getRow();
    XDOM.focus(this.row[0]);
};
/**
 * gaat naar het invoer veld direct onder het huidige veld
 * als last = true dan wordt deze functie aangeroepen door de functie fp.next()
 * de cursor wordt dan op het eerste beschikbare veld van de volgende regel gezet
 * @param {boolean} fromNext
 * @returns {undefined}
 */
fp.subfileBody.prototype.down = function(fromNext){
    var query = '',
        obj = null;
    this.y++;
    if(fromNext){
        this.first();
        return;
    }
    while(this.y<=this.totatalRecords){
        query = "[data-record-number='" + this.y + "'][data-axis='" + this.axis + "']:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])";
        obj =  this.container.querySelector(query);
        if(obj){
            XDOM.focus(obj);
            return;
        }
        this.y++;
    }
};


fp.subfileBody.prototype.gotoHeader = function(){
    var headerId = this.container.getAttribute("data-sfl-header-id"),
        container = XDOM.getObject(headerId),
        header = new fp.subfileHead(null,container);
    header.y = 0;
    header.first();
};
/* fp-sfl-header */
/* Load Timestamp 13:59:55.666 */
/* global fp, XDOM */
/**
 * subfile header field progression object
 * @returns {fp.subfileHead}
 */
fp.subfileHead = function(obj,container){
    fp.subfileHead.baseConstructor.call(this,obj,container);
};
XDOM.extendObject(fp.subfileHead, fp);


/**
 * initialisatie
 */
fp.subfileHead.prototype.init = function(){
    this.type = 'subfileHead';
    this.y = parseInt(this.obj.getAttribute("data-line"));
    return true;
};

/**
 * haalt alle input elementen op van de header binnen de huidige container
 * geordend van links naar rechts
 */
fp.subfileHead.prototype.getRow = function(){
    if(!this.container){
        this.row = [];
        return;
    }
    var query = "input:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])," +
        "a[data-line='" + this.y + "'].checkbox:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])";
    this.row = Array.prototype.slice.call(this.container.querySelectorAll(query));
    this.orderRow();
};

/**
 * het is niet mogelijk om vanuit de header regel om hoog te gaan
 * @returns {undefined}
 */
fp.subfileHead.prototype.up = function(){};

/**
 * omdat een subfile header altijd maar 1 regel met inputs heeft
 * ga je met het pijltje down naar de eerste regel van de body
 * @returns {undefined}
 */
fp.subfileHead.prototype.down = function(){
    var bodyId = this.container.getAttribute("data-sfl-body-id"),
        container = XDOM.getObject(bodyId),
        bodyFp = new fp.subfileBody(null,container);
    bodyFp.y = 1;
    bodyFp.first();
};


/* fp-singleLine */
/* Load Timestamp 13:59:55.666 */
/* global fp, XDOM, SETTINGS */
/**
 * single line field progression object
 * @returns {fp.singleLine}
 */
fp.singleLine = function(obj,container){
    fp.singleLine.baseConstructor.call(this,obj,container);
};
XDOM.extendObject(fp.singleLine, fp);


/**
 * initialisatie
 */
fp.singleLine.prototype.init = function(){
    this.type = 'singleLine';
    this.y = parseInt(this.obj.getAttribute("data-line"));
    return true;
};


/**
 * haalt alle elementen op van de regel y binnen de huidige container
 * geordend van links naar rechts
 */
fp.singleLine.prototype.getRow = function(){
    if(!this.container){
        this.row = [];
        return;
    }
    var query = "input[data-line='" + this.y + "']:not([type='hidden']):not([data-hidden='true']):not([data-protected='true']), " +
        "a[data-line='" + this.y + "'].checkbox:not([type='hidden']):not([data-hidden='true']):not([data-protected='true']), " +
        "textarea[data-line='" + this.y + "']:not([type='hidden']):not([data-hidden='true']):not([data-protected='true'])"
    rawRow = this.container.querySelectorAll(query);
    this.row = [];
    //haal alle elementen uit de array die niet binnen deze container vallen
    //dat kan gebeuren bij een normale single line element in een pagina
    //waar ook een of meer subfiles, extended velden(onder de subfile), subviews of popup windows in staan
    for(var i=0,l=rawRow.length;i<l;i++){
        if(fp.isInContainer(rawRow[i],this.container)){
            this.row.push(rawRow[i]);
        }
    }
    this.orderRow();
};

/**
 * verplaatste de focus naar het meest linkse veld
 * van de dichtsbijzijnde regel boven het huidige veld
 * die een input veld heeft
 * is die er niet dan de eerste regel vanaf de onderkant van het scherm
 * @returns {undefined}
 */
fp.singleLine.prototype.up = function(fromPrevious){
    var currentRow = this.y;
    this.y--;

    while(this.y > 0){
        if(fromPrevious && this.last()){
            return;
        }
        if(this.first()){
            return;
        }
        this.y--;
    }
    this.y=SETTINGS.maxLines;
    while(this.y > currentRow){
        if(fromPrevious && this.last()){
            return;
        }
        if(this.first()){
            return;
        }
        this.y--;
    }

};


/**
 * verplaatste de focus naar het meest linkse veld
 * van de dichtsbijzijnde regel onder het huidige veld
 * die een input veld heeft
 * is die er niet dan de eerste regel vanaf de bovenkant van het scherm
 * @returns {undefined}
 */
fp.singleLine.prototype.down = function(){
    var currentRow = this.y;
    this.y++;

    while(this.y < SETTINGS.maxLines){
        if(this.first()){
            return;
        }
        this.y++;
    }
    this.y=1;
    while(this.y < currentRow){
        if(this.first()){
            return;
        }
        this.y++;
    }

};

/* quicksearch */
/* Load Timestamp 13:59:55.667 */


/**
 * QuickSearch object
 *
 * @param obj
 * - target
 * - minLengt
 * - searchFields
 * - requestFields
 * - returnFields
 * - macro
 * - srcLoc
 * - properties
 * - axis
 * - applyToRow *ALL of regel nummers waarop snelzoeken in een subfile van toepassing is
 * - triggerFields array van veldnamen als string bij een verandering van die velden wordt snelzoeken geactiveerd
 * - screenMode    *SUBVIEW inline anders als popup
 * - LimitResults  *YES|*NO resp maximaal 500 of 25 regels tonen
 * @returns {QuickSearch}
 */

function QuickSearch(obj) {
    this.type = 'quicksearch';
    this.id = obj.getAttribute('data-quicksearch-id');
    this.targetId = obj.getAttribute('data-to-id').trim();
    this.srcLocation = obj.getAttribute('data-macro-location');
    this.minLength = parseInt(
        obj.getAttribute('data-quicksearch-activate-after')
    );
    this.activateSearch = obj.getAttribute('data-activate-search');
    this.requestFieldsArray = eval(obj.getAttribute('data-parm-object'));
    this.requestPrefix = obj.getAttribute('data-parm-prefix') || '';
    this.returnFields = obj.getAttribute('data-return-fields').split(' ');
    this.clearFields = (obj.dataset.clearFields || '').split(' ');
    this.environmentConditions  = obj.dataset.environmentConditions;
    this.panelheight = parseInt(
        obj.getAttribute('data-quicksearch-panel-height')
    );
    this.panelWidth = parseInt(obj.getAttribute('data-quicksearch-panel-width'));
    this.macro = obj.getAttribute('data-macro-name');
    this.invokerBaseId = obj.getAttribute('data-invoker-baseId');
    this.triggerAction = obj.getAttribute('data-job-parm-action');

    this.recordNumber = obj.getAttribute('data-record-number');
    this.maxResults = QuickSearch.DefaultmaxResults;
    this.titleVariable = 'mTX_TTL';
    this.titleOrigin = '*LBL';
    this.iconId = obj.id;
    this.qsId =
        SESSION.activePage.macroName +
        '-' +
        this.id +
        '-' +
        this.macro +
        '-' +
        this.targetId;
    this.embeddedInMacro = SESSION.activePage.macroName;
    if (obj.getAttribute('data-quicksearch-limit-results') === '*NO') {
        this.maxResults = 500;
    }
    this.requestCounter = 0;
    this.axis = null;
    this.height = obj.getAttribute('data-subview-width');
    this.width = obj.getAttribute('data-subview-lines');
    this.triggerMacros = obj.getAttribute('data-trigger-macros') || '';
    this.triggerFields = obj.getAttribute('data-trigger-fields') || '';
    this.inSubfile = obj.getAttribute('data-record-number') !== null;
    this.messageWidth = null;
    this.HeaderAxis = null;
    this.targetAxis = null;
    this.applyToRow = null;
    this.errorMsg = null;
    this.autoOpen = true;
    this.paramString = '';
    this.target = XDOM.getObject(this.targetId);
    if (!this.srcLocation) {
        this.srcLocation = 'DBS';
    }

    // wordt in de eerste onResponce geinitialiseerd
    this.returnDataFields = [];
    this.displayFields = [];
    this.searchFields = [];
    this.searchFieldsLength = 0;
    this.requestFieldsLength = this.requestFieldsArray.length;
    this.delay = QuickSearch.defaultDelay;

    //data objecten
    this.data = null;
    this.subfileAttributes = null;

    this.requiredOutputObj = null;
    this.displayData = [];
    this.displaySubfileAttributes = [];
    this.exceedsMaxResults = false;
    this.cursor = -1;
    this.dom = {};

    //hulp variabelen
    this.openOnRequest = false;
    this.selectionRequest = '';
    this.requestArguments = null;
    this.isInitialised = false;
    this.lastPreFix = ''; //laatste waarde van het selectie voor de keyup event op dat veld
    this.isRendered = false;
    this.requery = false; // geeft aan of er al eerder een request is gedaan
    this.totalHeight = 0;
    this.proObj = {};

    //display elementen
    this.messagePlaceHolder = null;
    this.descriptionPlaceHolder = null;
    this.resultNumberPlaceHolder = null;
    this.NrResultsCaptionPlaceHolder = null;
    this.inline = true;
    this.table = new Table(this.qsId + '_table');
    this.table.qsId = this.qsId;
    this.panel = new Panel(this.qsId + '_panel', 'quickSearch');
    this.panel.rows = this.panelheight;
    this.panel.cols = this.panelWidth;
    this.panel.modal = false;
    this.panel.guiObject = this;
    this.panel.placeHolder = null;
    this.panel.panelBackgroundColor = '';
    this.panel.panelIconGroup = obj.getAttribute("data-fieldset-icon-group") || "fontAwesome";
    this.panel.panelIconClass = obj.getAttribute("data-fieldset-icon-class") || "";


    this.embeddedSizes = {};
    this.sortfields = {};
    this.sortField = '';
    this.sortSequence = '';
    this.sortCaseSensitive = false;
    this.SortDefined = false;
    this.invoke = ENUM.invoke.external;
    this.invokee = null;
    this.iconGroup = obj.getAttribute('data-fieldset-icon-group');
    this.iconClass = obj.getAttribute('data-fieldset-icon-class');


    QuickSearch.instances[this.qsId] = this;
    //  QuickSearch.instances[this.id] = this;
    this.setScreenMode(obj);
    this.updateID();
}

QuickSearch.prototype.setScreenMode = function(obj) {
    var sScreenMode = obj.getAttribute('data-screen-mode');
    var sSubViewId = obj.id.replace('QSR_', '');
    var targetObj = this.getTarget();
    if (sScreenMode === '*SUBVIEW') {
        this.panel.screenDiv = obj.parentNode
        this.inline = true;
    } else {
        this.panel.alignTo = targetObj;

        //Als target een mask is dan gebruiken we de container om uit te lijnen
        if (Mask.isMask(targetObj)) {
            this.panel.alignTo = Mask.getContainer(targetObj);
        }

        //als de input/output hidden is gebruiken we het icoon/knopje om de positie te bepalen (POM-1647)
        if (isHidden(this.panel.alignTo)) {
            this.panel.alignTo = XDOM.getObject(this.iconId);
        }

        this.inline = false;
        this.panel.screenDiv = XDOM.getObject('DTADIV');
        this.panel.onShow = function() {
            ScreenBlokker.guiObject = this.guiObject;
            ScreenBlokker.onclick = function() {
                ScreenBlokker.guiObject.selectField.focus();
                setCursorToEnd(ScreenBlokker.guiObject.selectField);
            };
        };
    }

    setSubviewNoMargin(sSubViewId, sScreenMode);
    this.panel.inline = this.inline;
    this.setDefaultMinLength();
};

QuickSearch.panelBorderWidth = 12;

QuickSearch.prototype.getTarget = function() {
    return XDOM.getObject(this.targetId);
};
QuickSearch.prototype.initObj = function() {
    this.registerTrigger();

    if (this.inline) {
        this.show();
    }
};

QuickSearch.prototype.renderIcon = function() {
    if (!this.inSubfile || this.dom.icon || this.inline) {
        return;
    } //-->
    this.dom.td = XDOM.getAxis(this.axis, this.recordNumber);
    if (this.dom.td) {
        this.iconId = 'QUICKSEARCH_' + this.qsId;
        this.dom.icon = XDOM.createElement('DIV', this.iconId, 'quickSearch');
        this.dom.td.appendChild(this.dom.icon);
    }
};

QuickSearch.prototype.registerSFLEvents = function() {};

QuickSearch.prototype.setDefaultMinLength = function() {
    // zet de default minlength als deze niet is gedefinieerd
    var targetObj = this.getTarget();
    if (this.minLength === '0' || this.inline) {
        this.minLength = 0;
        return; //omdat 0 gelijk is aan false
    }
    if (hasValue(this.minLength)) {
        return;
    }

    if (targetObj.maxLength > 0) {
        this.minLength = QuickSearch.DefaultMinLength[targetObj.maxLength];
        if (!this.minLength) {
            this.minLength =
                QuickSearch.DefaultMinLength[QuickSearch.DefaultMinLength.length - 1];
        }
    }
};

QuickSearch.prototype.update = async function() {
    if (this.inline) {
        this.requery = true;
        this.data = null;
        return this.request();
    } else {
        this.close();
        return Promise.resolve();
    }
};

/**
 * keyup event handler voor QuickSearch object
 * @param iKeyCode
 * @param eventFromSelectField
 * @returns
 */
QuickSearch.prototype.handleKeyUp = function(iKeyCode, eventFromSelectField) {
    var selectedFieldValue = XDOM.getObjectValue(this.selectFieldId);
    var validateResponse = null;
    var targetObj = this.getTarget();
    if (iKeyCode) {
        switch (iKeyCode) {
            case keyCode.arrowDown:
                if (this.getRowSelectionDown()) {
                    this.table.rowDown();
                }
                return true;
                break;
            case keyCode.arrowUp:
                if (this.getRowSelectionUp()) {
                    this.table.rowUp();
                }
                return true;
                break;
            case keyCode.enter:
                this.select(true);
                return true;
                break;
            case keyCode.F12:
            case keyCode.escape:
                this.close();
                return true;
                break;
            case keyCode.tab:
            case keyCode.shift:
                return true;
                break;
            case keyCode.F4:
                this.close();
                var obj = XDOM.query(
                    '[data-to-id="' + targetObj.id + '"][data-search-id]'
                );
                if (obj) {
                    XDOM.invokeClick(obj);
                }
                return true;
        }
    }
    if (!eventFromSelectField) {
        return false;
    }
    Stateless.setSubviewActive(this.selectFieldId);
    if (this.lastPreFix === selectedFieldValue) {
        // er is geen een change
        return false;
    }
    this.lastPreFix = selectedFieldValue;

    //check searchinput

    if (selectedFieldValue.length > 0) {
        validateResponse = Validate.test(this.selectFieldId);

        if (!validateResponse.succeed) {
            this.showMessage(validateResponse.message);
            return;
        }
    }

    if (selectedFieldValue.length < this.minLength) {
        this.updateResultIndicator();
        this.table.update(null);
        this.table.setSize();
        this.checkInput();
        return;
    }

    if (
        !this.data ||
        this.data.length > QuickSearch.subSelectOnClient ||
        this.requestParamChanged() ||
        this.errorMsg === ENUM.quicksearchErrors.subfileFull
    ) {
        this.requery = true;
        this.data = null;
        SESSION.submitFromScope = this.selectFieldId;
        this.request();
        return;
    }

    this.getSubSelection();
    this.table.update(this);

    if (
        this.displayData.length == 1 &&
        selectedFieldValue != targetObj.value &&
        this.displayData[0][this.keyField] == selectedFieldValue.toUpperCase()
    ) {
        QuickSearch.blockRequest = false;
        QuickSearch.OnSelect(this.qsId, 0, true);
    }

    this.table.setSize();
    this.updateResultIndicator();
};

// controle speciaal voor snelzoek. Indien de bovenste regel is
// geselecteerd en de gebruiker drukt op arrow UP dan blijft de cursor staan en schiet niet meer naar het laatste record.
QuickSearch.prototype.getRowSelectionUp = function() {
    if (this.table.cursor <= 0) {
        return false;
    }
    return true;
};

// controle speciaal voor snelzoek. Indien de onderste regel is
// geselecteerd en de gebruiker drukt op arrow DOWN dan blijft de cursor staan en schiet niet meer naar het eerste record.
QuickSearch.prototype.getRowSelectionDown = function() {
    if (this.table.cursor >= this.table.displayedRecords.length - 1) {
        return false;
    }
    return true;
};

QuickSearch.prototype.splitSelection = function(fsValue) {
    var requestArguments = fsValue.split(' ');
    var faReturn = [];
    if (requestArguments.length > 1) {
        faReturn[0] = requestArguments[0];
        faReturn[1] = requestArguments.slice(1).join(' ');
    } else {
        faReturn[0] = fsValue;
        faReturn[1] = '';
    }
    return faReturn;
};

QuickSearch.prototype.requestParamChanged = function() {
    var selectedFieldValue = XDOM.getObjectValue(this.selectFieldId) || '';
    var currentRequestArguments = this.splitSelection(selectedFieldValue);

    var firstArgumentSame = currentRequestArguments[0].startsWith(
        this.requestArguments[0]
    );
    var secondArgumentSame = currentRequestArguments[1].startsWith(
        this.requestArguments[1]
    );

    if (!this.requestArguments) {
        return true;
    }

    if (
        firstArgumentSame &&
        secondArgumentSame &&
        this.requestArguments[0] != ''
    ) {
        return false;
    }

    return true;
};

QuickSearch.prototype.updateResultIndicator = function() {
    if (this.exceedsMaxResults) {
        this.resultNumberPlaceHolder.innerHTML = '> ' + this.maxResults;
    } else {
        this.resultNumberPlaceHolder.innerHTML = this.displayData.length;
    }
    this.checkInput();
};

/**
 * close: sluit het sugest window
 * @param closeBySelection
 * @returns
 */
QuickSearch.prototype.close = function(closeBySelection) {
    var targetObj = this.getTarget();
    if (this.inline) {
        return;
    }
    if (targetObj) {
        targetObj.setAttribute('data-block-autosubmit', 'false');
    }

    if (this.invokee) {
        this.invokee.setAttribute('data-no-completion', 'false');
    }

    this.requery = false;
    this.data = null;

    if (!this.panel.visible) {
        this.invokee = null;
        return;
    }

    XDOM.setObjectValue(this.selectFieldId, '');

    if (this.panel) {
        this.panel.close();
        if (this.qsId && QuickSearch.instances[this.qsId]) {
            QuickSearch.gotFocus = false;
        }
    }
    if (closeBySelection) {
        //er heeft een selectie plaats gevonden
        //focus mag niet meer op de invokee gezet worden;
        this.invokee = null;
    }
    this.focusTarget();
    this.invokee = null;
    SESSION.activePage.modalObject = null;
};

QuickSearch.prototype.focusTarget = function() {
    var targetObj = this.getTarget();
    if (!targetObj) {
        return;
    }
    if (Mask.isMask(targetObj)) {
        //als invokee is gedefinieerd dan moet de focus terug
        //gaan naar het juiste deel van het masker (er wordt is geen waarde terug gezet
        //als invokee niet is defnieerd dan naar het laatste deel
        if (this.invokee) {
            targetObj = this.invokee;
        } else {
            targetObj = Mask.getLastPart(targetObj);
        }
    }
    XDOM.focus(targetObj);
    setCursorToEnd(targetObj);
};

/**
 * doet een request naar de server
 * @returns
 */
QuickSearch.prototype.request = async function () {
    let qsId = this.qsId;
    let selectedFieldValue = XDOM.getObjectValue(this.selectFieldId) || '';
    if (hasValue(selectedFieldValue) && this.panel.visible) {
        this.selectionRequest = selectedFieldValue;
    }
    let url =
        '/ndscgi/' +
        this.srcLocation +
        '/ndmctl/' +
        this.macro +
        '.ndm/JSON?PFMSOMTD=' +
        PFMBOX.PFMSOMTD +
        '&PFMFILID=' +
        PFMBOX.sPFMFILID +
        '&USRID=' +
        PFMBOX.PFMRMTUS +
        '&AUTHTOKEN=' +
        SESSION.AUTHTOKEN +
        '&requestCount=' +
        ++this.requestCounter +
        '&pPanelWidth= ' +
        this.panelWidth +
        '&pPanelHeight= ' +
        this.panelheight;
    url += '&SortDefined=' + this.SortDefined;
    url += '&invoke=' + this.invoke;
    url += '&WS_SRT=' + this.sortField;
    url += '&WS_SEQ=' + this.sortSequence;

    url += '&WS_TRN=';
    if (this.sortCaseSensitive) {
        url += 'T';
    }

    if (this.environmentConditions) {
        url += '&EnvConditions=' + encodeURIComponent(this.environmentConditions);
    }

    this.invoke = ENUM.invoke.external;
    if (this.selectionRequest.length < this.minLength && !this.openOnRequest) {
        //geen data nodig
        if (this.isInitialised) {
            //geen request dus geen data en geen config nodig
            this.onResponse();
            return;
        }
        //alleen config nodig
        url += '&CONFIG=all';
        url += this.getParamString();
    } else {
        //wel data nodig
        if (this.isInitialised) {
            //geen config nodig
            url += '&CONFIG=data';
        } else {
            //data en config nodig
            url += '&CONFIG=all';
        }
        this.paramString = this.getParamString();

        if (this.paramString === 'invalid') {
            return;
        }

        url += this.paramString;
    }

    if (this.isRendered) {
        this.resultNumberPlaceHolder.setAttribute('data-hidden', 'true');
        this.quickSearchLoader.setAttribute('data-hidden', 'false');
    }

    setSubviewLoading(this.quickSearchLoader, true);
    QuickSearch.response = await fetch(url).then(response => response.json())
    QuickSearch.handleRequest(qsId);

};

QuickSearch.prototype.getParamString = function() {
    return this.buildParameterString();
};



QuickSearch.prototype.buildParameterString = function() {

    var foField = null;
    var fsValue = '';
    var fsLocation = null;
    var fiRecordNr = '';
    var fsRequestUri = '&PRMLEN=' + this.requestFieldsArray.length;
    var constValue = null;
    var fieldObjName = '';
    var targetObj = this.getTarget();

    for (var i = 0; i < this.requestFieldsArray.length; i++) {
        const fieldName = this.requestFieldsArray[i].field;
        fieldObjName = this.requestPrefix + fieldName;
        fsRequestUri += '&PRM' + (i + 1) + '=';
        fsLocation = this.requestFieldsArray[i].location;
        foField = XDOM.getObject(fieldObjName);
        fiRecordNr = null;
        fsValue = '';

        if (!foField || (foField && foField.tagName !== 'INPUT')) {
            switch (fsLocation) {
                case 'headerData':
                    //remove macroname prefix

                    if (this.invokerBaseId) {
                        fieldObjName = fieldObjName.replace(this.invokerBaseId + '-', '');
                        fsValue = encodeURIField(
                            GUI.BasePanel.instances[this.invokerBaseId].data[fieldObjName]
                        );
                    } else {
                        fsValue = encodeURIField(
                            SESSION.activeData.headerData[fieldName]
                        );
                    }
                    break;
                case 'subfileData':
                    fiRecordNr = parseInt(this.recordNumber) - 1; //array begint bij 0 en recordnummer bij 1
                    if (fiRecordNr >= 0) {
                        foField = XDOM.getObject(fieldObjName + '_' + this.recordNumber);
                        if (!foField || (foField && foField.tagName !== 'INPUT')) {
                            fsValue = encodeURIField(
                                SESSION.activePage.subfileData[fiRecordNr][fieldName]
                            );
                        }
                    }
                    break;
                default:
                    constValue = foField.getAttribute('data-const-value');
                    if (constValue) {
                        fsValue = constValue;
                    }
                    break;
            }
        }

        if (!foField) {
            foField = XDOM.getObject('trigger_' + fieldObjName);
        }

        if (foField && foField.tagName === 'INPUT') {
            if (foField === targetObj) {
                fsValue = encodeURIField(this.selectionRequest);
            } else {
                if (!Validate.test(foField)) {
                    return 'invalid';
                }
                fsValue = encodeURIField(XDOM.getObjectValue(foField));
            }
        }

        if (fsValue && fsValue != 'undefined') {
            fsRequestUri += fsValue;
        }
    }

    if (this.requiredReturnFields && this.requiredReturnFields != 'undefined') {
        fsRequestUri += this.returnRequiredString();
    }

    this.requestArguments = this.splitSelection(this.selectionRequest);
    return fsRequestUri;
};

/**
 * return required fields
 */
QuickSearch.prototype.returnRequiredString = function() {
    var requiredReturnFields = this.requiredReturnFields;
    var requireSting = '';

    for (var value in requiredReturnFields) {
        requireSting += '&' + value.toString() + '=';
        requireSting += encodeURIField(requiredReturnFields[value]);
    }

    return requireSting;
};
QuickSearch.prototype.getTargetValue = function() {
    var targetObj = this.getTarget();
    var retValue = Mask.getRawValue(targetObj);
    if (!retValue) {
        retValue = XDOM.getObjectValue(targetObj);
    }
    return retValue;
};

QuickSearch.prototype.show = function(delayedOpen) {
    var foField = this.getTarget();
    var selectedField = XDOM.getObject(this.selectFieldId);
    var requestString = null;
    foField.setAttribute('data-block-autosubmit', 'true');

    requestString = this.getTargetValue();

    if (requestString.length < this.minLength && delayedOpen) {
        QuickSearch.blockRequest = false;
        return;
    }

    this.selectionRequest = requestString;

    if (selectedField && this.panel.visible) {
        selectedField.value = this.selectionRequest;
        setCursorToEnd(selectedField);
    }

    this.hideMessage();
    this.request();
};

QuickSearch.prototype.onResponse = function(response) {
    var selectedField = XDOM.getObject(this.selectFieldId);
    var selectedFieldValue = XDOM.getObjectValue(selectedField) || '';
    var targetObj = this.getTarget();
    if (
        response &&
        response.basicConfig &&
        response.basicConfig.requestCount < this.requestCounter
    ) {
        return;
    }
    if (response && response.subfile) {
        this.data = response.subfile;
        this.subfileAttributes = response.subfileAttributes || [];
    } else {
        this.data = [];
        this.subfileAttributes = [];
    }

    this.init(response);
    //bij 1 resultaat die gelijk is aan het verzoek en het scherm is niet geopend door middel van
    if (
        this.data.length === 1 &&
        selectedFieldValue !== targetObj.value &&
        this.data[0][this.keyField] === selectedFieldValue.toUpperCase()
    ) {
        this.table.data = this.data;
        QuickSearch.blockRequest = false;
        QuickSearch.OnSelect(this.qsId, 0, true, true);
        return;
    }

    //f2 of f4 of via klikken op een icoon (openOnRequest = true) dan niet renderen en het scherm verder gewoon sluiten
    if (
        !this.openOnRequest &&
        this.data.length === 1 &&
        this.returnfieldsMatch() &&
        !this.inline
    ) {
        this.table.data = this.data;
        QuickSearch.blockRequest = false;
        QuickSearch.OnSelect(this.qsId, 0, true);
        return;
    }

    //bij automatisch openen - in de response van de marco staat false en de definitie laat het afhangen van de macro...
    if (
        !this.autoOpen &&
        this.activateSearch === '*MACRO' &&
        !this.openOnRequest
    ) {
        //unblock autosubmit for input (it will be set)
        targetObj.setAttribute('data-block-autosubmit', false);
        return;
    }

    //=======================================================>>
    //OPLOSSING POM-2341
    //=======================================================>>

    var targetObj = this.getTarget();
    var toIdValue = targetObj.value || '';
    var sendNewRequest = false;

    //if QS is open get seachField value
    if (this.panel.visible) {
        if (this.selectionRequest !== selectedFieldValue) {
            this.selectionRequest = selectedFieldValue;
            sendNewRequest = true;
        }
        //else get value from target field
    } else {
        if (this.selectionRequest !== toIdValue) {
            this.selectionRequest = toIdValue;
            sendNewRequest = true;
        }
    }

    if (sendNewRequest) {
        //check of er een nieuwe request uit moet of dat we kunnen filteren...
        if (!this.isRendered) {
            this.renderQuickSearch();
        }
        this.getSubSelection();
        if (this.displayData.length == 0) {
            this.request();
            return;
        }
    }

    //=======================================================>>

    if (this.selectionRequest.length >= this.minLength) {
        if (
            this.paramString !== this.getParamString() &&
            this.data.length >= QuickSearch.subSelectOnClient
        ) {
            this.request();
            return;
        }
    }

    QuickSearch.blockRequest = false;

    if (this.isRendered) {
        if (!this.panel.visible) {
            //wordt opnieuw aangeroepen nadat hij gesloten was
            this.panel.show();
            selectedField.value = this.getTargetValue();
            this.lastPreFix = selectedField.value;
        }
        this.getSubSelection();
        this.updateResultIndicator();
        this.table.update(this);
        this.table.setSize();
    } else {
        this.render();
        this.renderResults();
        this.panel.show();
        this.table.setSize();
        this.setDescriptionSize();
        this.updateResultIndicator();
        this.updateRequestArguments()
    }

    //controle op fouten of boodschappen
    this.handleMessages(response);
    this.setDescription(response);
    this.setHeaderTitle(response);
    this.onReloadByMacrotrigger();
    this.focusSelectField();
    setSubviewLoading(this.quickSearchLoader, false);
    setCursorFromStateless();
};

QuickSearch.prototype.saveCurrentState = function(index) {
    this.beforeReload = {
        cursor: this.table.cursor,
        orgCursor: this.table.cursor,
        top: this.table.body.domObject.scrollTop,
        selectionFound: false
    };
};

QuickSearch.prototype.findLastSelected = function(index) {
    if (!this.beforeReload || this.beforeReload.selectionFound) {
        return;
    }
    let record = this.displayData[index];
    for (let fieldName in this.lastSelectedKey) {
        if (record[fieldName] !== this.lastSelectedKey[fieldName]) {
            return;
        }
    }
    this.beforeReload.cursor = index;
    this.beforeReload.selectionFound = true;
};

QuickSearch.prototype.onReloadByMacrotrigger = function(response) {
    if (!this.beforeReload) {
        return;
    }

    let cursor = this.beforeReload.cursor;
    let fromTop = this.beforeReload.top;

    if (cursor > this.data.length) {
        cursor = this.data.length;
    }

    this.table.cursor = cursor;
    this.table.highLightRow();
    if (cursor == this.beforeReload.orgCursor) {
        this.table.body.domObject.scrollTop = this.beforeReload.top;
    }
    this.beforeReload = null;
};

QuickSearch.prototype.focusSelectField = function(response) {
    const selectedField = XDOM.getObject(this.selectFieldId);
    if (!Stateless.canHaveFocus(selectedField)) {
        return;
    }
    selectedField.focus();
    //setCursorToEnd(selectedField); aanpassing ivm POM-3499
};

QuickSearch.prototype.renderQuickSearch = function() {
    this.render();
    this.renderResults();
    this.panel.show();
    this.table.setSize();
    this.setDescriptionSize();
    this.updateResultIndicator();
    this.focusSelectField();
};

QuickSearch.prototype.updateRequestArguments = function() {
    this.requestArguments  = this.splitSelection( XDOM.getObjectValue(this.selectFieldId) || '');
}

QuickSearch.prototype.setDescriptionSize = function() {
    var fiLeft = this.descriptionPlaceHolder.offsetLeft;
    var fiNextLeft = this.NrResultsCaptionPlaceHolder.offsetLeft;
    var fiWidth = fiNextLeft - fiLeft - 5;
    this.descriptionPlaceHolder.style.width = fiWidth + 'px';
};

QuickSearch.prototype.showMessage = function(text, level) {
    if (text === '') {
        this.hideMessage();
        return;
    }
    this.messagePlaceHolder.innerHTML = text;
    this.messagePlaceHolder.style.display = '';
    /*  this.messagePlaceHolder.style.width =  'calc(100% - 42px)';*/
    this.messagePlaceHolder.className = 'STS_' + level;
};

QuickSearch.prototype.hideMessage = function() {
    if (this.messagePlaceHolder) {
        this.messagePlaceHolder.style.display = 'none';
    }
};

QuickSearch.checkAutoOpen = function(autoOpenState) {
    switch (autoOpenState) {
        case '*MANUAL':
            return false;
            break;
        default:
            return true;
            break;
    }
};

QuickSearch.prototype.checkInput = function() {
    var fsMessage = '';
    var selectedFieldValue = XDOM.getObjectValue(this.selectFieldId) || '';
    this.hideMessage();

    if (selectedFieldValue.length < this.minLength) {
        fsMessage = getCapt('gQSEARCHNOTENOUGHIMPUT1');
        fsMessage += this.minLength.toString();
        if (this.minLength === 1) {
            fsMessage += getCapt('gQSEARCHNOTENOUGHIMPUT2');
        } else {
            fsMessage += getCapt('gQSEARCHNOTENOUGHIMPUT3');
        }
        this.resultNumberPlaceHolder.innerHTML = '';
        this.requestArguments = '';
    } else if (this.displayData.length === 0) {
        fsMessage = getCapt('gQSEARCHRESULTSETEMPTY');
    }

    this.showMessage(fsMessage, 'OK');
};

QuickSearch.prototype.handleMessages = function(response) {
    this.checkInput();

    if (!response || !response.data) return;

    this.errorMsg = response.data.WS_ERR;

    var foMessage = QuickSearch.error[response.data.WS_ERR];
    if (foMessage) {
        this.showMessage(foMessage.caption, foMessage.messageLevel);
    }
    return;
};

QuickSearch.prototype.setDescription = function(response) {
    if (response && response.data && response.data.WS_DSC) {
        this.descriptionPlaceHolder.innerHTML = response.data.WS_DSC;
    } else {
        this.descriptionPlaceHolder.innerHTML = '';
    }
};

QuickSearch.prototype.setHeaderTitle = function(response) {
    var title = '';
    if (!response) {
        return; //aangeroepen zonder response gebeurd als het zoek creteria te kort is
        // in dat geval hoeft de title niet opneiuw worden gezet
    }

    this.table.header.update(response.data);
    if (response.basicConfig) {
        var titleText =
            getCapt('cTX_SSN') +
            ': ' +
            response.basicConfig.jobNbr +
            ' \x0A' +
            getCapt('cTX_PGM') +
            ': ' +
            response.basicConfig.macroId;
        GUI.infoTitle.register(this.panel.headerDiv, titleText);
    }

    if (this.titleOrigin === '*LBL') {
        title = this.captions[this.titleVariable];
    } else {
        if (response.data) {
            title = response.data[this.titleVariable];
        }
    }
    this.panel.setTitle(title);
};

QuickSearch.prototype.init = function(response) {
    if (this.isInitialised || !response || !response.config) {
        return;
    }
    var config = response.config;
    var faCols = config.dataCols;
    var foDataCol = null;
    var faHeaders = [];
    var faTableRows = [];
    var fiCol = null;
    var fiRow = null;
    var fsHeaderText = '';
    var fiTotalCols = 0;
    var fiTotalwidth = 0;
    var fiWidth = 0;
    var fsDataType = '';
    var foField = null;
    var fsClassExtend = '';
    var infoPrograms = {};
    this.returnDataFields = config.returnField.split(' ');
    this.requiredReturnFields = config.requiredData;

    this.keyField = this.returnDataFields[this.returnDataFields.length - 1];
    this.captions = config.captionsUserLang;
    if (!this.captions) {
        this.captions = config.captionsDftLang;
    }
    for (var fiCols = config.dataCols.length, i = 0; i < fiCols; i++) {
        foDataCol = faCols[i];
        fiRow = parseInt(foDataCol.rowNum) - 1; //posities in netdata 1-based javascript 0-based
        fiCol = parseInt(foDataCol.colNum) - 1;
        if (fiCol > fiTotalCols) {
            fiTotalCols = fiCol;
        }
        if (
            foDataCol.search === '*YES'
            //&& config.returnField.indexOf(foDataCol.fieldId) === -1 oud zeer altijd zoeken op een veld met search="*YES" N.A.V. POM-2890
        ) {
            this.searchFields[this.searchFields.length] = foDataCol.fieldId;
        }
        if (foDataCol.type === 'infoProgram') {
            infoPrograms[foDataCol.toId] = foDataCol;
        }
        if (
            foDataCol.labelVariable &&
            foDataCol.labelVariable.length > 0 &&
            foDataCol.display === '*YES'
        ) {
            if (!faHeaders[fiRow]) {
                faHeaders[fiRow] = [];
            }
            faHeaders[fiRow][fiCol] = foDataCol;
        }
        if (foDataCol.display === '*YES') {
            this.displayFields.push(foDataCol.fieldId); //pom-1202
            if (!faTableRows[fiRow]) {
                faTableRows[fiRow] = [];
            }
            faTableRows[fiRow][fiCol] = foDataCol;
        }
    }

    for (var fiYLength = faHeaders.length, y = 0; y < fiYLength; y++) {
        if (y > 0) {
            this.table.header.newRow();
        }
        for (var x = 0; x <= fiTotalCols; x++) {
            var foFieldDev = faHeaders[y][x];
            if (foFieldDev) {
                if (foFieldDev.labelOrigin === '*LBL') {
                    fsHeaderText = this.captions[foFieldDev.labelVariable];
                } else {
                    fsHeaderText = ' ';
                }
                fsDataType = foFieldDev.dataType;
            } else {
                fsHeaderText = ' ';
                fsDataType = '';
            }

            foField = new TableField(fsHeaderText);
            foField.qsId = this.qsId;
            foField.dataType = fsDataType;
            foField.cssClass = 'quickSearch-table-header';

            if (foFieldDev) {
                foField.labelOrigin = foFieldDev.labelOrigin;
                foField.labelVariable = foFieldDev.labelVariable;
                foField.fieldName = foFieldDev.fieldId;
                foField.sortAscend = foFieldDev.sortAscend;
                foField.sortDescend = foFieldDev.sortDescend;
                foField.sortSensitivity = foFieldDev.sortSensitivity;
                foField.sortId = foFieldDev.sortId;
                foField.textAlign = foFieldDev.textAlign;
            }

            if (foField.sortAscend === 'true' || foField.sortDescend === 'true') {
                this.SortDefined = true;
            }

            foField.quickSearch = this;
            this.table.header.addField(foField);
        }
    }

    for (var fiYLength = faTableRows.length, y = 0; y < fiYLength; y++) {
        if (y > 0) {
            this.table.body.newRow();
        }
        for (var x = 0; x <= fiTotalCols; x++) {
            fsClassExtend = '';
            foFieldDev = faTableRows[y][x];
            if (foFieldDev) {
                foField = new TableField(foFieldDev.fieldId);
                foField.dataType = foFieldDev.dataType;
                foField.maxScaleSystemLimit = foFieldDev.maxScaleSystemLimit;
                foField.maxScaleField = foFieldDev.maxScaleField;
                foField.blankWhenZero = foFieldDev.blankWhenZero;
                foField.thousandSeparator = foFieldDev.thousandSeparator;
                foField.attentionField = foFieldDev.AttnField;
                foField.textAlign = foFieldDev.textAlign;
                foField.hintOrigin = foFieldDev.hintOrigin;
                foField.hintVariable = foFieldDev.hintVariable;

                foField.setInfoProgram(infoPrograms[foFieldDev.fieldId]);

                if (foFieldDev.colWidth) {
                    fiWidth = parseInt(foFieldDev.colWidth);
                    fiTotalwidth += fiWidth;
                    this.table.columns[x] = fiWidth;
                }
            } else {
                foField = new TableField('');
            }

            if (foField.dataType === '*DEC') {
                fsClassExtend = 'decimal';
            }
            foField.cssClass = 'quickSearch-table-entry ' + fsClassExtend;

            GUI.MaskedOutput.isOutputMask(foField, foFieldDev);
            GUI.Link.isLink(foField, foFieldDev);
            this.table.body.addField(foField);
        }
    }

    this.setSize(fiTotalwidth);
    this.searchFieldsLength = this.searchFields.length;
    this.titleVariable = response.config.panelDef.titleVariable;
    this.titleOrigin = response.config.panelDef.titleOrigin;
    this.autoOpen =
        (response.config.panelDef.autoOpen === 'false') !==
        Boolean(response.config.panelDef.autoOpen);
    this.isInitialised = true;
    return;
};

QuickSearch.prototype.setSize = function(fiTotalWidth) {
    if (this.sizes) {
        return;
    }
    var totalWidth = fiTotalWidth;
    totalWidth *= SETTINGS.charWidth;
    totalWidth += SETTINGS.scrollBarWidth;
    totalWidth += QuickSearch.panelBorderWidth;
    this.panel.width = totalWidth.toString() + 'px';
    this.messageWidth = totalWidth - 20 + 'px';

    if (this.inline) {
        var fiTotalHeight = this.panel.screenDiv.offsetHeight;
        this.sizes = {};
        this.sizes.lineHeight = 20;
        this.sizes.headerHeight = 30;
        this.table.sizes.totalHeight = fiTotalHeight - 2 * this.sizes.headerHeight;

        this.table.sizes.totalWidth =
            floor(100 / this.panelWidth, 2) * (this.panelWidth - 1);
        this.table.totalLines = this.panelheight - 2;
        this.table.inline = true;
        this.sizes.headerHeight += 'px';
    }
};

/**
 * rendert de resultaten (onderste deel van QuickSearch scherm)
 * @returns
 */
QuickSearch.prototype.renderResults = function() {
    var foContent = null;
    this.getSubSelection();

    if (this.panel.contentExists('result')) {
        this.table.update(this);
    } else {
        this.table.data = this.displayData;
        this.table.subfileAttributes = this.displaySubfileAttributes;
        this.table.captions = this.captions;
        foContent = this.table.render();
        this.panel.add(foContent, 'result');
    }
    this.table.setSize();
    this.updateResultIndicator();
    this.table.select(0);
    return;
};

QuickSearch.prototype.getSubSelection = function() {
    var selectedField = XDOM.getObject(this.selectFieldId);
    var selectedFieldValue = this.selectionRequest.trim();
    if (selectedField) {
        //als selectedField niet bestaat dan is het scherm nog niet gerenderd
        selectedFieldValue = selectedField.value;
    }
    var fidata = 0;
    var fiResults = 1;
    var fsSelection = selectedFieldValue.toUpperCase();
    var newIndex = 0;
    this.displayData = [];
    this.displaySubfileAttributes = [];

    var selection = this.splitSelection(fsSelection);
    this.exceedsMaxResults = false;
    if (!this.data || fsSelection.length < this.minLength) {
        return [];
    }
    fidata = this.data.length;
    for (this.cursor = 0; this.cursor < fidata; this.cursor++) {
        if (this.isInSelection(selection)) {
            this.displayData[newIndex] = this.data[this.cursor];
            this.findLastSelected(newIndex);
            this.displaySubfileAttributes[newIndex] =
                this.subfileAttributes[this.cursor] || {};
            newIndex++;

            if (++fiResults > this.maxResults) {
                this.exceedsMaxResults = true;
                return;
            }
        }
    }
    return;
};

/**
 * zet de sleutel waarde van het geselecteerde veld terug naar het target veld
 * @param {type} setFocus
 * @param {type} returnFromResponse
 * @returns {undefined}
 */
QuickSearch.prototype.select = function(setFocus, returnFromResponse) {
    var fbTriggersEvent = false;
    var selectedFieldValue = XDOM.getObjectValue(this.selectFieldId) || '';
    if (this.inSubfile) {
        this.selectSfl();
        return;
    }
    var faRecord = this.table.getCurrentRecord();
    var fiRetFields = this.returnFields.length;
    var fsFieldId = '';
    var foRetField = null;
    var fsRetValue = null;
    var fsPanelId = null;
    var foEdit = null;
    var targetObj = this.getTarget();
    XDOM.focus(this.selectFieldId);
    Stateless.setSubviewActive(this.selectFieldId);
    this.lastSelectedKey = {};
    //clear the fields if any
    XDOM.clearFields(this.clearFields);
    if (faRecord) {
        for (var i = 0; i < fiRetFields; i++) {
            fsFieldId = this.returnFields[i];
            foRetField = XDOM.getObject(fsFieldId);
            this.lastSelectedKey[fsFieldId] = faRecord[this.returnDataFields[i]];
            if (foRetField) {
                if (Trigger.hasTriger(foRetField)) {
                    fbTriggersEvent = true;
                }
                XDOM.setObjectValue(foRetField, faRecord[this.returnDataFields[i]]);
            }
        }
    } else {
        //zet alleen de waarde terug (qua lengte) die in het targetField mag staan
        fsRetValue = selectedFieldValue.substr(
            0,
            XDOM.getObject(this.targetId).maxLength
        );
        XDOM.setObjectValue(this.targetId, fsRetValue);
    }
    resetMessage();
    this.close(true);
    if (this.triggerAction === ENUM.triggerAction.update) {
        Stateless.setSubviewActive(this.selectFieldId);
        Command.ipmfSubmitOnly();
    } else {
        if (isAutoSubmitField(targetObj)) {
            fsPanelId = XDOM.getAttribute(targetObj, 'data-panel-id');

            if (fsPanelId) {
                foEdit = GUI.BasePanel.instances[fsPanelId];
                foEdit.send('ENTER', targetObj.id.replace(fsPanelId + '-', ''));
                return;
            }

            if (!returnFromResponse) {
                Command.enter();
                return;
            }
        }
    }

    if (!isAutoSubmitField(targetObj) && fbTriggersEvent) {
        Trigger.fire(this.returnFields.concat(this.clearFields));
        XDOM.setOldvalue(this.returnFields.concat(this.clearFields));
        return;
    }

    if (setFocus) {
        fp.next(targetObj);
    }

    return;
};

/**
 * zet de sleutel waarde van het geselecteerde veld terug naar het target veld
 * @returns
 */
QuickSearch.prototype.selectSfl = function() {
    var faRecord = this.table.getCurrentRecord();
    var fiRetFields = this.returnFields.length;
    var fsFieldId = '';
    var fsValue = '';
    if (faRecord) {
        for (var i = 0; i < fiRetFields; i++) {
            fsFieldId = this.returnFields[i];
            fsValue = faRecord[this.returnDataFields[i]];
            XDOM.setAxisValue(fsFieldId, this.recordNumber, fsValue);
        }
    }
    Subfile.setChanged(this.recordNumber);
    resetMessage();
    this.close(true);
    INP.handelTriggersAndAutoSubmits(XDOM.getAxis(fsFieldId, this.recordNumber));
};

/**
 * controleerd of het huidige record aangegeven door cursor in data array
 * een veld uit de searchFields array bevat bevat waarvan de waarde voldoet aan een like %[waarde uit selectie veld]%
 * of het sleutelveld bevat dat voldoet aan like [waarde uit selectie veld]%
 * @param selection
 * @returns {boolean}
 */
QuickSearch.prototype.isInSelection = function(selection) {
    var searchString = '';
    var fsFieldId = '';
    var fbResult = false;
    var record = this.data[this.cursor];
    // stel de zoek string samen
    for (var i = 0; i < this.searchFieldsLength; i++) {
        fsFieldId = this.searchFields[i];
        searchString += ' ' + record[fsFieldId].toUpperCase();
    }

    //fbResult = this.valueInRecord(selection[0],searchString);
    //fbResult = this.valueInRecord(selection[1],searchString);

    fbResult =
        this.valueInRecord(selection[0], searchString) &&
        this.valueInRecord(selection[1], searchString);

    return fbResult;
};

QuickSearch.prototype.valueInRecord = function(searchValue, searchString) {
    var record = this.data[this.cursor];
    var fsDataValue = null;
    var searchArguments = null;
    var patern = '';
    if (searchValue === '') {
        return true;
    }

    //maak een array met alle zoekwoorden
    searchArguments = searchValue.split(' ');

    //start het maken van een regular expression .*
    patern = '.*';

    //voeg aan de regular expression de zoekwoorden toe - (?=.*ZOEKWOORD)
    for (var l = searchArguments.length, i = 0; i < l; i++) {
        //escape alle zoekwoorden met speciale tekens zodat de regEx blijft kloppen
        searchArguments[i] = searchArguments[i].replace(
            /[-[\]{}()*+?.,\\^$|#\s]/g,
            '\\$&'
        );

        //combine de zoektermen
        patern += '(?=.*' + searchArguments[i] + ')';
    }

    //creeer regular expression met (I)gnore case sensitive en (G) global
    patern = new RegExp(patern, 'ig');

    //check de zoekstring of hij alle zoekwoorden bevat
    if (patern.test(searchString)) {
        return true;
    }

    for (var l = this.returnFields.length, i = 0; i < l; i++) {
        let returnField = this.returnDataFields[i];
        if (this.displayFields.indexOf(returnField) > -1) {
            //pom1202
            continue;
        }
        fsDataValue = record[returnField];

        if (fsDataValue.startsWith(searchValue)) {
            return true;
        }
    }
    return false;
};

QuickSearch.prototype.returnfieldsMatch = function() {
    var fsFieldValue = '';
    var fsDataValue = null;
    for (var l = this.returnFields.length, i = 0; i < l; i++) {
        if (this.recordNumber) {
            fsFieldValue = XDOM.getAxisValue(this.returnFields[i], this.recordNumber);
        } else {
            fsFieldValue = XDOM.getObjectValue(this.returnFields[i]);
        }

        fsDataValue = this.data[0][this.returnDataFields[i]];
        if (fsDataValue) {
            if (fsFieldValue.toUpperCase() !== fsDataValue.toUpperCase()) {
                return false;
            }
        } else {
            return false;
        }
    }
    return true;
};

QuickSearch.prototype.updateID = function() {
    var objects = XDOM.queryAll("[data-quicksearch-id='" + this.id + "']");
    for (var i = 0, l = objects.length; i < l; i++) {
        objects[i].setAttribute('data-quicksearch-id', this.qsId);
    }
};

QuickSearch.prototype.render = function() {
    var foInputLine = null;
    var selectField = null;
    var targetObj = this.getTarget();
    if (!this.isRendered) {
        this.panel.title = this.captions['mTX_TTL'];
        if (!this.inline) {
            this.panel.onDrop = function() {
                setCursorToEnd(this.guiObject.selectField);
            };
            this.panel.onClose = function() {
                if (SESSION.activePage.modalObject) {
                    SESSION.activePage.modalObject.close();
                }
            };
        }
        foInputLine = XDOM.createElement(
            'DIV',
            'quickSearch-inputLine',
            'searchRow'
        );
        this.selectFieldId = this.qsId + '_search';
        selectField = XDOM.createElement('INPUT', this.selectFieldId, null);

        selectField.setAttribute('autocomplete', 'off');
        selectField.type = 'text';
        selectField.setAttribute('data-quicksearch-selectField', 'true');
        selectField.setAttribute('data-setDefault-events', 'false');
        selectField.setAttribute('data-quicksearch-id', this.qsId);
        selectField.setAttribute('data-datatype', '*QUICKSEARCH');
        selectField.placeholder = getCapt('gQSEARCHEMPTYFIELD');

        if (this.inline) {
            selectField.addEventListener('click', QuickSearch.selectFieldClick)
            selectField.value = '';
        } else {
            selectField.value = this.getTargetValue();
        }

        this.descriptionPlaceHolder = XDOM.createElement(
            'DIV',
            null,
            'quickSearch-description'
        );

        this.resultNumberPlaceHolder = XDOM.createElement(
            'DIV',
            null,
            'quickSearch-nrResults'
        );
        this.resultNumberPlaceHolder.setAttribute('data-hidden', 'false');

        this.quickSearchLoader = XDOM.createElement(
            'DIV',
            null,
            'quickSearch-loader'
        );
        this.quickSearchLoader.setAttribute('data-hidden', 'true');

        this.NrResultsCaptionPlaceHolder = XDOM.createElement(
            'DIV',
            null,
            'textResultFound quickSearch-nrResults-caption'
        );
        this.NrResultsCaptionPlaceHolder.appendChild(
            XDOM.createTextNode(getCapt('gQSEARCHRESULTS') + ':')
        );

        foInputLine.appendChild(selectField);
        foInputLine.appendChild(this.descriptionPlaceHolder);
        foInputLine.appendChild(this.resultNumberPlaceHolder);
        foInputLine.appendChild(this.quickSearchLoader);
        foInputLine.appendChild(this.NrResultsCaptionPlaceHolder);

        this.messagePlaceHolder = XDOM.createElement(
            'DIV',
            'quickSearch-message',
            'quickSearch-message'
        );

        this.panel.add(foInputLine, 'inputPart');
        this.panel.add(this.messagePlaceHolder, 'message');

        if (this.inline) {
            foInputLine.style.height = this.sizes.headerHeight;
        }

        this.isRendered = true;
        this.register();
    }

    if (!this.requery) {
        this.lastPreFix = this.getTargetValue();
        targetObj.value = this.lastPreFix;
    }

    QuickSearch.blockRequest = false;
    return;
};

QuickSearch.prototype.register = function() {
    // var qsId = this.qsId;
    // this.table.onClick = 	function(){QuickSearch.OnSelect(qsId,false);};
};

/**
 * static
 */
QuickSearch.delayedOpen = null;
QuickSearch.blockRequest = false;
QuickSearch.currentInstance = null;
QuickSearch.response = null;
// settings
QuickSearch.subSelectOnClient = 1000; //maximum aantal waarbinnen een subselectie op de client wordt gemaakt
QuickSearch.defaultDelay = 850;
QuickSearch.messageDelay = 2000;
QuickSearch.DefaultmaxResults = 50;
QuickSearch.lineHeight = 16;
QuickSearch.ResultlinesByRecord = [];
QuickSearch.ResultlinesByRecord[1] = 10;
QuickSearch.ResultlinesByRecord[2] = 8;
QuickSearch.ResultlinesByRecord[3] = 5;
QuickSearch.DefaultMinLength = [];
QuickSearch.DefaultMinLength[1] = 1;
QuickSearch.DefaultMinLength[2] = 1;
QuickSearch.DefaultMinLength[3] = 1;
QuickSearch.DefaultMinLength[4] = 2;
QuickSearch.DefaultMinLength[5] = 2;
QuickSearch.DefaultMinLength[6] = 2;
QuickSearch.DefaultMinLength[7] = 3;

QuickSearch.error = [];
QuickSearch.error['HeaderRequired'] = {
    caption: getCapt('gQSEARCHHEADERREQUIRED'),
    messageLevel: 'M'
};
QuickSearch.error['InputRequired'] = {
    caption: getCapt('gQSEARCHINPUTREQUIRED'),
    messageLevel: 'OK'
};
QuickSearch.error['InvalidInput'] = {
    caption: getCapt('gQSEARCHINVALIDINPUT'),
    messageLevel: 'E'
};
QuickSearch.error['SqlPrepareError'] = {
    caption: getCapt('gQSEARCHSQLPREPAREERR'),
    messageLevel: 'E'
};
QuickSearch.error['SqlFetchError'] = {
    caption: getCapt('gQSEARCHSQLFETCHERR'),
    messageLevel: 'E'
};
QuickSearch.error['ResultSetEmpty'] = {
    caption: getCapt('gQSEARCHRESULTSETEMPTY'),
    messageLevel: 'OK'
};

QuickSearch.prototype.registerTrigger = function() {
    if (!this.triggerFields && !this.triggerMacros) {
        return;
    }
    var triggers = this.triggerFields.split(' ');
    var foThis = this;
    for (var i = 0, l = triggers.length; i < l; i++) {
        var fsFieldId = triggers[i]; //var binnen scope in verband met doorgeven by value niet byref(pointer)
        const desc = `QuickSearch: ${this.macro} triggered by field change `;
        Trigger.register(
            fsFieldId,
            'QuickSearch-' + this.macro,
            'QuickSearch.openByTrigger' + this.macro,
            function() {
                QuickSearch.openByTrigger(fsFieldId, foThis);
            },
            desc
        );
    }
    var triggers = this.triggerMacros.split(' ');
    for (var i = 0, l = triggers.length; i < l; i++) {
        var macro = triggers[i]; //var binnen scope in verband met doorgeven by value niet byref(pointer)
        const desc = `QuickSearch: ${this.macro} triggered by macro :`;
        Trigger.register(
            macro,
            'QuickSearch-' + this.macro,
            'QuickSearch.openByTrigger' + this.macro,
            function() {
                QuickSearch.openByTrigger(macro, foThis, true);
            },
            desc
        );
    }
};

QuickSearch.prototype.sort = function(fieldName, sequence, caseSensitive) {
    this.sortField = fieldName;
    this.sortSequence = sequence;

    this.sortCaseSensitive = caseSensitive;
    this.request();
};

QuickSearch.prototype.resetSortButtons = function() {
    var foObj = null;
    for (var fieldName in this.sortfields) {
        foObj = XDOM.getObject(this.qsId + '-A-' + fieldName);
        if (foObj) {
            foObj.className = 'srtascavl pth-icon dataSectionButton';
            foObj.setAttribute('data-sort-active', 'false');
        }
        foObj = XDOM.getObject(this.qsId + '-D-' + fieldName);
        if (foObj) {
            foObj.className = 'srtdscavl pth-icon dataSectionButton';
            foObj.setAttribute('data-sort-active', 'false');
        }
    }
};

/* static */
/* Load Timestamp 13:59:55.668 */
/* global QuickSearch, XDOM, GLOBAL, SESSION, keyCode */

QuickSearch.instances = {};
Barcode.instances = {};

QuickSearch.activate = function () {
    var fsLength = GLOBAL.eventSourceElement.getAttribute(
        'data-quicksearch-activate-after'
    );
    var oIcon = null;
    var value = '';
    var fiLength = 0;
    var autoRequest = false;
    if (!fsLength) {
        return false;
    }
    oIcon = QuickSearch.iconByInput(GLOBAL.eventSourceElement.id);

    if (!oIcon || oIcon.dataset.disable=='true') {
        return false;
    }
    if (GLOBAL.charCode == keyCode.F12 || GLOBAL.charCode == keyCode.escape) {
        return false;
    }
    if (
        GLOBAL.eventSourceElement.maxLength ==
        GLOBAL.eventSourceElement.value.length
    ) {
        //geen vertraging veld is vol
        QuickSearch.gotFocus = true;
        autoRequest = true;

        QuickSearch.open(oIcon, false, null, autoRequest);
        return;
    }

    fiLength = parseInt(fsLength);
    if (GLOBAL.eventSourceElement.value.length >= fiLength) {
        value = GLOBAL.eventSourceElement.value;
        if (GLOBAL.keydownValue.startsWith(value)) {
            return;
        }
        if (oIcon) {
            QuickSearch.openDelayed(oIcon, true);
            XDOM.cancelEvent();
            return true;
        }
    }
    return false;
};

/**
 * sluit eventueel open quicksearch scherm en opent quickSearch voor het qSearchObj
 * @param auto indicatie of het zoekscherm via f2 of f4 is geopend of automatisch
 * @param qSearchObj (optional)
 */
QuickSearch.openByTrigger = function (triggerFieldId, qSearchObj, fromMacro) {
    var foTargetField = XDOM.getObject(qSearchObj.target);
    QuickSearch.blockRequest = true;
    foTargetField.value = '';
    foTargetField.setAttribute('data-old-value', '');
    if (fromMacro) {
        qSearchObj.saveCurrentState();
    }
    qSearchObj.openOnRequest = true;
    qSearchObj.show();
};

QuickSearch.sortButtonClick = function (e) {

    var fsQuickSearchId = e.target.getAttribute('data-quicksearch-id');
    var fsField = e.target.getAttribute('data-sort-field-name');
    if (!fsQuickSearchId || !fsField) {
        return false;
    }
    var fsId = e.target.getAttribute('data-sort-id');
    var fsSequence = e.target.getAttribute('data-sort-sequence');
    var fbCaseSensitive = e.target.getAttribute('data-sort-case-sensitve') == 'true';
    var fbActive = e.target.getAttribute('data-sort-active') == 'true';
    var foQuickSearch = QuickSearch.instances[fsQuickSearchId];
    var foAsc = XDOM.getObject(fsQuickSearchId + '-A-' + fsField);
    var foDesc = XDOM.getObject(fsQuickSearchId + '-D-' + fsField);

    foQuickSearch.resetSortButtons();

    if (fbActive) {
        foQuickSearch.sort('', '', '', '');
        return true;
    }

    if (fsSequence == 'A') {
        foAsc.setAttribute('data-sort-active', 'true');
        foAsc.className = 'srtascsel pth-icon dataSectionButton';
    } else {
        foDesc.className = 'srtdscsel pth-icon dataSectionButton';
        foDesc.setAttribute('data-sort-active', 'true');
    }
    if (fsId) {
        fsField = fsId;
    }

    foQuickSearch.sort(fsField, fsSequence, fbCaseSensitive);
    return true;
};

QuickSearch.autoOpen = function (delayedOpen) {
    if (SESSION.activePage.modalObject.panel.visible) {
        return;
    }

    if (
        !QuickSearch.checkAutoOpen(SESSION.activePage.modalObject.activateSearch)
    ) {
        return;
    }

    QuickSearch.gotFocus = true;
    QuickSearch.blockRequest = true;
    SESSION.activePage.modalObject.openOnRequest = false;
    SESSION.activePage.modalObject.show(delayedOpen);
};

/**
 * sluit eventueel open quicksearch scherm en opent quickSearch voor het obj
 * @param auto indicatie of het zoekscherm via f2 of f4 is geopend of automatisch
 * @param obj (optional)
 */
QuickSearch.open = function (obj, auto, invokee, autoFieldFull) {
    var oInstance = null;
    var qsId = obj.getAttribute('data-quicksearch-id');
    var qsAutoOpen = obj.getAttribute('data-activate-search');

    //request because toId field has maximum length
    if (!auto) {
        if (!QuickSearch.checkAutoOpen(qsAutoOpen)) {
            //return if state is *MANUAL
            return;
        }
    }

    if (SESSION.activePage.modalObject) {
        if (
            qsId === SESSION.activePage.modalObject.qsId &&
            SESSION.activePage.modalObject.panel.visible
        ) {
            //huidig zoekscherm is al open
            return;
        }
    }

    if (QuickSearch.instances[qsId]) {
        oInstance = QuickSearch.instances[qsId];
    } else {
        oInstance = new QuickSearch(obj);
    }
    oInstance.invokee = invokee;
    if (invokee) {
        invokee.setAttribute('data-no-completion', 'true');
    }

    if (autoFieldFull) {
        //automatic request if toid field is full
        if (!QuickSearch.checkAutoOpen(qsAutoOpen)) {
            //return if state is *MANUAL
            return;
        }
    }

    QuickSearch.blockRequest = true;

    if (!oInstance.inline) {
        closePopUp();
        SESSION.activePage.modalObject = oInstance;
    }
    oInstance.openOnRequest = auto;
    oInstance.show();
};

QuickSearch.handleOnClick = function (e) {
    XDOM.getEvent(e)
    if (QuickSearch.handleHeadingClick()) {
        return true;
    }

    if (
        !GLOBAL.eventSourceElement.getAttribute('data-quicksearch-id') ||
        GLOBAL.eventObjectTAG == 'INPUT'
    ) {
        return false;
    }

    XDOM.cancelEvent();
    QuickSearch.open(GLOBAL.eventSourceElement, true);
    return true;
};

QuickSearch.handleHeadingClick = function (e) {
    var thCell = null;
    var serviceId = null;
    var serviceObject = null;
    var serviceType = null;

    //check of er op een columnheading TH is geklikt
    thCell = XDOM.getParentByTagName(GLOBAL.eventSourceElement, 'TH');

    if (!thCell) {
        return false;
    }

    serviceId = thCell.getAttribute('data-search-click-id');
    if (!serviceId) {
        return false;
    }

    serviceObject = XDOM.getObject(serviceId);
    if (!serviceObject || serviceObject.dataset.hidden == 'true') {
        return false;
    }

    serviceType = serviceObject.getAttribute('data-search-type');
    if (serviceType != 'quickSearch') {
        return false;
    }

    XDOM.cancelEvent();
    QuickSearch.open(serviceObject, true);
    return true;
};
//
// /**
//  * deze mag pas na de when.update, cndatributes updat komen
//  * @returns {undefined}
//  */
// QuickSearch.updateDoubleSearch = function () {
//     // zet alle duouble search uit
//     const doubleSearchObjects = XDOM.queryAllScope('[data-double-search="true"]'),
//         availableSearchObjects = XDOM.queryAllScope(
//             '[data-search-id]:not([data-when="unavailable"])'
//         ),
//         availableQuickSearchObjects = XDOM.queryAllScope(
//             '[data-quicksearch-id]:not([data-when="unavailable"])'
//         ),
//         searchObjects = {};
//
//     XDOM.setAttributesToNodeList(
//         doubleSearchObjects,
//         'data-double-search',
//         'false'
//     );
//     XDOM.setAttributesToNodeList(
//         doubleSearchObjects,
//         'data-button-icon',
//         'search'
//     );
//     availableSearchObjects.forEach(
//         obj => (searchObjects[obj.dataset.toId] = obj)
//     );
//
//     availableQuickSearchObjects.forEach(quickSearchObject => {
//         const toId = quickSearchObject.dataset.toId,
//             searchObject = searchObjects[toId];
//         if (!searchObject) {
//             return;
//         }
//         if (
//             searchObject.offsetLeft == quickSearchObject.offsetLeft &&
//             searchObject.offsetHeight == quickSearchObject.offsetHeight
//         ) {
//             searchObject.setAttribute('data-double-search', 'true');
//             quickSearchObject.setAttribute('data-double-search', 'true');
//             quickSearchObject.setAttribute('data-button-icon', 'searchboth');
//             searchObject.setAttribute('data-button-icon', 'searchboth');
//         }
//     });
// };

// opnieuw submitten van alle quicksearch objecten
QuickSearch.updateDom = function () {
    var quickSearchObject = null;
    var promises = []
    for (qsId in QuickSearch.instances) {
        quickSearchObject = QuickSearch.instances[qsId];

        /*alleen updaten als de snelzoek ook in het scherm opgenomen is...*/
        if (SESSION.activePage.macroName === quickSearchObject.embeddedInMacro) {
            promises.push(quickSearchObject.update());
        }
    }
    return promises;
};

QuickSearch.prepareDom = function () {
    var oPageObjects = XDOM.queryAll('DIV[data-quicksearch-id]');
    var oObj = null;
    var screenMode = '';
    QuickSearch.instanceCount = 0; //will be use to make double instances unique
    for (var i = 0, l = oPageObjects.length; i < l; i++) {
        oObj = oPageObjects[i];
        screenMode = oObj.getAttribute('data-screen-mode');
        QuickSearch.prepareDomObj(oObj);

        if (
            screenMode == GUI.BasePanel.screenMode.subview ||
            oObj.getAttribute('data-trigger-fields')
        ) {
            setSubviewLoading(oObj, true);
            var quickSch = new QuickSearch(oObj);
            quickSch.initObj();
        }
    }
};

QuickSearch.prepareDomObj = function (oObj, to) {
    let oTo = null;
    let sToId = '';
    let sMinLength = oObj.getAttribute('data-quicksearch-activate-after');
    let qsId = oObj.getAttribute('data-quicksearch-id');
    //check if this queickSearchId is already in use
    if (XDOM.queryAll(`[data-quicksearch-id="${qsId}"]`).length > 1) {

        qsId +=QuickSearch.instanceCount++;
        oObj.setAttribute('data-quicksearch-id',qsId );
        oObj.id += QuickSearch.instanceCount;
    }

    if (to) {
        oTo = to;
    } else {
        sToId = oObj.getAttribute('data-to-id');
        oTo = XDOM.getObject(sToId);
        if (!oTo) {
            return;
        }
    }

    //bepalen default lengte
    if (!sMinLength || sMinLength === '*AUTO') {
        sMinLength = QuickSearch.getDefaultMinLength(oTo);
        oObj.setAttribute('data-quicksearch-activate-after', sMinLength);
    }
    oTo.setAttribute('data-quicksearch-id', oObj.id);
    oTo.setAttribute('data-quicksearch-activate-after', sMinLength);
    XDOM.classNameReplaceOrAdd(oTo, 'search', 'search');
};

/**
 * blur handler
 */
QuickSearch.onTargetBlur = function () {
    if (
        GLOBAL.eventSourceElement.getAttribute('data-quicksearch-activate-after')
    ) {
        QuickSearch.blockRequest = false;
        //reset QS  modalObj

        //cancel delay but keep modelObject RKR
        //SESSION.activePage.modalObject = null;
        QuickSearch.cancelDelayedOpen();
    }
};

/**
 * request handler
 * @param response
 * @qsId id van de quicksearch
 */
QuickSearch.handleRequest = function (qsId) {
    var foQuickSearchInstance = QuickSearch.instances[qsId];
    if (!foQuickSearchInstance) {
        return;
    } //-->
    if (XDOM.objectUnderModal(foQuickSearchInstance.target)) {
        return;
    }


    if (QuickSearch.response.basicConfig) {
        if (
            foQuickSearchInstance.requestCounter !=
            QuickSearch.response.basicConfig.requestCount
        ) {
            return;
        } //-->
    }
    if (foQuickSearchInstance.isRendered) {
        foQuickSearchInstance.resultNumberPlaceHolder.setAttribute(
            'data-hidden',
            'false'
        );
        foQuickSearchInstance.quickSearchLoader.setAttribute('data-hidden', 'true');
        setSubviewLoading(foQuickSearchInstance.quickSearchLoader, false);
        setCursorFromStateless();
    }

    foQuickSearchInstance.onResponse(QuickSearch.response);
};
/**
 * sluiten van een quick search scherm
 */
QuickSearch.close = function () {
    if (
        SESSION.activePage.modalObject &&
        !SESSION.activePage.modalObject.inline
    ) {
        SESSION.activePage.modalObject.close();
        SESSION.activePage.modalObject = null;
        QuickSearch.gotFocus = false;
        return true;
    }
    return false;
};

QuickSearch.hideTempMessage = function (qs) {
    qs.hideMessage();
};

QuickSearch.setTempMessage = function (message, level) {
    var qs = QuickSearch.get();
    qs.showMessage(message, level);
    setTimeout(function () {
        QuickSearch.hideTempMessage(qs);
    }, QuickSearch.messageDelay);
};

/**
 * Controleeerd of snelzoek open staat als dat zo is mag de enter geen submit veroorzaken
 * true zorgt er voor dat er geen verdere event handeling wordt uitgevoerd
 * handleKeyDown comnt niet meer bij Command.handleKeyDown
 * @returns {Boolean}
 */
QuickSearch.HandleKeyDown = function () {
    var isSelectField =
        (SESSION.activePage.modalObject &&
            SESSION.activePage.modalObject.panel.visible) ||
        XDOM.GLOBAL.getAttribute('data-quicksearch-selectfield');
    switch (GLOBAL.charCode) {
        case keyCode.enter:
            QuickSearch.cancelDelayedOpen();
            return isSelectField;
            break;
    }
    return false;
};

/**
 * verkrijgt het bijbehorende quicksearchId
 * @param {type} obj domobject
 * @returns {undefined}
 */
QuickSearch.getId = function (obj) {
    var id = XDOM.GLOBAL.getAttribute('data-quicksearch-id'),
        maskTarget = XDOM.GLOBAL.getAttribute('data-mask-target');

    if (maskTarget) {
        id = XDOM.getAttribute(maskTarget, 'data-quicksearch-id');
    }
    return id;
};

QuickSearch.get = function () {
    var qsId = QuickSearch.getId(GLOBAL.eventSourceElement);
    return QuickSearch.instances[qsId];
};

/**
 * set focus op subview als die aanwezig is
 */
QuickSearch.selectFieldClick = function (e) {
    Stateless.setSubviewActive(e.target);
};

/**
 * keyUp handler
 */
QuickSearch.HandleKeyUp = function () {
    var qsId = null;
    var qsinstance = null;

    qsId = QuickSearch.getId(GLOBAL.eventSourceElement);
    //key events van uit het quicksearch input veld
    if (XDOM.GLOBAL.getAttribute('data-quicksearch-selectField')) {
        qsinstance = QuickSearch.instances[qsId];
        if (qsinstance.handleKeyUp(GLOBAL.charCode, true)) {
            GLOBAL.eventObject.cancel();
        }
        //quit keyDownHandler
        return true;
    }

    //als het volledige targetveld gevuld is neemt de snelzoek de controle over en volgt er geen autosubmit
    if (qsId) {
        if (
            GLOBAL.charCode == keyCode.tab ||
            GLOBAL.charCode == keyCode.enter ||
            GLOBAL.charCode == keyCode.shift ||
            GLOBAL.charCode == keyCode.arrowUp ||
            GLOBAL.charCode == keyCode.arrowRight ||
            GLOBAL.charCode == keyCode.arrowDown ||
            GLOBAL.charCode == keyCode.arrowLeft
        ) {
            return false;
        }

        if (
            GLOBAL.eventSourceElement.maxLength ==
            GLOBAL.eventSourceElement.value.length
        ) {
            if (
                GLOBAL.charCode == keyCode.F2 ||
                GLOBAL.charCode == keyCode.F4 ||
                GLOBAL.charCode == keyCode.F12 ||
                !XDOM.fieldIsChanged(GLOBAL.eventSourceElement) ||
                GLOBAL.charCode == keyCode.escape
            ) {
                GLOBAL.eventObject.cancel();
                return true;
            }
        }
    }

    //key afhandeling voor een open modal quicksearch
    if (
        SESSION.activePage.modalObject && //     SESSION.activePage.modalObject.id == qsId &&
        SESSION.activePage.modalObject.type == 'quicksearch' &&
        SESSION.activePage.modalObject.panel.visible
    ) {
        SESSION.activePage.modalObject.handleKeyUp(GLOBAL.charCode, false);
        GLOBAL.eventObject.cancel();
        return true;
    }

    return QuickSearch.activate();
};

/**
 * cancelen van delayed open
 */
QuickSearch.cancelDelayedOpen = function () {
    clearTimeout(QuickSearch.delayedOpen);
};

QuickSearch.handleFunctionKEY = function () {
    var invokee = GLOBAL.eventSourceElement;
    var id = invokee.getAttribute('data-mask-target') || invokee.id,
        obj = QuickSearch.iconByInput(id);
    if (obj && obj.getAttribute("data-disable")!="true") {
        QuickSearch.open(obj, true, invokee);
        return true;
    }
    return false;
};

QuickSearch.iconByInput = function (id) {
    return XDOM.query(
        '[data-to-id="' +
        id +
        '"][data-quicksearch-id]:not([data-when="unavailable"])'
    );
};

QuickSearch.getDefaultMinLength = function (obj) {
    var minL = QuickSearch.DefaultMinLength[obj.maxLength];
    if (!minL) {
        minL =
            QuickSearch.DefaultMinLength[QuickSearch.DefaultMinLength.length - 1];
    }
    return minL;
};

QuickSearch.handleFocus = function (qsId) {
    QuickSearch.currentInstance = QuickSearch.instances[qsId];
};

/**
 * opend het snel zoek scherm na quickSearch.delay millie seconden
 * als deze 0 is wordt het scherm direct geopend
 * @param obj
 */
QuickSearch.openDelayed = function (obj) {
    var qsId = obj.getAttribute('data-quicksearch-id');
    if (QuickSearch.blockRequest) {
        return;
    }
    closePopUp();
    QuickSearch.cancelDelayedOpen();
    if (QuickSearch.instances[qsId]) {
        SESSION.activePage.modalObject = QuickSearch.instances[qsId];
    } else {
        SESSION.activePage.modalObject = new QuickSearch(obj);
    }
    QuickSearch.delayedOpen = setTimeout(
        'QuickSearch.autoOpen(true);',
        QuickSearch.defaultDelay
    );
};

/**
 * wordt aangeroepen op de onclick van een body regel
 * deze functie heeft een andere signatuur omdat hij statisch is (niet object gebonden)
 * @param iCursor
 */
QuickSearch.OnSelect = function (qsId, rowNr, setFocus, responseReturn) {
    var foQuickSearch = QuickSearch.instances[qsId];
    var returnFromResponse = responseReturn || false;

    if (foQuickSearch) {
        foQuickSearch.table.cursor = rowNr;
        foQuickSearch.select(setFocus, returnFromResponse);
        QuickSearch.gotFocus = false;
    }
};

/* table */
/* Load Timestamp 13:59:55.668 */
function Table(id) {
    this.id = id;
    this.data = [];
    this.columns = [];
    this.header = new TableHeader(this);
    this.body = new TableBody(this);
    this.domObject = null;
    this.maxRows = 999999;
    this.onClick = null;
    this.width = '';
    this.totalWidth = 0;
    this.cursor = 0;
    this.displayedRecords = [];
    this.sizes = {};
    this.inline = false;
    this.lastSelectedRecord = null;
    this.bodyDivHeight = 0;
    this.dom = {};
    this.qsId = null;
    Table.add(this);
}

//static
Table.fieldType = {"data": 'd', "header": 'h'};
Table.tableInstances = [];

Table.rowClickHandler = function (e) {
    XDOM.getEvent(e);
    //check if this a link
    if (e.target.tagName === 'A') {
        //if so don't execute the rowclick event
        return;
    }

    var tbody = XDOM.getParentByTagName(GLOBAL.eventSourceElement, "TBODY");
    var rowNr = tbody.getAttribute("data-table-cursor");
    var Tableid = tbody.getAttribute("data-table-id");

    var qsId = tbody.getAttribute("data-quicksearch-id");
    QuickSearch.OnSelect(qsId, parseInt(rowNr), true);

    var foTable = Table.tableInstances[Tableid];
    if (foTable) {
        foTable.cursor = parseInt(rowNr);
        foTable.highLightRow();
    }
};

Table.add = function (table) {
    Table.tableInstances[table.id] = table;
};


Table.prototype.renderColGroup = function (forHeader) {
    if (this.inline) {
        return this.renderInlineColGroup();
    }
    var foColGroup = null;
    var fiCols = this.columns.length;
    var fiPXWidth = 0;
    var fiPXTotalWidth = 0;
    var foCol = null;
    if (fiCols === 0) {
        return;
    }
    foColGroup = XDOM.createElement('COLGROUP');
    for (var i = 0; i < fiCols; i++) {
        if (this.columns[i]) {
            fiPXWidth = SETTINGS.charWidth * this.columns[i];
            foCol = XDOM.createElement('COL');
            foCol.style.width = fiPXWidth.toString() + 'px';
            foColGroup.appendChild(foCol);
            fiPXTotalWidth += fiPXWidth;
        }
    }

    if (forHeader) {
        this.totalWidth = (fiPXTotalWidth + fiCols - 1);
    }

    this.width = fiPXTotalWidth.toString() + 'px';
    return foColGroup;
};

Table.prototype.renderInlineColGroup = function () {
    var fitotalColumns = 0;
    var fiTotalWidth = 0;
    var fiColWidth = 0;
    var fiWidth = 0;
    var foCol = null;
    var foColGroup = XDOM.createElement('COLGROUP');

    if (this.columns.length === 0) {
        return foColGroup;
    }

    for (var i = 0, l = this.columns.length; i < l; i++) {
        fitotalColumns += this.columns[i];
    }

    fiColWidth = floor(100 / fitotalColumns, 2);

    for (var i = 0, l = this.columns.length; i < l; i++) {
        if (i === l - 1) {//laatste colomn
            fiWidth = 100 - fiTotalWidth;
        } else {
            fiWidth = fiColWidth * this.columns[i];
            fiTotalWidth += fiWidth;
        }
        foCol = XDOM.createElement('COL');
        foCol.style.width = fiWidth + '%';
        foColGroup.appendChild(foCol);
    }

    return foColGroup;
};

//regelt de grotes voor inline tables: tables waarbij de buitenkant bepaaald hoe groot ze zijn en die in procenten gezet worden
Table.prototype.setSize = function () {
    if (!this.inline) {
        return;
    }
    var fiHeaderRows = this.header.rows.length;
    var fiHeaderHeight = fiHeaderRows * 20;
    var fiFullWidth = 0;

    this.domObject.style.height = this.sizes.totalHeight + 'px';
    this.header.domObject.style.height = fiHeaderHeight + 'px';
    this.backgroundDomObject.style.height = fiHeaderHeight + 'px';
    this.body.domObject.style.height = this.sizes.totalHeight - fiHeaderHeight + 'px';
    this.body.domObject.style.minHeight = this.sizes.totalHeight - fiHeaderHeight + 'px';

    this.domObject.style.width = this.sizes.totalWidth + '%';
    this.header.tableDomObject.style.width = "100%";
    this.header.tableDomObject.style.height = "100%";
    this.body.domObject.style.width = "100%"; //eerst 100% zetten en dan pas in pixels zodat we die kunnen opvragen en later geen afrondingsfouten meer kunnen hebben
    fiFullWidth = this.domObject.offsetWidth;
    this.body.domObject.style.width = fiFullWidth + 'px';

    //nu kunnen we de breedte van de header zetten afgeleid van de body - 16px voor de scrollbar
    this.header.domObject.style.width = fiFullWidth - BrowserDetect.scrollbarWidth + 'px';
    this.body.tableDomObject.style.width = "100%";
};

Table.prototype.render = function () {

    this.domObject = XDOM.createElement('DIV', this.id, 'regularTable');
    this.backgroundDomObject = XDOM.createElement('DIV', null, 'tableHeaderBackground theme-background-color');
    this.header.render();
    this.body.render();

    this.domObject.appendChild(this.backgroundDomObject);
    this.domObject.appendChild(this.header.domObject);
    this.domObject.appendChild(this.body.domObject);
    return this.domObject;
};

Table.prototype.select = function (iRowNr) {
    this.cursor = iRowNr;
    this.highLightRow();
};

Table.prototype.rowUp = function () {
    this.cursor--;
    if (this.cursor < 0) {
        this.cursor = this.displayedRecords.length - 1;
    }
    this.highLightRow();
};

Table.prototype.rowDown = function () {
    this.cursor++;
    if (this.cursor >= this.displayedRecords.length) {
        this.cursor = 0;
    }
    this.highLightRow();
};


Table.prototype.update = function (qs) {
    this.data = null;
    this.cations = null;
    this.subfileAttributes = [];

    if (qs) {
        this.data = qs.displayData;
        this.cations = qs.captions;
        this.subfileAttributes = qs.subfileAttributes || [];
    }

    this.displayedRecords = [];
    this.cursor = 0;
    XDOM.removeDOMObject(this.body.domObject);
    this.body.render();
    this.select(0);
};


Table.prototype.getCurrentRecord = function () {
    if (!this.data) {
        return null;
    }

    return this.data[this.cursor];
};

Table.prototype.highLightRow = function () {
    //unselect previous  field
    if (this.lastSelectedRecord) {
        this.lastSelectedRecord.className = this.lastSelectedRecord.className.replace('table-row-highlight', '');
        this.lastSelectedRecord.setAttribute('data-record-selected','');
    }

    this.lastSelectedRecord = this.displayedRecords[this.cursor];
    if (this.lastSelectedRecord) {
        this.lastSelectedRecord.className += ' table-row-highlight';
        scrollIntoView(this.lastSelectedRecord, this.body.domObject);
    }
};






/* panel */
/* Load Timestamp 13:59:55.669 */
function Panel(id, classname,obj) {
    this.id = id;
    this.width = '';
    this.height = '';
    this.title = '';
    this.header = {};
    this.header.title = '';
    this.domObject = null;
    this.guiObject = null;
    this.screenDiv = null;
    this.headerDiv = null;
    this.headerTextDiv = null;
    this.bodyDiv = null;
    Panel.instances[this.id] = this;
    this.alignTo = false;
    this.visible = false;
    this.content = [];
    this.onDrop = null;
    this.onFocus = null;
    this.onShow = null;
    this.onClose = null;
    this.inline = null;
    if (!classname) {
        this.classname = '';
    } else {
        this.classname = classname;
    }



}

Panel.instances = [];

Panel.closePanelClick = function () {
    var id = XDOM.GLOBAL.getAttribute("close-panel-id");
    if (id) {
        if (Panel.instances[id].onClose) {
            Panel.instances[id].onClose();
        }
        Panel.instances[id].close();
        return true;
    }
    return false;
};

Panel.startDragging = function (e, id) {
    if (BrowserDetect.isIE || BrowserDetect.isSafari) {
        return;
    }
    var foEvent = XDOM.getEvent(e);

    if (foEvent.srcElement.id == "MEXIT") {
        return;
    }
    var foInstance = Panel.instances[id];
    Dragger.guiObject = foInstance;
    Dragger.domObject = foInstance.domObject;
    GLOBAL.mouseKeyDown = true;
    Dragger.start(e);
};

Panel.focus = function (id) {
    if (Panel.instances[id].onFocus) {
        Panel.instances[id].onFocus();
    }
};

Panel.prototype.close = function () {
    if (!this.visible) {
        return;
    }
    this.domObject.style.display = 'none';
    //this.headerDiv.style.cursor = 'default';
    //this.headerDiv.style.cursor = 'move';
    this.visible = false;

//	if(this.onClose){
//	  this.onClose();
//	}

    ScreenBlokker.hide();
};

Panel.prototype.render = function () {

    var obj = null;
    this.domObject = XDOM.createElement('DIV', this.id, 'popup popup-panel ' + this.classname);
    if (this.inline) {

        this.domObject.style.width = "100%";//(100/this.cols) * this.cols-2 +
        this.domObject.style.height = "100%";//(100/this.rows) * this.rows-2 +
    } else {
        if (this.width) {
            this.domObject.style.width = this.width;
        }
        if (this.height) {
            this.domObject.style.height = this.height;
        } else {
            this.domObject.style.height = "auto";
        }
    }


    this.domObject.id = this.id;
    this.domObject.setAttribute("data-update-dom-depth", "false");
    updatePanelSort(this.domObject);

    this.screenDiv.appendChild(this.domObject);
    this.renderHeader();
    this.renderBody();

    for (var s in this.content) {
        obj = this.content[s];
        if (typeof (obj) == 'object') {
            this.bodyDiv.appendChild(obj);
        }

    }


    this.visible = true;

};

Panel.prototype.setTitle = function (title) {
    this.title = title;
    this.headerTextDiv.childNodes[0].nodeValue = this.title;
};
Panel.prototype.renderHeader = function () {
    //if(this.inline){return;}
    var foTitel = XDOM.createTextNode(this.title);
    var fsPanelId = this.id;

    this.headerDiv = XDOM.createElement('DIV');
    this.headerTitleIcon = null;
    this.headerDiv.id = "panel-header-" + this.id;
    this.headerDiv.className = "panelHeader theme-background-color";
    this.headerTextDiv = XDOM.createElement('DIV', null, 'panelTitle');

    if (this.inline) {
        if (this.panelIconClass && this.panelIconClass != "") {
            this.headerTitleIcon = XDOM.createElement('i', null, 'panelHeaderIcon ' + getFontPrefix(this.panelIconGroup) + this.panelIconClass);
            this.headerDiv.appendChild(this.headerTitleIcon);
        }
    }

    this.headerTextDiv.appendChild(foTitel);


    this.headerDiv.appendChild(this.headerTextDiv);

    if (this.inline) {
        this.headerDiv.style.cursor = 'default';
    } else {
        var foExit = XDOM.createElement('DIV');
        foExit.id = 'MEXIT';
        foExit.className = 'popup-close pth-icon';
        foExit.setAttribute("close-panel-id", this.id);
        this.headerTextDiv.appendChild(foExit);
        this.headerDiv.style.cursor = 'move';

        this.headerDiv.setAttribute("data-mouseDown-action", "Dragger.start");
        this.headerDiv.setAttribute("data-dragger-objId", this.id);

        this.headerTextDiv.setAttribute("data-mouseDown-action", "Dragger.start");
        this.headerTextDiv.setAttribute("data-dragger-objId", this.id);

    }

    this.domObject.appendChild(this.headerDiv);
    return;
};


Panel.prototype.renderBody = function () {
    if (this.bodyDiv && this.bodyDiv.parent) {
        this.bodyDiv.parent.removeChild(this.bodyDiv);
    }
    this.bodyDiv = XDOM.createElement('DIV');
    this.bodyDiv.id = "panel-body-" + this.id;
    this.bodyDiv.className = "panelBody";

    this.domObject.appendChild(this.bodyDiv);
};

Panel.prototype.add = function (domHTMLObject, id) {
    var foDomObject = domHTMLObject;
    if (domHTMLObject.domObject) {
        foDomObject = domHTMLObject.domObject;
    }
    if (!id) {
        this.content[this.content.length] = foDomObject;
    } else {
        this.content[id] = foDomObject;
    }
    if (this.bodyDiv) {
        this.bodyDiv.appendChild(foDomObject);
    }
};

Panel.prototype.getContent = function (id) {
    return this.content[id];
};

Panel.prototype.clearContent = function (id) {
    if (id) { // verwijder 1 instantie 1
        if (this.content[id] && this.content[id].parent) {
            this.content[id].parent.removeChild(this.content[id]);
            this.content[id] = null;
        }
    } else { // schrijf de body opnieuw
        this.content = [];
        this.renderBody();
    }
    return;
};

Panel.prototype.contentExists = function (id) {
    if (this.content[id]) {
        return true;
    }
    return false;
};

Panel.prototype.show = function () {
    if (!this.domObject) {
        this.render();
    } else {
        updatePanelSort(this.domObject);
    }
    if (this.onShow) {
        this.onShow();
    }
    if (this.onFocus) {
        this.onFocus();
    }

    if (this.modal) {
        ScreenBlokker.show(this.z - 1);
    }
    this.domObject.style.display = '';

    this.visible = true;

    if (this.alignTo && !this.inline) {
        var position = alignTo(this.domObject, this.alignTo);
        this.domObject.style.top = position.top + 'px';
        this.domObject.style.left = position.left + 'px';
    }
};


/* header */
/* Load Timestamp 13:59:55.669 */
/* global Table, XDOM */

function TableHeader(parent) {
    this.rows = [];
    this.parent = parent;
    this.rows[0] = [];
    this.domObject = null;
    this.backgroundDomObject = null;
    this.tableDomObject = null;
};


TableHeader.prototype.newRow = function () {
    this.rows[this.rows.length] = [];
    return;
};

TableHeader.prototype.addField = function (field) {
    field.type = Table.fieldType.header;
    field.caption = field.id;
    var faCurrentRow = this.rows[this.rows.length - 1];
    faCurrentRow[faCurrentRow.length] = field;
    return;
};

/**
 * POM-1539
 * Headers van een snelzoek kunnen dynamisch zijn opgebouwd
 * @param {type} data
 * @returns {void}
 */
TableHeader.prototype.update = function (data) {
    if (!data) {
        return;
    }
    var dbHeaders = this.domObject.querySelectorAll("[data-quicksearch-heading-field]"),
        label = null;

    for (var i = 0, l = dbHeaders.length; i < l; i++) {
        label = dbHeaders[i];
        label.innerHTML = data[label.getAttribute("data-quicksearch-heading-field")] || "*---*";
    }
};

TableHeader.prototype.render = function () {
    if (this.domObject) {
        return;
    }
    var fiHeaderRows = this.rows.length;
    var faCells = null;
    var fiCells = 0;
    var foCell = null;
    var foTBODY = null;
    var foTR = null;
    var foTH = null;
    var foColGroep = null;


    this.domObject = XDOM.createElement('DIV', this.parent.id + 'tableHeader', 'table-header-div');
    this.tableDomObject = XDOM.createElement('TABLE', this.parent.id + 'header', 'regularTableHeader');

    this.domObject.appendChild(this.tableDomObject);

    foColGroep = this.parent.renderColGroup(true);
    this.tableDomObject.appendChild(foColGroep);
    foTBODY = XDOM.createElement('THEAD');
    this.tableDomObject.appendChild(foTBODY);


    for (var i = 0; i < fiHeaderRows; i++) {
        foTR = XDOM.createElement('TR');
        foTBODY.appendChild(foTR);
        faCells = this.rows[i];
        fiCells = faCells.length;
        for (var n = 0; n < fiCells; n++) {
            foCell = faCells[n];
            foTH = foCell.renderHeaderCel();
            foTR.appendChild(foTH);
        }
    }
    return;
};


/* body */
/* Load Timestamp 13:59:55.669 */
/* global XDOM */

function TableBody(parent) {
    this.rows = [];
    this.rows[0] = [];
    this.parent = parent;
    this.tableDomObject = null;
    this.domObject = null;
    this.bodyHeight = null;
}

TableBody.prototype.newRow = function () {
    this.rows[this.rows.length] = [];
    return;
};

TableBody.prototype.addField = function (field) {
    var faCurrentRow = this.rows[this.rows.length - 1];
    faCurrentRow[faCurrentRow.length] = field;
    return;
};


TableBody.prototype.render = function () {
    var fiDataLength = 0;
    if (this.parent.data) {
        fiDataLength = this.parent.data.length;
    }

    XDOM.removeDOMObject(this.domObject);
    this.domObject = null;

    this.domObject = XDOM.createElement('DIV', this.parent.id + 'Body', 'table-body-div');

    if (this.bodyHeight) {
        this.domObject.style.height = this.bodyHeight;
        this.domObject.style.minHeight = this.bodyHeight;
    }

    this.tableDomObject = XDOM.createElement('TABLE', this.parent.id + 'body', 'regularTableBody qsResultTable');

    this.tableDomObject.appendChild(this.parent.renderColGroup());
    this.domObject.appendChild(this.tableDomObject);
    this.parent.domObject.appendChild(this.domObject);

    if (!this.parent.data || this.parent.data.length === 0) {
        return;
    }
    for (this.cursor = 0; this.cursor < fiDataLength && this.cursor < this.parent.maxRows; this.cursor++) {
        this.renderRecord();
    }

    return;
};

TableBody.prototype.renderRecord = function () {
    var fiRows = this.rows.length;
    var faCells = null;
    var fiCells = 0;
    var foCell = null;
    var foTbody = null;
    var foTD = null;
    var foTR = null;
    var record = this.parent.data[this.cursor];
    var subfileAttributes = this.parent.subfileAttributes[this.cursor] || {};
    var fsData = '';
    var foCaptions = this.parent.captions;

    foTbody = XDOM.createElement('TBODY');
    foTbody.setAttribute("data-table-cursor", this.cursor);
    foTbody.setAttribute("data-quicksearch-id", this.parent.qsId);
    foTbody.setAttribute("data-table-id", this.parent.id);
    foTbody.addEventListener('click', Table.rowClickHandler);

    this.tableDomObject.appendChild(foTbody);
    this.parent.displayedRecords[this.cursor] = foTbody;

    if (this.cursor % 2 === 0) {
        foTbody.className = "table-row";
    } else {
        foTbody.className = "table-alt-row";
    }

    for (var i = 0; i < fiRows; i++) {
        foTR = XDOM.createElement('TR');
        foTbody.appendChild(foTR);
        foTR.style.height = "19px";
        faCells = this.rows[i];
        fiCells = faCells.length;
        for (var n = 0; n < fiCells; n++) {
            foCell = faCells[n];

            if (record[foCell.id]) {
                fsData = record[foCell.id];
            } else {
                fsData = "";
            }
            foTD = foCell.render(fsData, foCaptions, record, subfileAttributes, this.cursor);
            foTD.addEventListener('click', Table.rowClickHandler)
            foTD.setAttribute("data-click-action", "Table.rowClickHandler");
            foTD.setAttribute("data-table-cursor", this.cursor);
            foTD.setAttribute("data-table-id", this.parent.id);
            foTR.appendChild(foTD);
        }

    }
};


/* field */
/* Load Timestamp 13:59:55.670 */
function TableField(id, cssClass, colSpan) {
    this.id = id;
    this.type = Table.fieldType.data;
    this.colSpan = 1;
    this.caption = '';
    this.labelOrigin = '';
    this.labelVariable = '';
    this.maxScaleSystemLimit = null;
    this.maxScaleField = null;
    this.blankWhenZero = null;
    this.thousandSeparator = null;
    this.attentionField = null;
    if (colSpan) {
        this.colSpan = colSpan;
    }
    this.cssClass = cssClass;
    this.sortAscend = null;
    this.sortDescend = null;
    this.sortSensitivity = null;
    this.sortId = null;
    this.qsId = null;
    this.fieldName = null;
    this.textAlign = null;
    this.infoProgram = null;
    this.whenField = null;
    this.whenValue = null;
}

/**
 *
 * @returns {domObject}
 */
TableField.prototype.renderHeaderCel = function () {
    var foDomObject = XDOM.createElement('TH', null, this.cssClass);
    var foWrapper = XDOM.createElement("DIV", null, "thWrapper");
    var foSort = XDOM.createElement("DIV", null, "srtcol");
    var foAsc = null;
    var foDesc = null;
    var foLabel = XDOM.createElement("LABEL");
    var fsText = this.caption;

    if (this.labelOrigin === "*VAR") {
        foLabel.setAttribute("data-quicksearch-heading-field", this.labelVariable);
    }

    if (fsText === '') {
        fsText = " ".nonBreakingSpace();
    }
    if (this.sortAscend === "true") {
        this.quickSearch.sortfields[this.fieldName] = this.fieldName;
        foAsc = XDOM.createElement("DIV", this.qsId + '-A-' + this.fieldName, "srtascavl pth-icon dataSectionButton");
        foAsc.setAttribute("data-quicksearch-id", this.qsId);
        foAsc.setAttribute("data-sort-sequence", "A");
        foAsc.setAttribute("data-sort-field-name", this.fieldName);
        foAsc.setAttribute("data-sort-id", this.sortId);
        foAsc.setAttribute("data-sort-case-sensitve", this.sortSensitivity);
        foAsc.setAttribute("data-sort-active", "false");
        foAsc.title = getCapt('cSRTASC_TTL');
        foAsc.addEventListener('click', QuickSearch.sortButtonClick);
        foSort.appendChild(foAsc);

    }


    if (this.sortDescend === "true") {
        this.quickSearch.sortfields[this.fieldName] = this.fieldName;
        foDesc = XDOM.createElement("DIV", this.qsId + '-D-' + this.fieldName, "srtdscavl pth-icon dataSectionButton");
        foDesc.setAttribute("data-quicksearch-id", this.qsId);
        foDesc.setAttribute("data-sort-id", this.sortId);
        foDesc.setAttribute("data-sort-field-name", this.fieldName);
        foDesc.setAttribute("data-sort-sequence", "D");
        foDesc.setAttribute("data-sort-case-sensitve", this.sortSensitivity);
        foDesc.setAttribute("data-sort-active", "false");
        foDesc.addEventListener('click', QuickSearch.sortButtonClick);
        foDesc.title = getCapt('cSRTDSC_TTL');
        foSort.appendChild(foDesc);

    }
    foLabel.appendChild(XDOM.createTextNode(fsText));
    foDomObject.appendChild(foWrapper);

    if ((this.sortAscend === "true") || (this.sortDescend === "true")) {
        foWrapper.appendChild(foSort);
        XDOM.classNameReplaceOrAdd(foLabel, "sortEnabled", "sortEnabled");
    }

    foWrapper.appendChild(foLabel);
    foDomObject.colSpan = this.colSpan;

    if (this.dataType === '*DEC' || this.dataType === '*VARDEC') {
        XDOM.classNameReplaceOrAdd(foLabel, "alignRight", "alignRight");
    }

    foLabel.style.width = "100%";
    switch (this.textAlign) {
        case "*LEFT":
            XDOM.classNameReplaceOrAdd(foLabel, "alignLeft", "alignLeft");
            break;
        case "*RIGHT":
            XDOM.classNameReplaceOrAdd(foLabel, "alignRight", "alignRight");
            break;
        case "*CENTER":
            XDOM.classNameReplaceOrAdd(foLabel, "alignCenter", "alignCenter");
            break;
        default:
            break;
    }

    return foDomObject;
};

/**
 * aanpasing in data structuur kan lijden tot het niet meer goed werken van specifieke
 * @param {type} text
 * @param {type} captions
 * @param {type} record
 * @param {type} subfileAttributes
 * @param {type} number
 * @returns {domObject}
 */
TableField.prototype.render = function (text, captions, record, subfileAttributes, number) {
    var foDomObject = null;
    var fiMaxScale = null;
    var foMaxScale = null;
    var fsAttentionLevel = null;

    this.number = number;
    this.record = record;
    this.subfileAttributes = subfileAttributes;

    if (this.maxScaleField) {
        fiMaxScale = subfileAttributes[this.maxScaleField];
    }

    fsAttentionLevel = ENUM.attentionLevelReverse[subfileAttributes[this.attentionField]];

    var fsText = null;
    if (this.type === Table.fieldType.data) {
        foDomObject = XDOM.createElement('TD', null, this.cssClass);
        if (fsAttentionLevel) {
            foDomObject.className += ' ' + fsAttentionLevel;
        }
        fsText = text;
    } else {
        foDomObject = XDOM.createElement('TH', null, this.cssClass);
        fsText = this.caption;
    }

    if (fsText === '') {
        fsText = " ".nonBreakingSpace();
    }
    foDomObject.colSpan = this.colSpan;


    if (this.blankWhenZero === ENUM.blankWhenZero.blank && isZero(fsText)) {
        fsText = '';
    }

    if (this.thousandSeparator) {
        fsText = formatThousand(fsText);
    }

    switch (this.dataType) {

        case '*LNK':
            if (fsText.trim().length > 0) {
                var showInSubfile = true;
                var foLinkObj = new GUI.Link(this);
                foLinkObj.id = this.id + "_" + this.number;
                foLinkObj.value = this.record[this.id];

                // if (foLinkObj.urlType !== "*HashedUrl") {
                //     foLinkObj.value = foLinkObj.value.toLowerCase();
                // }
                foLinkObj.extension = subfileAttributes[this.aliasField];
                foDomObject.appendChild(foLinkObj.render(showInSubfile));
            }
            break;
        case '*DEC':
            foDomObject.style.textAlign = "right";
            XDOM.setAttribute(foDomObject, "data-td-value", fsText);

            if (fiMaxScale) {
                foMaxScale = formatMaxScale(fsText, this.maxScaleSystemLimit, fiMaxScale);
                fsText = foMaxScale.value;
                foSpan = XDOM.createElement("span", null, "qsearchDec " + foMaxScale.cssClass);
                foDomObject.appendChild(foSpan);
                foSpan.appendChild(XDOM.createTextNode(fsText));
            } else {
                foDomObject.appendChild(XDOM.createTextNode(fsText));
            }
            break;
        case '*VARDEC':
            foDomObject.style.textAlign = "right";
            foDomObject.appendChild(XDOM.createTextNode(fsText));
            break;
        default:

            if (this.isMask) {
                var showInSubfile = true;
                var foMaskObj = new GUI.MaskedOutput(this);
                foMaskObj.value = this.record[this.id];
                foDomObject.appendChild(foMaskObj.render(showInSubfile));
            } else {
                foDomObject.style.textAlign = "left";
                foDomObject.appendChild(XDOM.createTextNode(fsText));
            }
    }

    if (this.infoProgram) {
        this.renderInfoProgramIcon(foDomObject);
    }


    switch (this.textAlign) {
        case "*LEFT":
            foDomObject.style.textAlign = "left";
            break;
        case "*RIGHT":
            foDomObject.setAttribute("data-align", "right");
            foDomObject.style.textAlign = "right";
            break;
        case "*CENTER":
            foDomObject.style.textAlign = "center";
            break;
        default:
            break;
    }

    var titleString = null;
    if (this.hintOrigin && this.hintVariable) {
        switch (this.hintOrigin) {
            case "*VAR":
                titleString = this.record[this.hintVariable];
                break;
            case "*LBL":
                if (captions && hasValue(captions[this.hintVariable])) {
                    titleString = captions[this.hintVariable];
                }
                break;
        }
        GUI.infoTitle.register(foDomObject, titleString);
    }

    return foDomObject;
};

TableField.prototype.checkWhen = function (value) {
    const field = this.infoProgram.whenField
    if (!field) {
        //no when conditions
        return true;
    }
    //check if whenfield is defined and equal to field in record or subfileAttributes
    return (
        this.record[field] == value ||
        this.subfileAttributes[field] == value
    );
}
/**
 * renderd het info icoon
 * @param {cel} cell td objectje
 * @returns {void}
 */
TableField.prototype.renderInfoProgramIcon = function (cell) {

    if (!this.checkWhen(this.infoProgram.whenValue)) { //return if when condition is not met
        return;
    }


    var id = "qs-info-" + this.id + '-' + this.number,
        div = XDOM.createElement("div", id, " pth-icon dataSectionButton theme-hover-color infoProgram  pth-infoProgram"),
        paramValues = [],
        paramObject = null;
    for (var i = 0, l = this.infoProgram.parmObject.length; i < l; i++) {
        paramObject = this.infoProgram.parmObject[i];
        if (paramObject.location === 'subfileData') {
            paramObject = {
                "location": "directValue",
                "value": this.record[paramObject.field]
            };
        }
        paramValues.push(paramObject);
    }

    div.setAttribute("data-parm-object", JSON.stringify(paramValues));
    div.setAttribute("data-panel-id", id);
    div.setAttribute("data-macro-name", this.infoProgram.macroName);
    div.setAttribute("data-macro-location", this.infoProgram.location || 'dbs');
    div.setAttribute("data-info-id", "INFO-" + id);
    div.setAttribute("data-to-id", "");
    div.setAttribute("data-click-action", "GUI.InfoWindow.handleClick");
    div.setAttribute("data-mouseover-action", "GUI.InfoWindow.handleMouseOver");
    div.setAttribute("data-mouseout-action", "GUI.InfoWindow.handleMouseOut");


    cell.appendChild(div);
    XDOM.addEventListener(div, "mouseover", handleMouseOver);
    XDOM.addEventListener(div, "mouseout", handleMouseOut);

};

TableField.prototype.setInfoProgram = function (infoPgm) {
    if (!infoPgm) {
        return;
    }
    infoPgm.parmObject = XDOM.parse(infoPgm.parmObject);
    this.infoProgram = infoPgm;
};
/* validationTree */
/* Load Timestamp 13:59:55.670 */
/**
 * object voor het opslaan van de gehele boom aan mogelijkheden Binnen het sessie niveau
 * dus alle procedures met alle subprocedures en macro's
 * deze wordt eerst opgebouwd en vervolgens worden de onderdelen die niet geldig zijn verwijderd
 */
NAV.validationTree = {
    directStart:false,
    session:{}
};
/**
 * valideerd procedures of sub procedures
 * @PARAM obj (te valideren (sub) procedure of macro
 * @PARAM defaultApp default applicatie kan ook null zijn
 * @RETURNS {Boolean}
 **/
NAV.validationTree.validate = function(obj, defaultApp){
    var application = obj.APP || defaultApp;

    //dummy part for home is always correct
    if(obj.isHome)  {
        return true;
    }

    if(obj.DSP === 'NO'){
        return false;
        obj.reason = "DSP=NO";
    }
    if(obj.isTarget){
        obj.reason = "is target";
        return false;
    }
    if(obj.MOD && !SESSION.session.validModules[obj.MOD]){
        obj.reason = "invalid MOD " + obj.MOD;
        return false;
    }
    if(!application){
        return true;
    }
    if(!SESSION.session.validApps[application]){
        obj.reason = "invalid app " + application;
        //console.log("unvalid app: " + application)
        return false;
    }
    return true;

};
/**
 * enumeratie
 * @type type
 */
NAV.validationTree.status = {
    'valid':'valid',
    'validisTarget':'validisTarget',
    'validNoChilds':'validNoChilds',
    'unValid':'unValid',
    'definitionMissing':'definitionMissing'
};

NAV.validationTree.setSession = function(definition, session, directStart){

    NAV.validationTree.sessionObject = session;
    NAV.validationTree.session = definition;
    NAV.validationTree.directStart = directStart;
    if(directStart){
        NAV.validationTree.setDirectStartProcedure(NAV.validationTree.session)
    }else{
        NAV.validationTree.setProcedures(NAV.validationTree.session);
    }

};

NAV.validationTree.setProcedures = function(session){
    var procedures = session.OPT;
    session.procedures = {};
    for(var i=0,l=procedures.length;i<l;i++){
        NAV.validationTree.addProcedure(procedures[i], session);
    }
};

NAV.validationTree.setDirectStartProcedure = function(session){
    var procedure = session.OPT[0];
    if(procedure.PRC){ //er zijn procedures gedefinieerd normaal verder initieren van boom
        NAV.validationTree.setProcedures(session);
    }
    session.procedures = {};
    // de direct start heeft geen procedure gedefineerd
    // de definities zijn van subProcedures
    // zelf een dummy procedure aanmaken en daaraan de sub procedures toevoegen
    procedure = {
        PRC: 'directStart',
        status:NAV.validationTree.status.validNoChilds,
        available:true,
        OPT:session.OPT
    };
    session.procedures['directStart'] =   procedure;
    NAV.validationTree.setSubProcedures(procedure);

};

NAV.validationTree.addProcedure = function(definition, session){
    var procedure = getEval(definition.PRC) || NAV.validationTree.sessionObject.homeProcedure,
        defaultApp = NAV.validationTree.session.DFTAPP,
        procedureName = definition.PRC;

    if(procedure){
        if(NAV.validationTree.validate(procedure, defaultApp)){
            procedure.status = NAV.validationTree.status.validNoChilds;
            procedure.available = true;
            NAV.validationTree.setSubProcedures(procedure);
        }else{
            procedure.status = NAV.validationTree.status.unValid;
            procedure.available = false;
        }
    }else{

        procedure = definition;
        procedure.available = false;
        procedure.status = NAV.validationTree.status.definitionMissing;
    }
    session.procedures[procedureName] =   procedure;
};


/**
 * voegt subProcedures toe aan procedure
 * zodra er een subProcedure met de status valid is toegevoegd
 * betekend dat er minstens 1 geldige optie is en
 * dat maakt de status van de procedure op zijn beurd ook geldig
 * @PARAM procedure
 **/
NAV.validationTree.setSubProcedures = function(procedure){
    procedure.subProcedures = {};
    for ( var i = 0, l = procedure.OPT.length; i < l; i++) {
        if(NAV.validationTree.addSubProcedure(procedure.OPT[i], procedure)){
            procedure.status = NAV.validationTree.status.valid;
        }
    }
    return (procedure.status === NAV.validationTree.status.valid || procedure.status === NAV.validationTree.status.validNoChilds);
};


/**
 * valideerd en voegt subProcedure toe aan procedure
 * @PARAM definition
 * @PARAM procedure
 * @RETURNS {Boolean} indicatie of subProcedure de status valid heeft
 **/
NAV.validationTree.addSubProcedure = function(definition, procedure){
    var subProcedure = getEval(definition.SBP)  || NAV.validationTree.sessionObject.homeSubProcedure ,
        defaultApp = procedure.DFTAPP;

    if(subProcedure){
        if (NAV.validationTree.validate(subProcedure,defaultApp)) {
            if(NAV.validationTree.setMacros(subProcedure)){
                subProcedure.status = NAV.validationTree.status.valid;
                subProcedure.available = true;
            }else{
                subProcedure.status = NAV.validationTree.status.validNoChilds;
                subProcedure.available = true;
            }
        }else{
            subProcedure.status = NAV.validationTree.status.unValid;
            subProcedure.available = false;
        }

    }else{
        subProcedure = definition;
        subProcedure.available = false;
        subProcedure.status = NAV.validationTree.status.definitionMissing;
    }

    procedure.subProcedures[definition.SBP] = subProcedure;
    return (subProcedure.status === NAV.validationTree.status.valid);
};

/**
 * voegt macros toe aan subProcedure
 * zodra er een macro met de status valid is toegevoegd
 * betekend dat er minstens 1 geldige macro is en
 * dat maakt de status van de subProcedure op zijn beurd ook geldig
 * @PARAM subProcedure
 **/
NAV.validationTree.setMacros = function(subProcedure){
    subProcedure.macros = {};
    var macro = null;
    var targets = {};

    //verzamel alle targets
    for ( var i = 0, l = subProcedure.OPT.length; i < l; i++) {
        macro = subProcedure.OPT[i];
        if(macro.TGT){
            targets[macro.TGT]= true;
        }
    }

    for ( var i = 0, l = subProcedure.OPT.length; i < l; i++) {
        macro = subProcedure.OPT[i];
        if(targets[macro.MCR]){
            macro.isTarget = true;
        }
        if(NAV.validationTree.addMacro(macro, subProcedure)){
            subProcedure.status = NAV.validationTree.status.valid;
        }
    }
    return (subProcedure.status === NAV.validationTree.status.valid );
};

/**
 * valideerd en voegt een macro toe aan subProcedure
 * @PARAM definition
 * @PARAM subProcedure
 * @RETURNS {Boolean} indicatie of de macro de status valid heeft
 **/
NAV.validationTree.addMacro = function(definition, subProcedure){
    var macro = definition,
        defaultApp = subProcedure.DFTAPP;
    if(macro){
        if (NAV.validationTree.validate(macro,defaultApp)) {
            macro.status = NAV.validationTree.status.valid;
            macro.available = true;
        }else{
            if(macro.isTarget){
                macro.status = NAV.validationTree.status.validisTarget;
            }else{
                macro.status = NAV.validationTree.status.unValid;
            }
            macro.available = false;
        }

    }else{
        macro = definition;
        macro.available = false;
        macro.status = NAV.validationTree.status.definitionMissing;
    }

    subProcedure.macros[definition.MCR] = macro;
    return (macro.status === NAV.validationTree.status.valid);
};

NAV.validationTree.getProcedure = function(procedureName){
    return  NAV.validationTree.session.procedures[procedureName] ||
        NAV.validationTree.session.procedures['directStart'] ||
        {};

};

NAV.validationTree.getSubProcedure = function(procedureName, subProcedureName){
    var procedure = NAV.validationTree.getProcedure(procedureName)
    var subProcedure = procedure.subProcedures[subProcedureName] || {};
    return subProcedure;
};

NAV.validationTree.getMacro = function(procedureName, subProcedureName, macroName){
    return NAV.validationTree.getSubProcedure(procedureName, subProcedureName).macros[macroName] || {};
};

/**
 * geeft aan of een macro of (sub) procedure geldig zijn
 * (sub) procedures hebben dan de status: NAV.validationTree.status.valid of NAV.validationTree.status.valid
 * macro's hebben de status: NAV.validationTree.status.valid of NAV.validationTree.status.validisTarget
 * @param {type} procedureName oor het controleren van een procedure
 * @param {type} subProcedureName optioneel voor het controleren van een subProcedure of Macro
 * @param {type} macroName optioneel voor het controleren van een macro procedure en sub proceduren dienen te zijn ingevuld
 * @returns {Boolean}
 * @see NAV.validationTree.status
 */
NAV.validationTree.isValid = function(procedureName, subProcedureName, macroName){
    var status = null;
    if(macroName){
        //macro objecten
        status = NAV.validationTree.getProcedure(procedureName, subProcedureName, macroName).status;
        return (status === NAV.validationTree.status.valid ||
            status === NAV.validationTree.status.validisTarget);
    }NAV.validationTree.isValid

    if(subProcedureName){
        //subprocedure objecten
        status = NAV.validationTree.getSubProcedure(procedureName).status;
    }else{
        //procedure objecten
        status = NAV.validationTree.getProcedure(procedureName, subProcedureName).status;
    }

    return (status === NAV.validationTree.status.valid ||
        status === NAV.validationTree.status.validNoChilds);
};

/**
 * geeft aan of navigatie element rechtstreeks opgenomen moet worden in respectievelijk
 * als procedure kop in het sessie menu (linker menu)
 * Als subprocedure knop in het bovenste knoppen menu binnen de sessie
 * Als macro tab direct na het kiezen van een subprocedure knop
 *
 * voor (sub) procedures gelden dat ze getoond worden als hun status valid zijn of als er geen onderliggende definite bekend is.
 * in het laatste geval wordt de knop uitgeschakeld en krijgt een afwijkende kleur zodat er direct een indicatie is dat er iets niet goed is gedefineerd
 *
 * voor macro's geld dat alleen macro's met de status valid worden weergegeven
 * tenzij deze macro's een target macro zijn.
 * target macro's hebben een isTarget eigenschap
 *
 * @param {type} procedureName oor het controleren van een procedure
 * @param {type} subProcedureName optioneel voor het controleren van een subProcedure of Macro
 * @param {type} macroName optioneel voor het controleren van een macro procedure en sub proceduren dienen te zijn ingevuld
 * @returns {Boolean}
 */

NAV.validationTree.showDirect = function(procedureName, subProcedureName, macroName){
    var status = null;
    if(macroName){
        status = NAV.validationTree.getMacro(procedureName, subProcedureName, macroName).status;
    }
    if(subProcedureName){

        status = NAV.validationTree.getSubProcedure(procedureName, subProcedureName).status;

    }else{
        status = NAV.validationTree.getProcedure(procedureName).status;
    }

    return ( status === NAV.validationTree.status.valid || status === NAV.validationTree.status.definitionMissing);
};


/**
 * geeft status aan van het navigatie element om te bepalen of deze
 * rechtstreeks opgenomen moet worden in respectievelijk
 * als procedure kop in het sessie menu (linker menu)
 * Als subprocedure knop in het bovenste knoppen menu binnen de sessie
 * Als macro tab direct na het kiezen van een subprocedure knop
 *
 * voor (sub) procedures gelden dat ze getoond worden als hun status valid zijn of als er geen onderliggende definite bekend is.
 * in het laatste geval wordt de knop uitgeschakeld en krijgt een afwijkende kleur zodat er direct een indicatie is dat er iets niet goed is gedefineerd
 *
 * voor macro's geld dat alleen macro's met de status valid worden weergegeven
 * tenzij deze macro's een target macro zijn.
 * target macro's hebben een isTarget eigenschap
 *
 * @param {type} procedureName oor het controleren van een procedure
 * @param {type} subProcedureName optioneel voor het controleren van een subProcedure of Macro
 * @param {type} macroName optioneel voor het controleren van een macro procedure en sub proceduren dienen te zijn ingevuld
 * @returns {object}
 */

NAV.validationTree.get= function(procedureName, subProcedureName, macroName){
    if(macroName){
        return NAV.validationTree.getMacro(procedureName, subProcedureName, macroName);
    }
    if(subProcedureName){
        return NAV.validationTree.getSubProcedure(procedureName, subProcedureName);
    }
    return NAV.validationTree.getProcedure(procedureName);
};



NAV.validationTree.log = function(){
    console.log(NAV.validationTree.session);
    return;
};

/* sessionMenu */
/* Load Timestamp 13:59:55.670 */
/* remove file */
/* procedure */
/* Load Timestamp 13:59:55.671 */
/* global NAV, SESSION, MAIN, GUI, XDOM, TabProtect, KeepAlive, advAJAX, PFMBOX, OCULUS */

NAV.Procedure = function(definition, optionNr, session) {
    this.type = 'procedure';
    this.session = session;
    this.optionNr = optionNr;
    this.option = definition;
    this.option.optionNr = optionNr;
    this.procedureName = definition.PRC;
    this.PRC = definition.PRC;
    this.title = definition.TTL;
    this.description = definition.DSC;
    this.subProcedures = [];
    //.buttonInstances = {};
    this.defaultSubProcedure = null;
    this.defaultApplication = '';
    this.defaultSubProcedureName = '';
    this.serverParameters = [];
    this.serverParametersValues = [];
    this.definition = null;
    this.previous = null;
    this.next = null;
    this.available = true;
    // this.button = new GUI.SessionMenuBtn(this);
    this.init();
    this.multiFormatTargets = [];
    this.workFlowTargets = {};
    this.isCleanUp = false;
    this.workflowTargets = {};
    this.level = 0;
};

NAV.Procedure.instances = [];
NAV.Procedure.currentInstance = null;

NAV.Procedure.prototype.init = function() {
    this.definition = getEval(this.procedureName)|| this.session.homeProcedure;

    if (this.definition) {
        this.defaultApplication = this.definition.DFTAPP;
        this.defaultSubProcedureName = this.definition.DFTSBP;
        if (this.definition.INZPRM) {
            this.serverParameters = this.definition.INZPRM;
        }
        if (this.definition.INZVAL) {
            this.serverParametersValues = this.definition.INZVAL;
        }
    } else {
        this.available = false;
    }
    if (SESSION.session.openFromfavourite) {
        this.defaultSubProcedureName = SESSION.session.openFromfavourite.SubProcedureName;
    }

    NAV.Procedure.instances[this.optionNr] = this;
};

NAV.Procedure.prototype.load = async function(subProcedure) {
    protectPage();
    if (NAV.Procedure.currentInstance) {
        NAV.Procedure.currentInstance.close();
    }

    SESSION.stack.currentSession.stack.add(this);
    NAV.Procedure.currentInstance = this;
    MAIN.NAV.Session.checkStatus(SESSION.stack.currentSession.id, false, true); //single job status check;
    this.setTitle();
    this.initOptions();
    await this.initServerParams(subProcedure)
    this.start(subProcedure);
};

NAV.Procedure.prototype.start = function(subProcedure = this.defaultSubProcedure) {
    //this.renderButtons();
    if (subProcedure) {
        TabProtect.createBlokker();
        subProcedure.load();
    } else {
        releasePage();
        //clear current frame source
        if (XDOM.getAttribute(SESSION.activeFrame.frameElement, 'data-frame-type') == 'Application') {
            XDOM.removeDOMObject(SESSION.activeForm);
        }
    }
    this.setMainButtons();

    SESSION.stack.currentSession.updateMainBtns();

    resetAllsubfilePositions();
};

NAV.Procedure.prototype.isValid = function(option) {
    if (option.DSP == 'NO') {
        return false;
    }
    if (!NAV.validationTree.showDirect(this.procedureName, option.SBP)) {
        return false;
    }
    if (!NAV.Stack.validate(option, this.defaultApplication)) {
        return false;
    }
    return true;
};

NAV.Procedure.prototype.prepareOptions = function() {
    var option = null;

    for (var i = 0, l = this.definition.OPT.length; i < l; i++) {
        option = this.definition.OPT[i];
        if (option.TYP == NAV.Stack.formatTyp.oldType) {
            option.TYP = NAV.Stack.formatTyp.workFlow;
        }
    }
};

NAV.Procedure.prototype.initOptions = function(options) {
    if (this.subProcedures.length > 0 || !this.definition) {
        return;
    } // -->

    let option = null,
        subProcedure = null;

    this.prepareOptions();
    for (var i = 0, l = this.definition.OPT.length; i < l; i++) {
        option = this.definition.OPT[i];
        if (!this.isValid(option)) {
            continue;
        }
        subProcedure = new NAV.SubProcedure(option, i, this);
        if (subProcedure.available && !this.defaultSubProcedure && this.defaultSubProcedureName != '*NONE') {
            this.defaultSubProcedure = subProcedure;
        }
        this.subProcedures.push(subProcedure);
        if (subProcedure.subProcedureName == this.defaultSubProcedureName) {
            // alser een default procedure is gedefinieerd of als er maar 1 subProcedure is
            this.defaultSubProcedure = subProcedure;
        }
    }
    if (this.defaultSubProcedure) {
        this.defaultSubProcedure.isDefault = true;
    }
};

NAV.Procedure.prototype.renderButtons = function() {};

/**
 *
 * @param subProcedure
 * @returns {Promise<boolean>}
 */
NAV.Procedure.prototype.initServerParams = async function(subProcedure) {

    let subToStart = subProcedure;
    if ((this.serverParameters.length == 0 && this.serverParametersValues.length == 0) || SESSION.submitInProgress) {
        return Promise.resolve();
    } // -->
    var fsUrl = SESSION.alias + '/box/ndmctl/inzsbp.ndm/main?PRCNAME=' + this.procedureName;

    if (this.serverParametersValues.length > 0) {
        fsUrl += '&PRMLEN=' + this.serverParametersValues.length;

        for (var i = 0, l = this.serverParametersValues.length; i < l; i++) {
            fsUrl += '&PRM' + (i + 1) + '=' + this.serverParametersValues[i].prm;
            fsUrl += '&VAL' + (i + 1) + '=' + this.serverParametersValues[i].val;
        }
    } else {
        fsUrl += '&PRMLEN=' + this.serverParameters.length;

        for (var i = 0, l = this.serverParameters.length; i < l; i++) {
            fsUrl += '&PRM' + (i + 1) + '=' + this.serverParameters[i];
        }
    }

    fsUrl += '&PFMJOBID=' + SESSION.jobId + '&AUTHTOKEN=' + SESSION.AUTHTOKEN;
    await fetch(fsUrl);

    // advAJAX.get({
    //   url: fsUrl,
    //   onSuccess: function(obj) {
    //     NAV.Procedure.initServerParamsResponse(subToStart);
    //   },
    //   onError: function(obj) {
    //     console.log('Fout: ' + fsUrl + ' / ' + PFMBOX.bLOADED_INZFCN + ' / ' + obj.status);
    //   }
    // });
    return;
};
//
// NAV.Procedure.initServerParamsResponse = function(subProc) {
//   NAV.Procedure.currentInstance.start(subProc);
// };

NAV.Procedure.prototype.close = function() {
    closeHighSlide();
    if (NAV.SubProcedure.currentInstance) {
        NAV.SubProcedure.currentInstance = null;
    }

    if (NAV.Macro.currentInstance) {
        NAV.Macro.currentInstance = null;
    }
    SESSION.stack.currentSession.stack.clearHistory(SESSION.stack.currentSession);
};

NAV.Procedure.prototype.setTitle = function() {
    let foPrcTitle = XDOM.getObject('macroDescription');
    XDOM.replaceAllChilds(foPrcTitle, XDOM.createTextNode(this.title));
    SESSION.stack.currentSession.setTitle();
};

/**
 * verwijderd referenties naar andere objecten en dom objecten in verband met
 * eventuele memory leaks
 */
NAV.Procedure.prototype.clearHistory = function() {
    if (this.isCleanUp) return;
    this.isCleanUp = true;
    if (this.next) {
        this.next.clearHistory();
        this.next = null;
    }
};

/**
 * verwijderd referenties naar andere objecten en dom objecten in verband met
 * eventuele memory leaks
 */
NAV.Procedure.prototype.cleanUp = function() {
    // this.button.cleanUp();
    // this.button = null;
    this.session = null;
    this.previous = null;
    this.next = null;
    this.cleanUpOptions();
};

NAV.Procedure.prototype.cleanUpOptions = function() {
    var foOption = null;
    for (var i = 0, l = this.subProcedures.length; i < l; i++) {
        foOption = this.subProcedures[i];
        if (foOption) {
            foOption.cleanUp();
        }
        this.subProcedures[i] = null;
    }
    this.subProcedures = [];
};

NAV.Procedure.prototype.toString = function() {
    var fsReturn = '<br/><b>procedure:</b><br/>';
    fsReturn += 'optionNr:' + this.optionNr + '<br/>';
    fsReturn += 'procedureName:' + this.procedureName + '<br/>';
    fsReturn += 'title:' + this.title + '<br/>';
    fsReturn += 'description:' + this.description + '<br/>';
    fsReturn += 'defaultSubProcedure:' + this.defaultSubProcedureName + '<br/>';
    fsReturn += 'defaultApplication:' + this.defaultApplication + '<br/>';
    fsReturn += '<hr />';
    if (this.next) {
        fsReturn += this.next;
    }
    return fsReturn;
};

NAV.Procedure.prototype.getDebugInfo = function() {
    return 'procedure :' + this.title + ' procedureName:' + this.procedureName;
};

// /**
//  * verkrijgt subprocedure op basis van naam
//  *
//  * @param fsSubProcedure
//  * @returns subprocedure of null
//  */
// NAV.Procedure.prototype.getSubProcedure = function(fsSubProcedure) {
//   var foOption = null;
//   for ( var i = 0, l = this.subProcedures.length; i < l; i++) {
//     foOption = this.subProcedures[i];
//     if (foOption.subProcedureName == fsSubProcedure) {
//       return foOption;
//     }
//   }
//   return null;
// };

/**
 * verkrijgt subprocedure op basis van naam
 *
 * @param name
 * @returns subprocedure of null
 */
NAV.Procedure.prototype.getSubProcedure = function(name) {
    return this.subProcedures.filter(proc => proc.SBP === name)[0];
};

NAV.Procedure.prototype.getFormatMacros = function() {
    var macros = {},
        macro = null,
        subProcedure = null;

    for (var i = 0, l = this.subProcedures.length; i < l; i++) {
        subProcedure = this.subProcedures[i];
        if (subProcedure.formatType == NAV.Stack.formatTyp.workFlow) {
            for (var s = 0, ml = subProcedure.options.length; s < ml; s++) {
                macro = subProcedure.options[s];
                if (macro.formatCode && !macros[macro.formatCode]) {
                    if (macro.macroName != SESSION.stack.currentMacro.macroName) {
                        macros[macro.formatCode] = macro.serverID;
                    }
                }
            }
        }
    }
    return macros;
};

NAV.Procedure.prototype.setMainButtons = function() {
    var foHelpBtn = null;
    var foPrintingBtn = null;
    if (SESSION.assistAvailable) {
        //MVB
        foHelpBtn = XDOM.getObject('procedureHelpIcon', MAIN.document);
        XDOM.setAttribute(foHelpBtn, 'data-button-enabled', 'true');
        OCULUS.procedureHelpUrl = SESSION.assistDir + this.procedureName + '.htm?TIMESTAMP=' + new Date().getTime();
        SESSION.stack.currentSession.procedureHelpUrl = OCULUS.procedureHelpUrl;
    }

    foPrintingBtn = XDOM.getObject('printSessionBtn', MAIN.document);

    if (foPrintingBtn && (SESSION.printAvailable !== undefined && !SESSION.printAvailable)) {
        XDOM.setAttribute(foPrintingBtn, 'data-button-enabled', 'false');
        SESSION.stack.currentSession.printingEnabled = false;
        return;
    }

    XDOM.setAttribute(foPrintingBtn, 'data-button-enabled', 'true');
    SESSION.stack.currentSession.printingEnabled = true;
};

/* subProcedure */
/* Load Timestamp 13:59:55.671 */
/* global NAV, SESSION, XDOM, KeepAlive, advAJAX */

NAV.SubProcedure = function(option, optionNr, procedure, previous) {
    this.type = 'subProcedure';
    this.optionNr = optionNr;
    this.procedure = procedure;
    this.option = option;
    this.option.nr = optionNr;
    this.option.PRC = procedure.PRC;
    /**
     * {string} format code voor een restrictie op de te tonen macro tabs en het bepalen van de default
     */
    this.macroFormatCode = null;
    /**
     * {string} actionCode geeft aan welke macro er opgestart moet worden
     */
    this.actionCode = null;
    this.available = true;
    this.isInitialized = false;
    this.application = option.APP;
    this.description = option.DSC;
    this.title = option.TTL;
    this.subProcedureName = option.SBP;
    this.SBP = option.SBP;
    this.formatType = option.TYP;
    this.isTarget = option.isTarget;
    this.restrictToTarget = null;
    this.definition = null;
    this.serverParameters = [];
    this.serverParametersValues = [];
    this.options = [];
    this.tabInstances = {};
    this.button = null;
    this.defaultApp = '';
    this.defaultMacroName = '';
    this.CHC = '';
    this.previous = previous || procedure;
    this.next = null;
    /*
   * voor de sturing bepaald of er een history wordt opgebouwd
   */
    this.clearHistoryOnClose = true;
    this.isCleanUp = false;
    this.init();
};

NAV.SubProcedure.instances = [];
NAV.SubProcedure.currentInstance = null;

// NAV.SubProcedure.initServerParamsResponse = function() {
//   NAV.SubProcedure.currentInstance.start();
// };

/**
 * Bepaald aan de hand van previous het type van de macro
 * Subprocedures zijn *MLTFMT als de aanroepende macro
 * (dat is de macro met als target deze subprocedure heeft)
 * .TYP = *MLTFMT
 *
 * Subprocedures zijn *WRKFLW als de definitie van de macor (dus niet de inhoudt van de macro)
 * .TYP = *WRKFLW is
 * als deze direct onder een procedure valt worden de target doorgegeven aan de procedure
 * het gaat dan altijd om *WRKFLW want er is geen aanroepende macro
 *
 * @returns {undefined}
 */
NAV.SubProcedure.prototype.setType = function() {
    if (this.previous.type == 'macro' && this.previous.formatType == NAV.Stack.formatTyp.multiFormat) {
        this.formatType = NAV.Stack.formatTyp.multiFormat;
    }
};

NAV.SubProcedure.prototype.init = function() {
    this.definition = getEval(this.subProcedureName) || this.procedure.session.homeSubProcedure;
    if (this.definition) {
        if (this.definition.INZPRM) {
            this.serverParameters = this.definition.INZPRM;
        }
        if (this.definition.INZVAL) {
            this.serverParametersValues = this.definition.INZVAL;
        }
        this.defaultApp = this.definition.DFTAPP;
        this.defaultMacroName = this.definition.DFTMCR;
        this.CHC = this.definition.CHC; // todo:naam uitzoeken
    } else {
        this.available = false;
    }
    NAV.SubProcedure.instances[this.optionNr] = this;
    this.setType();
    if (this.formatType == NAV.Stack.formatTyp.multiFormat || this.formatType == NAV.Stack.formatTyp.workFlow) {
        this.initOptions();
    }
};

NAV.SubProcedure.prototype.prepareOptions = function() {
    var name = '',
        option = null,
        options = {},
        target = '';

    for (var i = 0, l = this.definition.OPT.length; i < l; i++) {
        option = this.definition.OPT[i];
        //in het oude systeem is het fromat type MFT nu is het format Type afhankelijk
        //van het type macro
        //subprocedures met een TYP MFT is workflow
        //macro's  met het TYP MFT = multiformat
        // NAV.Stack.formatTyp.oldType = MFT
        if (option.MCR && option.TYP == NAV.Stack.formatTyp.oldType) {
            option.TYP = NAV.Stack.formatTyp.multiFormat;
        }
        if (option.SBP && option.TYP == NAV.Stack.formatTyp.oldType) {
            option.TYP = NAV.Stack.formatTyp.workFlow;
        }
        //controleer de optie in de huidige contekst geldig is
        if (!NAV.Stack.validate(option, this.defaultApp)) {
            continue;
        }
        name = option.MCR || option.SBP;
        options[name] = option;
    }
    for (name in options) {
        option = options[name];
        if (!option.TGT) {
            continue;
        }

        target = options[option.TGT];
        if (!target) {
            continue;
        }
        option.target = XDOM.clone(target);
        target.isTarget = true;
        if (option.TYP == NAV.Stack.formatTyp.multiFormat) {
        }
    }
};
/**
 * bepaald welke opties geldig zijn en welke ook direct zichtbaar moeten zijn.
 *
 * @returns {Array} van multi format targets
 */

NAV.SubProcedure.prototype.initOptions = function() {
    var option = null;
    var option = null;
    if (this.isInitialized || !this.available) {
        return;
    } // -->
    this.prepareOptions();
    this.tabInstances = {};
    for (var i = 0, l = this.definition.OPT.length; i < l; i++) {
        option = this.definition.OPT[i];

        if (!NAV.Stack.validate(option, this.defaultApp)) {
            continue;
        }
        if (option.MCR) {
            this.options.push(new NAV.Macro(option, this, i));
        }
        if (option.SBP) {
            this.options.push(new NAV.SubProcedure(option, i, this.procedure));
        }
    }
    this.isInitialized = true;
};

/**
 * bepaald welke opties geldig zijn en welke ook direct zichtbaar moeten zijn.
 *
 * @returns {Array} van multi format targets
 */
NAV.SubProcedure.prototype.getActionMacros = function() {
    var foMultiFormatTargets = [];
    var foMacro = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        foMacro = this.options[i];
        if (foMacro.actionCode) {
            foMultiFormatTargets[foMacro.actionCode] = foMacro;
        }
    }
    if (this.actionCode) {
        foMultiFormatTargets[this.actionCode] = this;
    }
    return foMultiFormatTargets;
};

/**
 * zoekt actionMacro
 * @returns {macroDefinition}
 */
NAV.SubProcedure.prototype.getActionMacro = function() {
    if (!this.actionCode) {
        return null;
    }

    let foMacro = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        foMacro = this.options[i];

        if (this.actionCode == foMacro.actionCode) {
            return foMacro;
        }
    }
    return null;
};

NAV.SubProcedure.prototype.isEqual = function(obj) {
    return this.subProcedureName == obj.subProcedureName;
};

NAV.SubProcedure.prototype.getFormatMacros = function() {
    var macros = {},
        macro = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        macro = this.options[i];
        if (macro.formatCode && !macros[macro.formatCode]) {
            if (macro.macroName != SESSION.stack.currentMacro.macroName) {
                macros[macro.formatCode] = macro.serverID;
            }
        }
    }
    return macros;
};

NAV.SubProcedure.prototype.getMacro = function(fsMacroName) {
    var foMacro = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        foMacro = this.options[i];

        if (foMacro.macroName == fsMacroName) {
            return foMacro;
        }
    }
    return null;
};

/**
 * geeft alle zichtbare tabbladen terug alleen opties die
 * niet van het type target zijn (foOption.isTarget)
 * zijn geldig als er een format code is gezet dan mogen alleen de macros die die code heeft getoond worden
 *
 * @returns {Array} van NAV.Macro objecten
 */
NAV.SubProcedure.prototype.getVisibleMacros = function() {
    var faMacros = [];
    var foMacro = null;
    if (this.restrictToTarget) {
        return [this.restrictToTarget];
    }
    for (var i = 0, l = this.options.length; i < l; i++) {
        foMacro = this.options[i];
        if (foMacro.type == 'subProcedure') {
            continue;
        } //alleen maar macros

        if (foMacro.display != '*ALWAYS') {
            //Optie altijd tonen
            if (foMacro.isTarget) {
                continue;
            } //geen targets
            if (foMacro.display == '*ACNONLY') {
                continue;
            } //geen actionOnly
        }

        if (
            this.formatType == NAV.Stack.formatTyp.workFlow &&
            foMacro.display == '*FMTONLY' &&
            foMacro.formatCode != this.macroFormatCode
        ) {
            continue;
        } //als de macro een formatCode en  .DSP = "*FMTONLY"; (display)  en deze subprocedure is workFlow
        //alleen dan marco tonen anders verbergen
        if (this.formatType == NAV.Stack.formatTyp.multiFormat && !setThenEqual(foMacro.formatCode, this.macroFormatCode)) {
            continue;
        } //als er een formatCode is en deze subprocedure is multiFormat
        //              //alleen de juiste macro's met format code tonen
        faMacros.push(foMacro);
    }

    return faMacros;
};

NAV.SubProcedure.prototype.activate = function() {
    SubProcedureButton.activate(this.SBP);
};
NAV.SubProcedure.prototype.load = async function() {
    if (NAV.SubProcedure.currentInstance) {
        NAV.SubProcedure.currentInstance.close();
    }

    if (SESSION.stack.currentProcedure) {
        SESSION.stack.clearHistory(SESSION.stack.currentProcedure);
    }

    SESSION.stack.add(this);
    // SESSION.stack.currentSession.updateTitle();

    this.restrictToTarget = null;
    this.initOptions();
    resetAllsubfilePositions();
    this.setDefaultMacro();
    //subProcedureMenu.activate(this.optionNr);
    //this.button.activate();

    await this.initServerParams()
    this.start();

    NAV.SubProcedure.currentInstance = this;
    SESSION.stack.currentSubprocedure = this;
    SESSION.stack.currentSession.setTitle();
};

NAV.SubProcedure.prototype.close = function() {
    if (NAV.Macro.currentInstance) {
        NAV.Macro.currentInstance = null;
    }
    if (this.clearHistoryOnClose) {
        SESSION.stack.clearHistory(this.procedure);
    }
    // de clearhistory boolean is eenmalig en moet elke keer weer op false worden gezet als de history moet worden
    // behouden
    this.clearHistoryOnClose = false;
};

NAV.SubProcedure.prototype.start = function() {
    if (this.defaultMacro) {
        this.defaultMacro.load();
    }
};

NAV.SubProcedure.prototype.setDefaultMacro = function() {
    this.defaultMacro = this.getDefaultMacro();
};

/**
 * als er format codes worden gebruikt is de eerste optie de defaultMacro zoals hieronder bepaald mits deze de juiste
 * format code heeft. is dit niet het geval dan wordt de eerst beschikbare optie met de format code gebruikt. omdat
 * format codes als ze niet gebruikt worden null zijn zal bepalen van de default macro deze wordt aangegeven door
 * this.defaultMacroName foFirstValidFormatOption in dat geval de eerste 0 optie zijn is deze niet gedefinieerd dan
 * wordt dus macro 0 (eerste optie gebruikt)
 *
 * @returns {object} macro
 */
NAV.SubProcedure.prototype.getDefaultMacro = function() {
    let foFirstValidFormatOption = null,
        foMacro = this.getfavouriteMacro() || this.getActionMacro();

    if (this.options.length == 0) {
        return null;
    }
    if (foMacro) {
        return foMacro;
    }

    for (var i = 0, l = this.options.length; i < l; i++) {
        foMacro = this.options[i];
        if (foMacro.isTarget) {
            continue;
        }
        if (foMacro.display == '*ACNONLY') {
            continue;
        }

        if (setThenEqual(this.macroFormatCode, foMacro.formatCode) && !foFirstValidFormatOption) {
            foFirstValidFormatOption = foMacro;
        }
        if (foMacro.macroName == this.defaultMacroName && setThenEqual(this.macroFormatCode, foMacro.formatCode)) {
            return foMacro;
        }
    }
    if (this.defaultMacroName == '*NONE') {
        return null;
    } else {
        return foFirstValidFormatOption;
    }
};

/**
 * als er een openFromfavourite definitie is geinstantieerd
 * wordt de bijbehorende macro geretourneerd
 * @returns {macrodefinition}
 */
NAV.SubProcedure.prototype.getfavouriteMacro = function() {
    if (!SESSION.session.openFromfavourite) {
        return null;
    }
    const macro = this.options.filter(opt => opt.macroName == SESSION.session.openFromfavourite.MacroName)[0];
    return macro;
};

NAV.SubProcedure.prototype.setRestrictions = function(fsFormatCode, fsActionCode) {
    this.macroFormatCode = nullWhenEmpty(fsFormatCode);
    this.actionCode = nullWhenEmpty(fsActionCode);
};

NAV.SubProcedure.prototype.clearRestrictions = function() {
    this.macroFormatCode = null;
    this.actionCode = null;
};

NAV.SubProcedure.prototype.getMacrosDefs = function() {
    if (SESSION.stack.currentMacro.display == '*ACNONLY' && hasValue(SESSION.stack.currentMacro.actionCode)) {
        // alleen deze tab mag
        return [SESSION.stack.currentMacro.definition];
    }
    let macros = this.getVisibleMacros();
    return macros.map(m => m.definition);
};

NAV.SubProcedure.prototype.renderTabs = function() {
    MacroTab.render(this.getMacrosDefs());

    return;
    // var macroWidth = 6;
    // var tabDiv = XDOM.getObject('TABDIV');
    // var faMacros = this.getVisibleMacros();
    // // de breedte van de tabs worden bepaald door het aantal te tonen tabs
    // // de grootse tab heeft de laagtse waarde de minimale waarde is 6

    // tabDiv.innerHTML = '';

    // if (SESSION.stack.currentMacro.display == '*ACNONLY' && hasValue(SESSION.stack.currentMacro.actionCode)) { // alleen deze tab mag
    //   // worden gerenderd
    //   SESSION.stack.currentMacro.tab.render(macroWidth);
    //   return;
    // }

    // if (faMacros.length > 6) {
    //   macroWidth = faMacros.length;
    // }

    // for (var i = 0, l = faMacros.length; i < l; i++) {
    //   if (faMacros[i].display != '*ACNONLY') { // mag alleen getoond als het de actieve macro is zie hierboven
    //     faMacros[i].tab.render(macroWidth, i+1, l);
    //   }
    // }
};

/**
 *
 * @returns {Promise<void>}
 */
NAV.SubProcedure.prototype.initServerParams = async function() {
    if ((this.serverParameters.length == 0 && this.serverParametersValues.length == 0) || SESSION.submitInProgress) {
        return Promise.resolve();
    } // -->
    // ***************************************************************************
    // Clear van parms opgegeven in SBP object
    // parms: fSBPPRM=de te clearen parameters
    // fSBP =SBP object
    // fSBPNM =SBP naam
    // return: --
    // ***************************************************************************
    var fsUrl = '?PRCNAME=' + this.subProcedureName;

    if (this.serverParametersValues.length > 0) {
        fsUrl += '&PRMLEN=' + this.serverParametersValues.length;

        for (var i = 0, l = this.serverParametersValues.length; i < l; i++) {
            fsUrl += '&PRM' + (i + 1) + '=' + this.serverParametersValues[i].prm;
            fsUrl += '&VAL' + (i + 1) + '=' + this.serverParametersValues[i].val;
        }
    } else {
        fsUrl += '&PRMLEN=' + this.serverParameters.length;

        for (var i = 0, l = this.serverParameters.length; i < l; i++) {
            fsUrl += '&PRM' + (i + 1) + '=' + this.serverParameters[i];
        }
    }
    fsUrl += '&PFMJOBID=' + SESSION.jobId + '&AUTHTOKEN=' + SESSION.AUTHTOKEN;

    fsUrl = SESSION.alias + '/box/ndmctl/inzsbp.ndm/main' + fsUrl;

    fsUrl = fsUrl.replace('#', '%23');

    await   fetch(fsUrl);

    // advAJAX.get({
    //   url: fsUrl,
    //   onSuccess: function(obj) {
    //     NAV.SubProcedure.initServerParamsResponse();
    //   },
    //   onError: function(obj) {
    //     console.log('Fout: ' + fsUrl + ' / ' + obj.status);
    //   }
    // });
};

/**
 * verwijderd referenties naar andere objecten en dom objecten in verband met eventuele memory leaks
 */
NAV.SubProcedure.prototype.clearHistory = function() {
    if (this.isCleanUp) return;
    this.isCleanUp = true;
    if (this.next) {
        this.next.clearHistory();
        this.next = null;
    }
};

NAV.SubProcedure.prototype.cleanUp = function() {
    if (this.button) {
        this.button.cleanUp();
    }
    this.button = null;
    this.procedure = null;
    this.application = null;
    this.previous = null;
    this.next = null;
    this.cleanUpOptions();
};

NAV.SubProcedure.prototype.cleanUpOptions = function() {
    var foOption = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        foOption = this.options[i];
        if (foOption) {
            foOption.cleanUp();
        }
        this.options[i] = null;
    }
    this.options = [];
};

NAV.SubProcedure.prototype.toString = function() {
    var fsReturn = '<br/><b>subProcedure:</b><br/>';
    fsReturn += 'optionNr:' + this.optionNr + '<br/>';
    fsReturn += 'title:' + this.title + '<br/>';
    fsReturn += 'application:' + this.application + '<br/>';
    fsReturn += 'description:' + this.description + '<br/>';
    fsReturn += 'defaultApp:' + this.defaultApp + '<br/>';
    fsReturn += 'defaultMacroName:' + this.defaultMacroName + '<br/>';
    fsReturn += '<hr />';
    if (this.next) {
        fsReturn += this.next;
    }
    return fsReturn;
};

NAV.SubProcedure.prototype.getDebugInfo = function() {
    return 'subProcedure : ' + this.title + '  subProcedureName: ' + this.subProcedureName + this.button;
};

NAV.SubProcedure.prototype.resetDirectTargets = function() {
    var foMacro = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        foMacro = this.options[i];
        foMacro.isDirectTarget = false;
    }
    this.restrictToTarget = null;
};

/**
 * verkrijgt subprocedure of de target Macro
 *
 * @param targetName
 * @returns subprocedure, macro of null
 */
NAV.SubProcedure.prototype.getTarget = function(targetName) {
    var foOption = null;
    var foReturn = null;
    for (var i = 0, l = this.options.length; i < l; i++) {
        foOption = this.options[i];
        if (foOption.macroName == targetName) {
            return foOption;
        }
        // target is een subprocedure
        if (foOption.subProcedureName == targetName) {
            if (foOption.type == 'subProcedure') {
                // de optie is als gedefinieerd als een subprocedure
                return foOption;
            }
            // als de subprocedure nog als target is gedefinieerd kijk of de subprocedure als optie in de procedure is
            // gedefinieerd
            foReturn = this.procedure.getSubProcedure(targetName);
            if (foReturn) {
                // de subprocedure is gevonden
                return foReturn;
            }
            // de subprocedure is niet gevonden en dus ook niet in de boom structuur opgenomen
            // er wordt een nieuwe subprocedure aangemaakt op basis van de definitie van de optie en geretourneerd
            return new NAV.SubProcedure(foOption.definition, null, this.procedure);
        }
    }
    //er is geen target gevonden in de huidige subprocedure
    //kijk of de target in de procedure is gedefinieerd

    return this.procedure.getSubProcedure(targetName);
};

/* macro */
/* Load Timestamp 13:59:55.671 */
NAV.Macro = function(def, subProcedure, id) {
    this.type = 'macro';
    this.id = id;
    this.subProcedure = subProcedure;
    this.targetSubProcedure = null;
    this.procedure = this.subProcedure.procedure;
    this.session = this.procedure.session;
    this.definition = def;
    this.title = def.TTL;
    this.titleText = null;
    this.description = def.DSC;
    this.macroName = nullWhenEmpty(def.MCR);
    this.MCR = this.macroName;
    this.subProcedureName = nullWhenEmpty(def.SBP);
    this.target = nullWhenEmpty(def.TGT);
    this.display = nullWhenEmpty(def.DSP);
    this.formatType = def.TYP || '';
    this.formatCode = nullWhenEmpty(def.FMT);
    this.actionCode = nullWhenEmpty(def.ACN);
    this.application = def.APP || subProcedure.defaultApp;
    this.containingDiv = 'SCRDIV';
    this.multiFormatTargets = null;
    this.userActionTargets = [];
    this.isDirectTarget = false;
    this.tab = null;
    this.url = '';
    this.previous = null;
    this.next = null;
    this.uploadCredentialsChecked = false;

    //info op server geregistreerd bij laden van pagina
    this.IDF = '';
    this.ISF = '';
    this.focusedButton = '';
    this.focusedField = '';
    this.messageLevel = '';
    this.messageQueue = '';
    this.document = null;
    this.activeForm = null;
    this.isCleanUp = false;
    this.isTarget = def.isTarget || false;
    this.serverID = subProcedure.subProcedureName + ' ' + this.application + ' ' + this.macroName;
    /*
   *voor de sturing bepaald of er een history wordt opgebouwd
   */
    this.clearHistoryOnClose = true;
    this.init();
};

NAV.Macro.instances = [];
NAV.Macro.currentInstance = null;
NAV.Macro.hovered = null;

/**
 * verwijderd referenties naar andere objecten en dom objecten in verband met eventuele memory leaks
 */
NAV.Macro.prototype.cleanUp = function() {
    //if(this.tab){
    //  this.tab.cleanUp();
    //}
    this.tab = null;
    this.subProcedure = null;
    this.procedure = null;
    this.session = null;
    this.application = null;
    this.previous = null;
    this.next = null;
};

NAV.Macro.prototype.init = function() {
    if (this.display != 'NO') {
        this.tab = new GUI.subProcedureTab(this);
    }
    if (this.definition.APP) {
        this.application = this.definition.APP;
    }

    if (!this.subProcedureName) {
        this.subProcedureName = this.subProcedure.subProcedureName;
    }
    this.initTargets();

    NAV.Macro.instances[this.id] = this;
};

NAV.Macro.prototype.getUserActionTargets = function() {
    this.userActionTargets = [];
    if (!(this.formatType == '*USRACN' || this.formatType == '*PMT_ML')) {
        return;
    }
    if (this.targetSubProcedure) {
        this.userActionTargets = this.targetSubProcedure.getActionMacros();
    } else {
        this.userActionTargets = this.subProcedure.getActionMacros();
    }
    return this.userActionTargets;
};

NAV.Macro.prototype.initTargets = function() {
    if (!isIn(this.formatType, ['*MLTFMT', '*WRKFLW', '*USRACN'])) {
        return;
    }
    var foSubOptions = this.subProcedure.definition.OPT;
    var foSubDef = null;
    for (var i = 0, l = foSubOptions.length; i < l; i++) {
        foSubDef = foSubOptions[i];
        if (foSubDef.SBP == this.target) {
            this.targetSubProcedure = new NAV.SubProcedure(foSubDef, i, this.procedure, this);

            this.multiFormatTargets = this.targetSubProcedure.initOptions();
            return;
        }
    }
};

NAV.Macro.prototype.load = function() {
    if (SESSION.stack.currentMacro) {
        SESSION.stack.currentMacro.close();
    }

    SESSION.stack.currentSession.stack.add(this);
    // SESSION.stack.currentSession.updateTitle();
    SESSION.stack.currentSession.setTitle();
    setFrames('*PGM');

    //sluit het sessieframe voordat er een marco laad
    Search.close();

    //this.tab.activate();
    MAIN.NAV.Session.checkStatus(SESSION.stack.currentSession.id, true, false); //retrieve job status met delay
    this.getUserActionTargets();

    this.start();
};
/**
 * sluiten van een macro
 */
NAV.Macro.prototype.close = function() {
    if (this.clearHistoryOnClose) {
        SESSION.stack.currentSession.stack.clearHistory(this.subProcedure);
    }
    //de clearHistory boolean is eenmalig en moet elke keer weer op false worden gezet als de history moet worden behouden
    this.clearHistoryOnClose = true;
};

NAV.Macro.prototype.start = function() {
    this.getUrl();
    NAV.Macro.currentInstance = this;

    protectPage();

    if (SESSION.submitInProgress) {
        setTimeout('NAV.Macro.currentInstance.start()', 20);
        return;
    }

    KeepAlive.cancel(); //stopt de keep alive job om dubbele requests te voorkomen
    SESSION.submitInProgress = true;
    AJAX.loadMacro(this);
    //reset global make sure favourite definition doesn't keep hanging around
    SCOPE.main.openingFavorite =  null;
};

NAV.Macro.prototype.getCurrentUrl = function() {
    var url = SESSION.alias + '/' + this.application + '/ndmctl/' + this.macroName + '.ndm/MAIN';
    return url;
};

NAV.Macro.prototype.getUrl = function() {
    var fsPreviousProgram = 'INZMNU';
    var fsPreviousMacro = '';
    if (NAV.Macro.currentInstance) {
        fsPreviousMacro = NAV.Macro.currentInstance.macroName;
        if (fsPreviousMacro && SESSION.pageStore[fsPreviousMacro]) {
            fsPreviousProgram = SESSION.pageStore[fsPreviousMacro].programName;
        }
    }
    this.url =
        SESSION.alias +
        '/' +
        this.application +
        '/ndmctl/' +
        this.macroName +
        '.ndm/MAIN?PFMJOBID=' +
        SESSION.jobId +
        '&AUTHTOKEN=' +
        SESSION.AUTHTOKEN +
        '&mIN_SBM=true' +
        '&pNM_PGM=' +
        fsPreviousProgram;
    return this.url;
};

NAV.Macro.prototype.setTitle = function(macroName) {
    var fsMacroName = this.macroName;
    var fTX_TTL = '';
    let altTitle = '';
    if (TopView.currentInstance) {
        altTitle = TopView.currentInstance.titleFromTarget || '';
    }
    this.macroTitle = XDOM.getObject('MACROTITLE');

    if (SESSION.activePage.screenType == '*SCH' || SESSION.isSingleView) {
        fsMacroName = SESSION.activePage.macroName;
        fTX_TTL = getCaption('TX_TTL', altTitle);

        if (fTX_TTL) {
            XDOM.replaceAllChilds(this.macroTitle, XDOM.createTextNode(fTX_TTL));
        }
    } else {
        if (SESSION.activePage.screenType == '*PGM') {
            if (SESSION.stack.currentProcedure) {
                XDOM.replaceAllChilds(this.macroTitle, XDOM.createTextNode(SESSION.stack.currentSubprocedure.title));
            }
        }
    }

    this.titleText =
        getCapt('cTX_USR') +
        ': ' +
        PFMBOX.PFMRMTUS +
        ' \x0A' +
        getCapt('cTX_ENV') +
        ': ' +
        PFMBOX.gCD_ENV +
        ' \x0A' +
        getCapt('cTX_ADM') +
        ': ' +
        PFMBOX.mEnvDB +
        ' \x0A' +
        getCapt('cTX_PGM') +
        ': ' +
        fsMacroName +
        ' \x0A' +
        getCapt('cTX_SSN') +
        ': ' +
        SESSION.jobId +
        ' \x0A' +
        getCapt('cTX_LNG') +
        ': ' +
        SESSION.language;

    this.printingTitleText =
        '<label>' +
        getCapt('cTX_USR') +
        ':</label> <output>' +
        PFMBOX.PFMRMTUS +
        '</output>' +
        '<label>' +
        getCapt('cTX_ENV') +
        ':</label> <output>' +
        PFMBOX.gCD_ENV +
        '</output> ' +
        '<label>' +
        getCapt('cTX_ADM') +
        ':</label> <output>' +
        PFMBOX.mEnvDB +
        '</output> ' +
        '<label>' +
        getCapt('cTX_PGM') +
        ':</label> <output>' +
        fsMacroName +
        '</output> ' +
        '<label>' +
        getCapt('cTX_SSN') +
        ':</label> <output>' +
        SESSION.jobId +
        '</output> ' +
        '<label>' +
        getCapt('cTX_LNG') +
        ':</label> <output>' +
        SESSION.language +
        '</output>' +
        '<label>' +
        getCapt('cTX_BRW') +
        ':</label> <output>' +
        BrowserDetect.browserUsed +
        '(v' +
        BrowserDetect.version +
        ')</output>';

    BrowserDetect.browserUsed + GUI.infoTitle.register(this.macroTitle, this.titleText);
};

/**
 * verwijderd referenties naar andere objecten en dom objecten in verband met eventuele memory leaks
 */
NAV.Macro.prototype.clearHistory = function() {
    if (this.isCleanUp) return;
    this.isCleanUp = true;
    if (this.next) {
        this.next.clearHistory();
        this.next = null;
    }
};

NAV.Macro.prototype.toString = function() {
    var fsReturn = '<br/><b>macro:</b><br/>';
    fsReturn += 'id:' + this.id + '<br/>';
    fsReturn += 'title:' + this.title + '<br/>';
    fsReturn += 'description:' + this.description + '<br/>';
    fsReturn += 'macroName:' + this.macroName + '<br/>';
    fsReturn += 'target:' + this.target + '<br/>';
    fsReturn += 'type:' + this.type + '<br/>';
    fsReturn += 'formatCode:' + this.formatCode + '<br/>';
    fsReturn += 'application:' + this.application + '<br/>';

    fsReturn += '<hr />';
    if (this.next) {
        fsReturn += this.next;
    }
    return fsReturn;
};

NAV.Macro.prototype.getDebugInfo = function() {
    return (
        'Macro: ' +
        this.title +
        ': ' +
        this.macroName +
        ' this.formatType: ' +
        this.formatType +
        '  userActionTargets:' +
        this.userActionTargets.join()
    );
};

/**
 * Verkrijgt macro behorende bij het target
 * de target kan een macro bionnen de zelfde subProcedure zijn of verwijzen naar een andere subProcedure
 * 1. als de target verwijst naar een macro dan deze openen
 * 2. als de target verwijst naar een subProcedure dan gelden de folgende regels:
 *   - is er spraken van een format code: open de default macro met die die formatCode of anders de eerste optie
 *   - is er spraken van een actie code: open de eerste optie met die actie code
 *   - is er geen format of actie code open dan de default macro
 *   - is er ook geen spraken van de default macro open dan de eerste macro
 *
 *   als er geen geldige macro te vinden is dan wordt er null geretourneerd
 *   voor alle gevallen geld dat er een historie wordt opgebouwd en het dus mogelijk is terug te gaan
 *   @param {string} fsFormatCode format code
 *   @param {string} fsActionCode actie code
 *   @returns {Object} of null;
 */
NAV.Macro.prototype.getTarget = function(fsFormatCode, fsActionCode) {
    var foTarget = null;
    var foMacro = null;
    //geen target gedefinieerd
    if (!this.target) {
        return null;
    }

    if (this.formatType == NAV.Stack.formatTyp.multiFormat) {
        foTarget = this.targetSubProcedure;
    } else {
        foTarget = this.subProcedure.getTarget(this.target);
    }

    if (!foTarget) {
        return null;
    } //geen target beschikbaar

    //we hebben een target het is een macro
    if (foTarget.type == 'macro') {
        foMacro = foTarget;
        foMacro.isDirectTarget = true;
    } else {
        //de target is een subprocedure
        foTarget.setRestrictions(fsFormatCode, fsActionCode);
        if (this.formatType == NAV.Stack.formatTyp.multiFormat) {
            foTarget.formatType == NAV.Stack.formatTyp.multiFormat;
        }
        foTarget.initOptions();
        foMacro = foTarget.getDefaultMacro();
        if (foMacro) {
            foMacro.isDirectTarget = false;
        }

    }
    return foMacro;
};

NAV.Macro.prototype.getFormatMacros = function() {
    if (this.subProcedure) {
        return this.subProcedure.getFormatMacros();
    } else {
        return {};
    }
};

/* stack */
/* Load Timestamp 13:59:55.672 */
/* global XDOM, SESSION, NAV, OCULUS, Stack */

//voorbeeld tekst
NAV.Stack = function () {
    this.currentSession = null;
    this.currentProcedure = null;
    this.nextSubprocedure = null;
    this.currentSubprocedure = null;
    this.currentMacro = null;
    this.nextMacro = null;
    this.current = null;
    this.activePage = null;
    this.breadCrums = [];
};

NAV.Stack.isFormated = function (obj) {
    return obj.formatType == NAV.Stack.formatTyp.multiFormat || obj.formatType == NAV.Stack.formatTyp.workFlow;
};

NAV.Stack.formatTyp = {
    multiFormat: '*MLTFMT',
    workFlow: '*WRKFLW',
    oldType: 'MFT'
};
/**
 * voegt een element aan de stack toe en zet de pointers previous en next
 * afhankelijk van het type object worden de members: currentSession
 * currentProcedure currentSubprocedure of currentMacro gezet
 *
 * @param obj
 */
NAV.Stack.prototype.add = function (obj) {
    if (this.current) {
        obj.previous = this.current;
        this.current.next = obj;
    }

    this.current = obj;

    switch (obj.type) {
        case 'session':
            this.currentSession = obj;
            obj.stack = this;
            break;
        case 'procedure':
            this.currentProcedure = obj;
            break;
        case 'subProcedure':
            this.currentSubprocedure = obj;
            this.currentProcedure = obj.procedure;
            break;
        case 'macro':
            this.currentMacro = obj;
            this.currentSubprocedure = obj.subProcedure;
            this.currentProcedure = obj.procedure;
            break;
    }
};

NAV.Stack.prototype.toString = function () {
    return this.currentSession.toString();
};

/**
 * de history dat na het mee gegeven element is opgebouwd weggooien Deze methode
 * verwijderd alle elementen die het element obj is toegevoegd aan de stack
 * tevens schoont hij afhankelijk van het type van obj de volgende members op:
 * currentSession currentProcedure currentSubprocedure currentMacro
 *
 * @param obj
 *          NAV object
 *
 */
NAV.Stack.prototype.clearHistory = function (obj) {
    //check if object exits and has clearHistory function
    if(!obj || typeof obj.clearHistory !== 'function') return;
    obj.clearHistory();
    this.current = obj;
    switch (obj.type) {
        case 'session':
            this.currentSession = obj;
            this.currentProcedure = null;
            this.currentSubprocedure = null;
            this.currentMacro = null;
            break;
        case 'procedure':
            this.currentProcedure = obj;
            this.currentSubprocedure = null;
            this.currentMacro = null;
            break;
        case 'subProcedure':
            this.currentProcedure = this.getPreviousProcedure();
            this.currentSubprocedure = this.getPreviousSubProcedure();
            this.currentMacro = null;

            break;
        case 'macro':
            this.currentMacro = obj;
            this.currentSubprocedure = this.getPreviousSubProcedure();
            this.currentProcedure = this.getPreviousProcedure();
            break;
    }
};

NAV.Stack.prototype.setCurrent = function (nav, activeForm) {
    this.activePage = activeForm;
    // var foPreviousMacro = this.getPreviousMacro();
    // if (foPreviousMacro) {
    //     this.addInputField('PrevMacroName', foPreviousMacro.macroName); // previous
    // } else {
    //     this.addInputField('PrevMacroName', ''); // previous Macroname
    // }
    this.setPreviousMacroFields();
    nav.Procedure.currentInstance = this.currentProcedure;
    nav.SubProcedure.currentInstance = this.currentSubprocedure;
    let targetOrWorkflow =
        this.currentSubprocedure.formatType == 'TGT' || this.currentSubprocedure.formatType == NAV.Stack.formatTyp.workFlow;

    if (this.currentMacro.formatCode && targetOrWorkflow) {
        this.currentSubprocedure.macroFormatCode = this.currentMacro.formatCode;
    }
    nav.Macro.currentInstance = this.currentMacro;
};

/**
 * retourneerd de eerste Macro die boven (terug in de hystorie) de huidige macro
 * in de stack staat
 *
 * @returns
 */
NAV.Stack.prototype.getPreviousMacro = function () {
    if (!this.currentMacro) {
        return null;
    }
    var obj = this.currentMacro.previous;
    var fiSecureCount = 0;
    while (obj && obj.type != 'macro') {
        obj = obj.previous;
        if (fiSecureCount++ > 100) {
            console.log('recursive probleem in NAV.Stack.prototype.getPreviousMacro ');
            return null;
        }
    }
    return obj;
};

/**
 * kijkt of compareObj eerder in de stack is opgenomen
 *
 * @param compareObj
 * @returns
 */
NAV.Stack.prototype.hasPreviousEntry = function (compareObj) {
    if (!this.currentMacro) {
        return null;
    }
    var obj = this.currentMacro.previous;
    var fiSecureCount = 0;
    while (obj) {
        obj = obj.previous;
        if (obj == compareObj) {
            return true;
        }
        if (fiSecureCount++ > 100) {
            console.log('recursive probleem in NAV.Stack.prototype.hasPreviousEntry ');
            return false;
        }
    }
    return false;
};

NAV.Stack.prototype.getPreviousProcedure = function () {
    if (!this.currentMacro) {
        return null;
    }
    var obj = this.currentMacro.previous;
    var fiSecureCount = 0;
    while (obj && obj.type != 'procedure') {
        obj = obj.previous;
        if (fiSecureCount++ > 100) {
            console.log('recursive probleem in NAV.Stack.prototype.getPreviousProcedure ');
            return null;
        }
    }
    return obj;
};

NAV.Stack.prototype.getTopSubprocedure = function () {
    var obj = this.currentSession;
    while (obj.next && obj.type != 'subProcedure') {
        obj = obj.next;
    }
    return obj;
};

NAV.Stack.prototype.getPreviousSubProcedure = function () {
    if (!this.currentMacro) {
        return null;
    }
    var obj = this.currentMacro.previous;
    var fiSecureCount = 0;
    while (obj && obj.type != 'subProcedure') {
        obj = obj.previous;
        if (fiSecureCount++ > 100) {
            console.log('recursive probleem in NAV.Stack.prototype.getPreviousProcedure ');
            return null;
        }
    }
    return obj;
};

/**
 * retourneerd een string met de titel op basis van de stack ten behoeve van de
 * Scherm Titel (de text boven de macro tabs) de stack kan als volgd zijn
 * opgebouwd: 1 sessie 2 procedure 3 subprocedure 4 macro 5 subprocedure 6 macro
 * 7 subprocedure 8 macro 9 macro de titel wordt als volgd bepaald: zoek de
 * macro op die boven jou in de stack staat deze leverd de titel als er geen
 * macro meer boven je staat (bij nr 4) dan neem je de titel van de boven
 * liggende subprocedure dit betekend dat macro 4 krijgt de titel van
 * subprocedure 3 macro 6 krijgt de titel van macor 4 macro 8 krijgt de titel
 * van macor 6 macro 9 krijgt de titel van macor 8
 *
 * @returns {String} titel als deze niet is gevonden dan geeft hij een lege
 *          string terug
 */
NAV.Stack.prototype.getTitle = function () {
    // return 'nog niet goed';
    var foMacro = this.getPreviousMacro();
    if (foMacro) {
        return foMacro.title;
    }
    if (this.currentSubprocedure) {
        return this.currentSubprocedure.title;
    }
    return '';
};

/**
 *
 */
NAV.Stack.prototype.sideWays = function () {
    this.clearHistory();
};

/**
 * Bouwd een lijst van hidden fields op op basis van de array van target macro's
 * elk veld krijgt een veldnaam met 'maCD_NXP_' als prefix met daar aan
 * toegevoegd de format code dus B.V. met formatcode RA heet het veld RA:
 * maCD_NXP_RA dit veld krijgt de waarde "subprocedurenaam applicatiecode
 * macronaam" met spaties gescheiden B.V. "GHOI0404 GHX GHON0404"
 *
 *          array van target macro's
 */
NAV.Stack.prototype.createMultiFormatFields = function () {
    var prefix = 'MultiFormat_';
    var macros = this.currentSubprocedure.getFormatMacros();
    for (var formatCode in macros) {
        this.addInputField(prefix + formatCode, macros[formatCode]); // next program
    }
};

NAV.Stack.prototype.setPreviousMacroFields = function () {
    var foPreviousMacro = this.getPreviousMacro();

    if (!foPreviousMacro) {
        // no previous found so clear the fields
        this.addInputField('PrevMacroName', '');
        this.addInputField('PrevMacroName', '');
        return
    }

    this.addInputField('PrevMacroName', foPreviousMacro.macroName); // previous
    this.addInputField('PrevAppCode', foPreviousMacro.application);

};

/**
 * Om het mogelijk te maken op de server door te prikken naar de juiste macro
 * moet er een lijst van hidden fields opgebouwd worden met daarin gegevens van
 * de huidige geldende target macro's target macro's zijn macro's van het
 * formatType='TGT' een lijst van target macro's (.multiFormatTargets) wordt
 * bijgehouden op procedure nivau en op macro niveau
 *
 * Als er onder een procedure een of meerdere subprocedures voorkomen van het
 * formatType='MFT' dan worden alle geldige macro's die onder die subprocedure
 * vallen met het formatType='TGT' opgenomen in de lijst van de subprocedure
 * .multiFormatTargets kan voor een procedure dus macro's bevatten vanuit
 * meerdere subprocedure's
 *
 * Als een macro het type='MFT' heeft dan bevat zijn .multiFormatTargets lijst
 * alle macro's van het typ='TGT' uit de subprocedure die die macro als target
 * heeft in dit geval zijn alle targets dus afkomstig uit 1 subproceure.
 *
 * de lijst van targetMacro's wordt in de functie this.createMultiFormatFields()
 *
 * Voorang van lijsten: er zijn twee scenario's mogelijk 1 er wordt van macro
 * gewisseld op de server dit kan door diverse oorzaken komen bijvoorbeeld door
 * te "rollen" binnen een subfile met een multiple format of automatisch
 * doorschakelen 2 er wordt van macro gewisseld door een onclick event op een
 * subfile in een multiFormat target hier gelden andere prioritijten
 *
 * deze functie houdt zich bezig met scenario 1 scenario twee wordt afgehandeld
 * door setSubfileTargetFields
 *
 * in volgorde van belangrijkheid word de lijst van .multiFormatTargets gebruikt
 * van 1 de vorige macro mits deze een multiFormat macro is (.formatType='MFT')
 * 2 de huidige macro als deze een multiFormat macro is (.formatType='MFT') 3 de
 * huidige procedure mits .multiFormat == true
 *
 * @see NAV.Stack.prototype.createMultiFormatFields
 * @param {type} activeForm
 * @param {type} submitFromSubfile
 * @returns {undefined}
 */
NAV.Stack.prototype.setFormatFields = function (activeForm, submitFromSubfile) {
    if (submitFromSubfile || this.currentSession.sessionScope.isSingleView) {
        return;
    }
    this.activePage = activeForm;
    if (this.currentSubprocedure.formatType == NAV.Stack.formatTyp.multiFormat) {
        this.createMultiFormatFields(this.currentMacro.previous);
    } else {
        this.createWorkFlowFields(this.currentMacro.previous);
    }
};

/**
 * Om het mogelijk te maken op de server door te prikken naar de juiste macro
 * moet er een lijst van hidden fields opgebouwd worden met daarin gegevens van
 * de huidige geldende target macro's target macro's zijn macro's van het
 * formatType='TGT' een lijst van target macro's (.multiFormatTargets) wordt
 * bijgehouden op procedure nivau en op macro niveau
 *
 * het laagste (nieuwste) niveau is afhankelijk van de actie binnen het scherm
 * bij doorschakelen via een subfile is de currentMacro het laagste niveau alle
 * andere acties begint bij het previous element van de currentMacro
 *
 * @param obj
 *          start object uit de stack
 * @returns {array} of null
 */
NAV.Stack.prototype.getMostRecentFormatMacros = function (obj) {
    var foNavObj = obj;
    var fiSecureCount = 0;
    while (!foNavObj.multiFormatTargets) {
        foNavObj = foNavObj.previous;
        if (!foNavObj) {
            return null;
        }
        if (fiSecureCount++ > 100) {
            console.log('recursive probleem in NAV.Stack.prototype.getMostRecentFormatMacros ');
            return null;
        }
    }
    if (!foNavObj.multiFormatTargets) {
        return null;
    }
    return foNavObj.multiFormatTargets;
};

/**
 * voegd een lijst van velden toe aan de te verzenden data
 * de velden zijn opgebouwd uit de namen WorkFlowLevel_#_[formatcode] en
 * bevatten de waarde
 * @param {obj} part
 * @returns {void}
 */
NAV.Stack.prototype.createWorkFlowFields = function (part) {
    var levels = [],
        prefix = 'WorkFlowLevel_',
        fieldName = '',
        level = 1,
        stackPart = this.currentProcedure,
        stackLevel = 1;
    if (!stackPart) {
        return;
    }
    levels.push({macros: this.currentProcedure.getFormatMacros(), level: 1});
    while (stackPart && stackPart.next != part) {
        if (stackPart.type == 'macro') {
            stackLevel++;
        }
        if (stackPart.type == 'subProcedure' && stackPart.formatType == NAV.Stack.formatTyp.workFlow) {
            levels.push( {macros: stackPart.getFormatMacros(), level: stackLevel});
        }
        stackPart = stackPart.next;
    }
    levels.push({macros: part.getFormatMacros(), level: 1});



    for (var i = 0, l = levels.length; i < l; i++) {
        level = levels[i];
        //if(!level) continue;
        for (var formatCode in level.macros) {
            fieldName = prefix + level.level + '_' + formatCode;
            this.addInputField(fieldName, level.macros[formatCode]);
        }
    }
    this.addInputField('StackLevel', stackLevel);
};

/**
 * maakt een associatieve array op basis van de de huidige procedure en de macro die wordt opgehaald via getMostRecentFormatMacros
 * @see NAV.Stack.prototype.getMostRecentFormatMacros
 * de meest recente macro's overschrijven de macro's uit de procedure zodat er nooit dubbele macro's kunnen zijn
 * als er meerdere format codes zijn geld de eerst gevonde format code teld en dan eerst de meest resente en daarna die van de subprocedure
 * @param obj stack object
 * @returns  associatieve array met macro's
 */
NAV.Stack.prototype.getFormatMacros = function (obj) {
    var foMostResentMultiFormat = this.getMostRecentFormatMacros(obj);
    var foFormattedMacros = {};
    var foTargetMacro = null;

    for (var i = 0, l = foMostResentMultiFormat.length; i < l; i++) {
        foTargetMacro = foMostResentMultiFormat[i];
        if (!foFormattedMacros[foTargetMacro.formatCode] && foTargetMacro.formatCode && foTargetMacro.macroName) {
            foFormattedMacros[foTargetMacro.formatCode] = foTargetMacro;
        }
    }

    for (var i = 0, l = this.currentProcedure.multiFormatTargets.length; i < l; i++) {
        foTargetMacro = this.currentProcedure.multiFormatTargets[i];
        if (!foFormattedMacros[foTargetMacro.formatCode] && foTargetMacro.formatCode && foTargetMacro.macroName) {
            foFormattedMacros[foTargetMacro.formatCode] = foTargetMacro;
        }
    }

    return foFormattedMacros;
};

/**
 * maakt een array op basis van de associatieve array die opgebouwd wordt in getFormatMacros
 * @param obj stack object
 * @returns array met macro's
 */
NAV.Stack.prototype.getFormatMacroArray = function (obj) {
    var foMacros = this.getFormatMacros(obj);
    var faRetMacros = [];

    for (var formatCode in foMacros) {
        faRetMacros.push(foMacros[formatCode]);
    }

    return faRetMacros;
};

/**
 * terug naar de vorige macro in de stack
 *
 * @param activeForm
 */
NAV.Stack.prototype.back = function (activeForm) {
    this.currentSubprocedure.restrictToTarget = null;

    var foMacro = this.getPreviousMacro();
    if (!foMacro) {
        return;
    }
    this.activePage = activeForm;
    this.addInputField('PrevAppCode', foMacro.application);
    this.addInputField('PrevMacroName', foMacro.macroName); // previous Macroname
    this.addInputField('SwitchMacro', 'true'); // next program
    this.addInputField('WS_CMD', 'CANCEL');
    this.addInputField('NextAppCode', foMacro.application); // volgende application ;
    this.addInputField('mNM_ENT', ''); // entry point
    this.clearHistory(foMacro);
};

NAV.Stack.clearFields = function (activePage) {
    var fieldsToClear = [
        'StackLevel',
        'SelectedSubfileRecord',
        'SwitchMacro',
        'mCD_ACN',
        'NextAppCode',
        'mNM_ENT',
        'PrevMacroName',
        'NextMacroName',
        'PrevAppCode',
        'WS_CMD'
    ];
    for (var i = 0, l = fieldsToClear.length; i < l; i++) {
        delete activePage.controlerFields[fieldsToClear[i]];
        //XDOM.setObjectValue(fieldsToClear[i],'');
    }
    for (var field in activePage.controlerFields) {
        if (field.indexOf('MultiFormat_') > -1) {
            delete activePage.controlerFields[field];
        }
    }

    //fieldsToClear = XDOM.queryAll("input[id^='maCD_NXP_']",SESSION.activeForm);
    //for(var i = 0,l=fieldsToClear.length;i<l;i++){
    //  XDOM.setObjectValue(fieldsToClear[i],'');
    //}
};

NAV.Stack.prototype.addInputField = function (fsName, fsValue) {

    //  console.log('maak:',fsName,fsValue);

    this.activePage.controlerFields[fsName] = fsValue;
    return;
};

NAV.Stack.prototype.debug = function () {
    var obj = this.currentSession;
    var fiSecureCount = 0;
    console.log('------------------------------------------------------------------'); // niet verwijderen
    console.log(obj.getDebugInfo()); // niet verwijderen

    while (obj.next) {
        obj = obj.next;
        console.log(obj.getDebugInfo()); // niet verwijderen
        if (fiSecureCount++ > 100) {
            console.log('recursive probleem in NAV.Stack.prototype.debug'); // niet verwijderen
        }
    }
    console.log('------------------------------------------------------------------'); // niet verwijderen
    return;
};
NAV.Stack.prototype.switchBack = function (staceMode) {
    if (staceMode != 'BWD') {
        return false;
    }

    var foMacro = this.getPreviousMacro();
    if(!foMacro){
        //No previous macro so nothing to switch back to,
        //return true to break out of the serverSwitch function that has been calling this.
        //This might occur when a manual navigation change is called by the user
        //while underlying macros are still loading in the background.
        return true;
    }
    this.clearHistory(foMacro);
    foMacro.subProcedure.resetDirectTargets();
    return true;
};
/**
 * bepaald of we van macro zijn veranderd
 * @param {type} loadedMacroName
 * @returns {boolean}
 */

NAV.Stack.prototype.noSwitch = function (loadedMacroName) {
    if (this.currentMacro && loadedMacroName == this.currentMacro.macroName) {
        // we blijven in de zelfde macro
        if (!this.currentMacro.isDirectTarget) {
            this.currentMacro.subProcedure.restrictToTarget = null;
        }
        return true;
    }
    return false;
};

NAV.Stack.prototype.getSubprocedure = function (subProcedureName) {
    //subprocedure blijft onveranderd
    if (subProcedureName == this.currentSubprocedure.subProcedureName) {
        return this.currentSubprocedure;
    }
    //subprocedure is target gedefinieerd in huidige subprocedure
    var subProc = this.currentSubprocedure.getTarget(subProcedureName);
    if (subProc) {
        return subProc;
    }
    subProc = this.currentMacro.previous;

    //subprocedure komt uit boom voor de huidige subprocedure
    while (subProc) {
        subProc = subProc.previous;
        if(!subProc) break;
        if (subProc.type == 'subProcedure' && subProc.subProcedureName) {
            return subProc;
        }
    }

    //subprocedure is gedefinieerd direct onder de procedure
    return this.currentProcedure.getSubProcedure(subProcedureName);
};

/**
 * op basis van de macro naam en procedure naam wordt gekeken of er op de server
 * geschakeld is naar een andere macro dan verwacht in dat geval wordt
 *
 * @param macroName
 * @param subProcedureName
 * @param fsStackMode
 *          *SWD|*FWD geeft aan of er binnen de subprocedure wordt gesprongen of
 *          een nivea dieper
 */
NAV.Stack.prototype.serverSwitch = function (macroName, subProcedureName, fsStackMode) {
    var subProcedure = null,
        macro = null;
    this.setNextAction(macroName);
    if (this.noSwitch(macroName)) {
        return;
    }
    if (this.switchBack(fsStackMode, macroName, subProcedureName)) {
        return;
    }

    subProcedure = this.getSubprocedure(subProcedureName);

    if (!subProcedure) {
        SCOPE.main.Dialogue.alert('sub procedure ' + subProcedureName + 'niet gevonden');
        return;
    }

    macro = subProcedure.getMacro(macroName);
    if (!macro) {
        SCOPE.main.Dialogue.alert('macro ' + macroName + ' uit sub procedure ' + subProcedureName + 'niet gevonden');
        return;
    }

    switch (fsStackMode) {
        case 'SWD':
            //schakelen binnen de zelfde subprocedure
            if (this.currentSubprocedure.isEqual(subProcedure)) {
                this.clearHistory(this.currentSubprocedure);
                this.add(macro);
                subProcedure.macroFormatCode = null;
            } else {
                //schakelen naar een andere subprocedure
                this.sideWaysToSPB(macro, subProcedure);
                return;
            }

            break;
        case 'FWD':
            if (!this.currentSubprocedure.isEqual(subProcedure)) {
                this.add(subProcedure);
            }
            subProcedure.macroFormatCode = macro.formatCode;
            this.add(macro);
    }

    this.activateTopSubprocedureButton();
};

NAV.Stack.prototype.sideWaysToSPB = function (macro, subProcedure) {
    this.clearHistory(this.currentProcedure);
    this.add(subProcedure);
    this.add(macro);
    this.currentProcedure.renderButtons();

    this.currentSubprocedure.activate();
};

NAV.Stack.prototype.activateTopSubprocedureButton = function () {
    var fosubProc = this.getTopSubprocedure();
    if (fosubProc && fosubProc.button) {
        fosubProc.procedure.renderButtons();
        fosubProc.button.activate();
    }
};

/**
 * activeer sub programma vanuit een subfile
 *
 * @param {type} subfileRecordNumber
 * @param {type} fsFormatCode
 * @param {type} fsActionCode
 * @param {type} activeForm
 * @returns {Boolean}
 */
NAV.Stack.prototype.setSubfileTargetFields = function (subfileRecordNumber, fsFormatCode, fsActionCode, activeForm) {
    //var foPreviousMacro = this.getPreviousMacro();
    var foTargetMacro = this.currentMacro.getTarget(fsFormatCode, fsActionCode);
    if (!foTargetMacro || foTargetMacro.display == '*ACNONLY') {
        return false;
    }

    var foSubrocedure = foTargetMacro.subProcedure;
    if (foTargetMacro.isDirectTarget) {
        foSubrocedure.restrictToTarget = foTargetMacro;
    } else {
        foSubrocedure.restrictToTarget = null;
    }

    this.activePage = activeForm;

    this.addInputField('SelectedSubfileRecord', stringValue(scriptToServer(subfileRecordNumber)));
    this.addInputField('SwitchMacro', 'true'); // next program
    this.addInputField('mCD_ACN', stringValue(fsActionCode)); // actie code
    this.addInputField('NextAppCode', foTargetMacro.application); // volgende
    this.addInputField('mNM_ENT', ''); // entry point

    // if (foPreviousMacro) {
    //     this.addInputField('PrevMacroName', foPreviousMacro.macroName); // previous
    // } else {
    //     this.addInputField('PrevMacroName', ''); // previous Macroname
    // }
    this.setPreviousMacroFields();
    this.addInputField('NextMacroName', foTargetMacro.macroName); // macro naam van
    if (foSubrocedure != this.currentSubprocedure) {
        this.add(foSubrocedure);
    }
    this.setFormatFields(activeForm);
    this.add(foTargetMacro);
    this.setPreviousMacroFields();
    return true;
};

/**
 * bij MFT doorschakelen kan RPG besluiten dat het om een recurrent aanroep moet gaan
 * dit is het geval bij een MFT waarbij een format type eigenlijk naar de MFT macro zelf verwijst
 * dit wordt echter niet zo in gericht maar in de RPG geregeld
 * in dat geval is er onterecht een stack opgebouwd en moet er weer een Hystorie back worden uitgevoerd.
 * dit is om deze manier gedaan om dat de stack bij de submit opgebouwd wordt maar pas bij de onload van de target is bekend dat het om een recurrent aanroep gaat
 * het hidden field mCD_RCR geeft aan dat het om een recurend subfile entry is
 */
NAV.Stack.prototype.setRecurrent = function () {
    var foMacro = this.getPreviousMacro();
    if (!foMacro) {
        return;
    }
    this.clearHistory(foMacro);
};

/**
 * activeer actie knop
 * @param {string} fsActionCode
 * @param {object} activeForm
 * @returns {void}
 */
NAV.Stack.prototype.setActionTargetFields = function (fsActionCode, activeForm) {
    //when we are in overlay no stack action are to be taken (this is always outside of the stack!
    if(SCOPE.session.SESSION.activePage.isOverlay()){
        return;
    }

    //var foPreviousMacro = this.getPreviousMacro();
    var foTargetMacro = this.currentMacro.getTarget(null, fsActionCode);

    if (!foTargetMacro) {
        // if (this.currentMacro.formatType == NAV.Stack.formatTyp.multiFormat)
        return false;
    }
    var foSubrocedure = foTargetMacro.subProcedure;

    if (foTargetMacro.isDirectTarget) {
        foSubrocedure.restrictToTarget = foTargetMacro;
    } else {
        foSubrocedure.restrictToTarget = null;
    }

    this.activePage = activeForm;
    this.addInputField('SwitchMacro', 'true'); // next program
    this.addInputField('mCD_ACN', stringValue(fsActionCode)); // actie code
    //this.addInputField('mCD_STC', 'NIX'); // toegevoegd stack opdracht
    this.addInputField('NextAppCode', foTargetMacro.application); // volgende
    this.addInputField('mNM_ENT', ''); // entry point
    this.setPreviousMacroFields();
    // if (foPreviousMacro) {
    //     this.addInputField('PrevMacroName', foPreviousMacro.macroName); // previous
    // } else {
    //     this.addInputField('PrevMacroName', ''); // previous Macroname
    // }
    //this.addInputField('mNM_CMC', this.currentMacro.macroName); // huidige macro
    this.addInputField('NextMacroName', foTargetMacro.macroName); // macro naam van

    this.createMultiFormatFields(this.currentMacro);
    if (foSubrocedure != this.currentSubprocedure) {
        this.nextSubprocedure = foSubrocedure;
    }
    this.nextMacro = foTargetMacro;
    return true;
};

NAV.Stack.prototype.setNextAction = function (fsMacroName) {
    if (!this.nextMacro) {
        return;
    }
    if (fsMacroName == this.nextMacro.macroName) {
        if (this.nextSubprocedure) {
            this.add(this.nextSubprocedure);
        }
        if (this.nextMacro) {
            this.add(this.nextMacro);
        }
    }
    this.nextSubprocedure = null;
    this.nextMacro = null;
};
/**

 * bepaald of een module beschikbaar voor de gebruiker op basis van het OCULUS.validApps en  array
 * als het option.MOD member niet bestaat wordt er vanuit gegaan dat de module beschikbaar is
 * is option.Mod gedefinieerd dan dient deze ook beschikbaar te zijn in de array:OCULUS.validModules array
 * het zelfde geld voor apps
 * @param {type} option navigatie Object
 * @param {type} application applicatie naam
 * @returns {Boolean}is de module ter beschikking
 */
NAV.Stack.validate = function (option, application) {
    var fsApplication = option.APP || application;

    if (fsApplication) {
        if(!SESSION.session.validApps[fsApplication]){
            return false;
        }
    }

    if (option.MOD) {
        if (!SESSION.session.validModules[option.MOD]) {
            return false;
        }
    }
    return NAV.Stack.isAuthorised(option);
};

NAV.Stack.isAuthorised = function (option) {
    var fsType = 'SBP';
    var fsName = option.SBP;

    var faAuthorisation = null;
    if (!option.USRAUT) {
        return true; //geen validatie nodig op deze optie
    }

    if (hasValue(option.MCR)) {
        //optie is geen subprocedure maar een macro
        fsType = 'MCR';
        fsName = option.MCR;
    }

    for (var i = 0, l = OCULUS.UserAuth.length; i < l; i++) {
        faAuthorisation = OCULUS.UserAuth[i];
        if (faAuthorisation[0] == fsType && faAuthorisation[1] == fsName) {
            return true;
        }
    }
    return false;
};

NAV.Stack.breadCrum = function (macro) {
    this.macroName = macro.macroName;
    this.description = macro.description;
    this.subProcedureName = macro.subProcedureName;
    this.application = macro.application;
    this.isEqual = function (macro) {
        return (
            this.macroName == macro.macroName &&
            this.application == macro.application &&
            this.subProcedureName == macro.subProcedureName
        );
    };
    this.inSameSubProcedure = function (macro) {
        return this.subProcedureName == macro.subProcedureName;
    };
};
NAV.Stack.prototype.logBreadCrums = function () {
    var trail = '',
        crum = null;
    for (var i = 0, l = this.breadCrums.length; i < l; i++) {
        crum = this.breadCrums[i];
        if (trail) {
            trail += '>>';
        }
        trail += crum.description + crum.macroName;
    }
    console.log('crums: ' + trail);
};

NAV.Stack.prototype.setBreadCrums = function () {
    var last = this.breadCrums[this.breadCrums.length - 1],
        previous = this.breadCrums[this.breadCrums.length - 2],
        newCrum = new NAV.Stack.breadCrum(this.currentMacro);

    if (!last) {
        //eerste macro in deze breadcrums;
        this.breadCrums.push(newCrum);
        return;
    }

    if (last.isEqual(newCrum)) {
        // geen verandering
        return;
    }

    if (!last.inSameSubProcedure(newCrum)) {
        //gewisseld van subProcedure
        //maak de breadCrums leeg
        this.breadCrums = [];
        //voeg nieuw crum toe
        this.breadCrums.push(newCrum);
        return;
    }
    if (previous && previous.isEqual(newCrum)) {
        //crum terug
        this.breadCrums.pop();
        return;
    }
    //volgende stap
    this.breadCrums.push(newCrum);
};

/* sessionLauncher */
/* Load Timestamp 13:59:55.672 */
/**
 * voor het starten van een nieuwe sessie via een token
 **/
NAV.sessionLauncher = {};

/**
 * loopt de sessie start objectenin de pagina door en controleerd of deze mogen worden getoond
 * eventueel anders maken zodat er met 1 ajax call alle validatie informatie kan owrden verzameld of eventueel met 1 ajax call per omgeving
 **/
/**
 * registratie van titels
 */
NAV.sessionLauncher.prepareDom = function() {
    var foObj = null;
    var fsTitle = '';
    var faPageObjects = XDOM.queryAllScope('[data-new-session-title]');
    for (var i = 0, l = faPageObjects.length; i < l; i++) {
        foObj = faPageObjects[i];
        fsTitle = foObj.getAttribute('data-new-session-title');
        fsTitle = getCaption(fsTitle, '');
        foObj.title = fsTitle;
    }
};

/**
 *
 * laat een nieuwe sessie
 * @param e event
 */

NAV.sessionLauncher.handleClick = function(e) {
    if (!XDOM.GLOBAL.getAttribute('data-new-session-location')) {
        return false;
    }
    var foSessionDef = {};
    var foSession = null;
    var fsDescriptionVarName = XDOM.GLOBAL.getAttribute('data-new-session-description');
    var fsDescription = getCaption(fsDescriptionVarName, fsDescriptionVarName);
    var fsTitle = GLOBAL.eventSourceElement.title;

    if(isStatelessObject(GLOBAL.eventSourceElement)){
        fsDescription = Stateless.Page.getCaption(fsDescriptionVarName) || fsDescription;
    }


    if (!MAIN.NAV.Session.checkMaxSessions()) {
        return true;
    }
    //data-new-session-id :voor de validatie
    //data-new-session-location-type voor de actie na het laden van de sessie


    foSessionDef.TYP = 'PGM'; //default
    foSessionDef.SON = 'usr'; //Default
    foSessionDef.DSC = fsDescription || fsTitle || XDOM.GLOBAL.getAttribute('data-new-session-location');
    foSessionDef.TTL = fsTitle;
    foSessionDef.PGM = XDOM.GLOBAL.getAttribute('data-new-session-location');
    foSessionDef.ENV = XDOM.GLOBAL.getAttribute('data-new-session-environment');
    foSessionDef.APP = XDOM.GLOBAL.getAttribute('data-new-session-source-location');

    foSession = new MAIN.NAV.Session(foSessionDef);
    foSession.isDirectStart = true;

    if (XDOM.GLOBAL.getAttribute('data-new-session-location-type') == '*PROCEDURE') {
        foProc = {};
        foProc.DFTAPP = foSessionDef.APP;
        foProc.MNUTTL = foSessionDef.TTL;
        foProc.MNUDSC = foSessionDef.DSC;
        foProc.SUBTTL = [];
        foProc.OPT = [];
        foProc.OPT[0] = {};
        foProc.OPT[0].PRC = foSessionDef.PGM;
        foProc.OPT[0].DSC = foSessionDef.DSC;
        foProc.OPT[0].TTL = foSessionDef.TTL;
        foSession.directStartProcedureDefinition = foProc;
    }

    foSession.parmKey = NAV.sessionLauncher.passParams();

    foSession.load();
    return true;
};

NAV.sessionLauncher.passParams = function() {
    var fsFormFields = XDOM.GLOBAL.getAttribute('data-new-session-form-fields');
    var fsParams = XDOM.GLOBAL.getAttribute('data-new-session-params');
    var fsEnvironment = XDOM.GLOBAL.getAttribute('data-new-session-environment');
    var recordNr = XDOM.GLOBAL.getAttribute('data-record-number');
    var record = null;
    var faFormFields = fsFormFields.split(' ');
    var faParams = fsParams.split(' ');
    var foFormData = new FormData();
    var foRequest = new XMLHttpRequest();
    var fsFieldName = '',
        fsValue = '',
        fsParam = '';

    var fsUrl =
        '/ndscgi/box/ndmctl/NewSession.ndm/ParmKey' +
        '?PFMFILID=' +
        fsEnvironment +
        '&PFMGRPID=' +
        PFMBOX.PFMGRPID +
        '&USRID=' +
        PFMBOX.PFMRMTUS +
        '&AUTHTOKEN=' +
        SESSION.AUTHTOKEN +
        '&PFMSOMTD=' +
        PFMBOX.PFMSOMTD;
    if (recordNr) {
        const index = serverToScript(recordNr)
        const data  = SESSION.activePage?.subfileData || SESSION.activeData?.subfileData || [];
        record = data[index]
    }

    for (var i = 0, l = faParams.length; i < l; i++) {
        fsParam = faParams[i];
        fsFieldName = faFormFields[i];
        if (recordNr) {
            fsValue = record[fsFieldName] || XDOM.getObjectValue(fsFieldName);
        } else {
            fsValue = XDOM.getObjectValue(fsFieldName);
        }

        fsUrl += '&PRM' + (i + 1) + '=' + fsParam + '&VAL' + (i + 1) + '=' + fsValue; // NewSession rekent op parms vanaf PRM1 en VAL1
    }

    /*add timestamp for unique data - IE11 problem*/
    fsUrl += '&TIMESTAMP=' + new Date().getTime();

    foRequest.open('GET', fsUrl, false); //asynchrone
    foRequest.send(foFormData);
    var fsParmKey = foRequest.responseText;
    return fsParmKey;
};

NAV.sessionLauncher.update = function() {
    const launchers = XDOM.queryAllScope('[data-new-session-environment-field-id]:not([data-record-number])');
    for (let i = 0, l = launchers.length; i < l; i++) {
        let launcher = launchers[i];
        launcher.dataset.newSessionEnvironment =
            SESSION.activePage.headerData[launcher.dataset.newSessionEnvironmentFieldId];
        NAV.sessionLauncher.authorize(launcher);
    }
};
NAV.sessionLauncher.authorize = function(obj) {
    if (!obj.dataset.newSessionEnvironmentFieldId) {
        return;
    }
    const authorizedFor = (obj.dataset.newSessionAuthorizedFor || '').split(','),
        envivronment = obj.dataset.newSessionEnvironment,
        isAuthorized = authorizedFor.indexOf(envivronment) > -1;

    obj.parentNode.dataset.hidden = !isAuthorized;
};

